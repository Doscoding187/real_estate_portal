var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc31) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc31 = __getOwnPropDesc(from, key)) || desc31.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// shared/const.ts
var COOKIE_NAME, ONE_YEAR_MS, UNAUTHED_ERR_MSG, NOT_ADMIN_ERR_MSG;
var init_const = __esm({
  "shared/const.ts"() {
    "use strict";
    COOKIE_NAME = "app_session_id";
    ONE_YEAR_MS = 1e3 * 60 * 60 * 24 * 365;
    UNAUTHED_ERR_MSG = "Please login (10001)";
    NOT_ADMIN_ERR_MSG = "You do not have required permission (10002)";
  }
});

// shared/_core/errors.ts
var HttpError, ForbiddenError;
var init_errors = __esm({
  "shared/_core/errors.ts"() {
    "use strict";
    HttpError = class extends Error {
      constructor(statusCode, message) {
        super(message);
        this.statusCode = statusCode;
        this.name = "HttpError";
      }
    };
    ForbiddenError = (msg) => new HttpError(403, msg);
  }
});

// drizzle/schema.ts
var schema_exports = {};
__export(schema_exports, {
  activities: () => activities,
  agencies: () => agencies,
  agencyBranding: () => agencyBranding,
  agencyJoinRequests: () => agencyJoinRequests,
  agencySubscriptions: () => agencySubscriptions,
  agentCoverageAreas: () => agentCoverageAreas,
  agentKnowledge: () => agentKnowledge,
  agentMemory: () => agentMemory,
  agentTasks: () => agentTasks,
  agents: () => agents,
  amenities: () => amenities,
  analyticsAggregations: () => analyticsAggregations,
  auditLogs: () => auditLogs,
  auditLogsRelations: () => auditLogsRelations,
  boostCampaigns: () => boostCampaigns,
  boostCampaignsRelations: () => boostCampaignsRelations,
  boostCredits: () => boostCredits,
  bundlePartners: () => bundlePartners,
  cities: () => cities,
  cityPriceAnalytics: () => cityPriceAnalytics,
  commissions: () => commissions,
  contentApprovalQueue: () => contentApprovalQueue,
  contentApprovalQueueRelations: () => contentApprovalQueueRelations,
  contentQualityScores: () => contentQualityScores,
  contentTopics: () => contentTopics,
  contentTopicsRelations: () => contentTopicsRelations,
  coupons: () => coupons,
  developerBrandProfiles: () => developerBrandProfiles,
  developerNotifications: () => developerNotifications,
  developerSubscriptionLimits: () => developerSubscriptionLimits,
  developerSubscriptionLimitsRelations: () => developerSubscriptionLimitsRelations,
  developerSubscriptionUsage: () => developerSubscriptionUsage,
  developerSubscriptionUsageRelations: () => developerSubscriptionUsageRelations,
  developerSubscriptions: () => developerSubscriptions,
  developerSubscriptionsRelations: () => developerSubscriptionsRelations,
  developers: () => developers,
  developersRelations: () => developersRelations,
  developmentApprovalQueue: () => developmentApprovalQueue,
  developmentApprovalQueueRelations: () => developmentApprovalQueueRelations,
  developmentDocuments: () => developmentDocuments,
  developmentDrafts: () => developmentDrafts,
  developmentLeadRoutes: () => developmentLeadRoutes,
  developmentPartners: () => developmentPartners,
  developmentPhases: () => developmentPhases,
  developmentPhasesRelations: () => developmentPhasesRelations,
  developmentUnits: () => developmentUnits,
  developmentUnitsRelations: () => developmentUnitsRelations,
  developments: () => developments,
  developmentsRelations: () => developmentsRelations,
  emailTemplates: () => emailTemplates,
  exploreBoostCampaigns: () => exploreBoostCampaigns,
  exploreCategories: () => exploreCategories,
  exploreComments: () => exploreComments,
  exploreContent: () => exploreContent,
  exploreCreatorFollows: () => exploreCreatorFollows,
  exploreDiscoveryVideos: () => exploreDiscoveryVideos,
  exploreEngagements: () => exploreEngagements,
  exploreFeedSessions: () => exploreFeedSessions,
  exploreFollows: () => exploreFollows,
  exploreHighlightTags: () => exploreHighlightTags,
  exploreInteractions: () => exploreInteractions,
  exploreLikes: () => exploreLikes,
  exploreNeighbourhoodFollows: () => exploreNeighbourhoodFollows,
  exploreNeighbourhoodStories: () => exploreNeighbourhoodStories,
  exploreNeighbourhoods: () => exploreNeighbourhoods,
  explorePartners: () => explorePartners,
  explorePartnersRelations: () => explorePartnersRelations,
  exploreSavedProperties: () => exploreSavedProperties,
  exploreShorts: () => exploreShorts,
  exploreSponsorships: () => exploreSponsorships,
  exploreTopics: () => exploreTopics,
  exploreUserPreferences: () => exploreUserPreferences,
  exploreUserPreferencesNew: () => exploreUserPreferencesNew,
  exploreVideoViews: () => exploreVideoViews,
  exploreVideos: () => exploreVideos,
  favorites: () => favorites,
  foundingPartners: () => foundingPartners,
  foundingPartnersRelations: () => foundingPartnersRelations,
  heroCampaigns: () => heroCampaigns,
  invitations: () => invitations,
  invites: () => invites,
  invoices: () => invoices,
  launchContentQuotas: () => launchContentQuotas,
  launchMetrics: () => launchMetrics,
  launchPhases: () => launchPhases,
  leadActivities: () => leadActivities,
  leads: () => leads,
  listingAnalytics: () => listingAnalytics,
  listingApprovalQueue: () => listingApprovalQueue,
  listingLeads: () => listingLeads,
  listingMedia: () => listingMedia,
  listingSettings: () => listingSettings,
  listingViewings: () => listingViewings,
  listings: () => listings,
  locationAnalyticsEvents: () => locationAnalyticsEvents,
  locationSearchCache: () => locationSearchCache,
  locationSearches: () => locationSearches,
  locationTargeting: () => locationTargeting,
  locations: () => locations,
  marketInsightsCache: () => marketInsightsCache,
  marketplaceBundles: () => marketplaceBundles,
  notifications: () => notifications,
  offers: () => offers,
  partnerLeads: () => partnerLeads,
  partnerLeadsRelations: () => partnerLeadsRelations,
  partnerSubscriptions: () => partnerSubscriptions,
  partnerSubscriptionsRelations: () => partnerSubscriptionsRelations,
  partnerTiers: () => partnerTiers,
  partnerTiersRelations: () => partnerTiersRelations,
  partners: () => partners,
  paymentMethods: () => paymentMethods,
  plans: () => plans,
  platformInquiries: () => platformInquiries,
  platformSettings: () => platformSettings,
  priceAnalytics: () => priceAnalytics,
  priceHistory: () => priceHistory,
  pricePredictions: () => pricePredictions,
  properties: () => properties,
  propertyClicks: () => propertyClicks,
  propertyImages: () => propertyImages,
  propertySimilarityIndex: () => propertySimilarityIndex,
  prospectFavorites: () => prospectFavorites,
  prospects: () => prospects,
  provinces: () => provinces,
  recentSearches: () => recentSearches,
  recentlyViewed: () => recentlyViewed,
  reviews: () => reviews,
  savedSearches: () => savedSearches,
  scheduledViewings: () => scheduledViewings,
  searchAnalytics: () => searchAnalytics,
  services: () => services,
  showings: () => showings,
  specVariations: () => specVariations,
  subscriptionEvents: () => subscriptionEvents,
  subscriptionPlans: () => subscriptionPlans,
  subscriptionUsage: () => subscriptionUsage,
  suburbPriceAnalytics: () => suburbPriceAnalytics,
  suburbReviews: () => suburbReviews,
  suburbReviewsRelations: () => suburbReviewsRelations,
  suburbs: () => suburbs,
  suburbsRelations: () => suburbsRelations,
  topics: () => topics,
  topicsRelations: () => topicsRelations,
  unitTypes: () => unitTypes,
  userBehaviorEvents: () => userBehaviorEvents,
  userOnboardingState: () => userOnboardingState,
  userPreferences: () => userPreferences,
  userRecommendations: () => userRecommendations,
  userSubscriptions: () => userSubscriptions,
  users: () => users,
  usersRelations: () => usersRelations,
  videoLikes: () => videoLikes,
  videos: () => videos
});
import { mysqlTable, index, int, varchar, text, json, mysqlEnum, timestamp, decimal, tinyint, boolean, unique, date } from "drizzle-orm/mysql-core";
import { sql, relations } from "drizzle-orm";
var activities, amenities, agencies, agencyBranding, agencyJoinRequests, agencySubscriptions, agentCoverageAreas, agents, analyticsAggregations, auditLogs, boostCredits, cities, cityPriceAnalytics, commissions, coupons, developerNotifications, developerSubscriptionLimits, developerSubscriptionUsage, developerSubscriptions, developers, developerBrandProfiles, developmentPhases, developmentUnits, developments, developmentPartners, developmentLeadRoutes, developmentApprovalQueue, developmentDrafts, heroCampaigns, unitTypes, specVariations, developmentDocuments, exploreCategories, exploreTopics, exploreNeighbourhoodStories, exploreSponsorships, emailTemplates, exploreComments, exploreFollows, exploreLikes, exploreVideoViews, exploreVideos, exploreHighlightTags, exploreInteractions, exploreShorts, exploreUserPreferences, favorites, invitations, invites, invoices, partners, leadActivities, leads, listingAnalytics, listingApprovalQueue, listingLeads, listingMedia, listingSettings, listingViewings, listings, locationSearchCache, locations, locationAnalyticsEvents, locationTargeting, locationSearches, recentSearches, marketInsightsCache, notifications, offers, paymentMethods, plans, platformSettings, platformInquiries, priceAnalytics, priceHistory, pricePredictions, properties, propertyImages, propertySimilarityIndex, prospectFavorites, prospects, provinces, recentlyViewed, reviews, savedSearches, searchAnalytics, propertyClicks, scheduledViewings, services, showings, subscriptionEvents, subscriptionPlans, subscriptionUsage, suburbPriceAnalytics, suburbs, suburbReviews, suburbsRelations, suburbReviewsRelations, userBehaviorEvents, userPreferences, userRecommendations, userSubscriptions, users, videoLikes, videos, exploreContent, exploreDiscoveryVideos, exploreNeighbourhoods, exploreUserPreferencesNew, exploreFeedSessions, exploreEngagements, exploreBoostCampaigns, exploreSavedProperties, exploreNeighbourhoodFollows, exploreCreatorFollows, developerSubscriptionsRelations, developerSubscriptionLimitsRelations, developerSubscriptionUsageRelations, usersRelations, developersRelations, developmentsRelations, developmentPhasesRelations, developmentUnitsRelations, developmentApprovalQueueRelations, auditLogsRelations, partnerTiers, explorePartners, topics, contentTopics, contentApprovalQueue, partnerSubscriptions, contentQualityScores, boostCampaigns, partnerLeads, marketplaceBundles, bundlePartners, launchPhases, launchContentQuotas, launchMetrics, userOnboardingState, foundingPartners, explorePartnersRelations, partnerTiersRelations, topicsRelations, contentTopicsRelations, partnerSubscriptionsRelations, boostCampaignsRelations, partnerLeadsRelations, contentApprovalQueueRelations, foundingPartnersRelations, agentMemory, agentTasks, agentKnowledge;
var init_schema = __esm({
  "drizzle/schema.ts"() {
    "use strict";
    activities = mysqlTable(
      "activities",
      {
        id: int().autoincrement().notNull(),
        developerId: int("developer_id").notNull().references(() => developers.id, { onDelete: "cascade" }),
        activityType: varchar("activity_type", { length: 50 }).notNull(),
        title: varchar({ length: 255 }).notNull(),
        description: text(),
        metadata: json(),
        relatedEntityType: mysqlEnum("related_entity_type", ["development", "unit", "lead", "campaign", "team_member"]),
        relatedEntityId: int("related_entity_id"),
        userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
        createdAt: timestamp("created_at", { mode: "string" }).notNull()
      },
      (table) => [
        index("idx_activities_developer_id").on(table.developerId),
        index("idx_activities_activity_type").on(table.activityType),
        index("idx_activities_created_at").on(table.createdAt),
        index("idx_activities_related_entity").on(table.relatedEntityType, table.relatedEntityId)
      ]
    );
    amenities = mysqlTable("amenities", {
      id: int().autoincrement().notNull(),
      locationId: int("location_id").notNull().references(() => locations.id, { onDelete: "cascade" }),
      name: varchar({ length: 255 }).notNull(),
      type: varchar({ length: 100 }).notNull(),
      rating: decimal({ precision: 3, scale: 1 }),
      latitude: varchar({ length: 50 }),
      longitude: varchar({ length: 50 }),
      distance: decimal({ precision: 10, scale: 2 }),
      metadata: json(),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    }, (table) => [
      index("idx_amenities_location_id").on(table.locationId),
      index("idx_amenities_type").on(table.type)
    ]);
    agencies = mysqlTable("agencies", {
      id: int().autoincrement().notNull(),
      name: varchar({ length: 255 }).notNull(),
      slug: varchar({ length: 255 }).notNull(),
      description: text(),
      logo: text(),
      website: varchar({ length: 255 }),
      email: varchar({ length: 320 }),
      phone: varchar({ length: 50 }),
      address: text(),
      city: varchar({ length: 100 }),
      province: varchar({ length: 100 }),
      subscriptionPlan: varchar({ length: 50 }).default("free").notNull(),
      subscriptionStatus: varchar({ length: 30 }).default("trial").notNull(),
      subscriptionExpiry: timestamp({ mode: "string" }),
      isVerified: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    agencyBranding = mysqlTable("agency_branding", {
      id: int().autoincrement().notNull(),
      agencyId: int().notNull().references(() => agencies.id, { onDelete: "cascade" }),
      primaryColor: varchar({ length: 7 }),
      secondaryColor: varchar({ length: 7 }),
      accentColor: varchar({ length: 7 }),
      logoUrl: text(),
      faviconUrl: text(),
      customDomain: varchar({ length: 255 }),
      subdomain: varchar({ length: 63 }),
      companyName: varchar({ length: 255 }),
      tagline: varchar({ length: 255 }),
      customCss: text(),
      metaTitle: varchar({ length: 255 }),
      metaDescription: text(),
      supportEmail: varchar({ length: 320 }),
      supportPhone: varchar({ length: 50 }),
      socialLinks: text(),
      isEnabled: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    agencyJoinRequests = mysqlTable("agency_join_requests", {
      id: int().autoincrement().notNull(),
      agencyId: int().notNull().references(() => agencies.id, { onDelete: "cascade" }),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      status: mysqlEnum(["pending", "approved", "rejected"]).default("pending").notNull(),
      message: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
      reviewedBy: int().references(() => users.id, { onDelete: "set null" }),
      reviewedAt: timestamp({ mode: "string" })
    });
    agencySubscriptions = mysqlTable("agency_subscriptions", {
      id: int().autoincrement().notNull(),
      agencyId: int().notNull().references(() => agencies.id, { onDelete: "cascade" }),
      planId: int().references(() => plans.id, { onDelete: "set null" }),
      stripeSubscriptionId: varchar({ length: 100 }),
      stripeCustomerId: varchar({ length: 100 }).notNull(),
      stripePriceId: varchar({ length: 100 }),
      status: mysqlEnum(["incomplete", "incomplete_expired", "trialing", "active", "past_due", "canceled", "unpaid"]).default("incomplete").notNull(),
      currentPeriodStart: timestamp({ mode: "string" }),
      currentPeriodEnd: timestamp({ mode: "string" }),
      trialEnd: timestamp({ mode: "string" }),
      cancelAtPeriodEnd: int().notNull(),
      canceledAt: timestamp({ mode: "string" }),
      endedAt: timestamp({ mode: "string" }),
      metadata: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    agentCoverageAreas = mysqlTable("agent_coverage_areas", {
      id: int().autoincrement().notNull(),
      agentId: int().notNull().references(() => agents.id, { onDelete: "cascade" }),
      areaName: varchar({ length: 255 }).notNull(),
      areaType: mysqlEnum(["province", "city", "suburb", "custom_polygon"]).notNull(),
      areaData: text().notNull(),
      isActive: int().default(1).notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    agents = mysqlTable("agents", {
      id: int().autoincrement().notNull(),
      userId: int().references(() => users.id, { onDelete: "cascade" }),
      agencyId: int().references(() => agencies.id, { onDelete: "set null" }),
      firstName: varchar({ length: 100 }).notNull(),
      lastName: varchar({ length: 100 }).notNull(),
      displayName: varchar({ length: 200 }),
      bio: text(),
      profileImage: text(),
      phone: varchar({ length: 50 }),
      email: varchar({ length: 320 }),
      whatsapp: varchar({ length: 50 }),
      specialization: text(),
      role: mysqlEnum(["agent", "principal_agent", "broker"]).default("agent").notNull(),
      licenseNumber: varchar({ length: 100 }),
      yearsExperience: int(),
      areasServed: text(),
      languages: text(),
      rating: int(),
      reviewCount: int(),
      totalSales: int(),
      isVerified: int().notNull(),
      isFeatured: int().notNull(),
      status: mysqlEnum(["pending", "approved", "rejected", "suspended"]).default("pending").notNull(),
      rejectionReason: text(),
      approvedBy: int().references(() => users.id, { onDelete: "set null" }),
      approvedAt: timestamp({ mode: "string" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    analyticsAggregations = mysqlTable("analytics_aggregations", {
      id: int().autoincrement().notNull(),
      aggregationType: mysqlEnum(["daily", "weekly", "monthly"]).notNull(),
      aggregationDate: varchar({ length: 10 }).notNull(),
      suburbId: int().references(() => suburbs.id, { onDelete: "cascade" }),
      cityId: int().references(() => cities.id, { onDelete: "cascade" }),
      provinceId: int().references(() => provinces.id, { onDelete: "cascade" }),
      propertyType: varchar({ length: 50 }),
      listingType: varchar({ length: 50 }),
      totalProperties: int(),
      activeListings: int(),
      avgPrice: int(),
      medianPrice: int(),
      minPrice: int(),
      maxPrice: int(),
      pricePerSqmAvg: int(),
      totalViews: int(),
      totalSaves: int(),
      totalContacts: int(),
      uniqueVisitors: int(),
      newListings: int(),
      soldProperties: int(),
      rentedProperties: int(),
      avgDaysOnMarket: int(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    auditLogs = mysqlTable("audit_logs", {
      id: int().autoincrement().notNull(),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      action: varchar({ length: 100 }).notNull(),
      targetType: varchar({ length: 50 }),
      targetId: int(),
      metadata: text(),
      ipAddress: varchar({ length: 45 }),
      userAgent: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    boostCredits = mysqlTable(
      "boost_credits",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        totalCredits: int("total_credits").default(0),
        usedCredits: int("used_credits").default(0),
        resetAt: timestamp("reset_at", { mode: "string" }),
        expiresAt: timestamp("expires_at", { mode: "string" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow()
      },
      (table) => [
        index("idx_user").on(table.userId),
        index("unique_user_credits").on(table.userId)
      ]
    );
    cities = mysqlTable(
      "cities",
      {
        id: int().autoincrement().notNull(),
        provinceId: int().notNull().references(() => provinces.id, { onDelete: "cascade" }),
        name: varchar({ length: 150 }).notNull(),
        slug: varchar({ length: 200 }),
        placeId: varchar("place_id", { length: 255 }),
        seoTitle: varchar("seo_title", { length: 255 }),
        seoDescription: text("seo_description"),
        latitude: varchar({ length: 20 }),
        longitude: varchar({ length: 21 }),
        isMetro: int().notNull(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_cities_slug").on(table.slug),
        index("idx_cities_place_id").on(table.placeId),
        index("idx_cities_slug_province").on(table.slug, table.provinceId)
      ]
    );
    cityPriceAnalytics = mysqlTable("city_price_analytics", {
      id: int().autoincrement().notNull(),
      cityId: int().notNull().references(() => cities.id, { onDelete: "cascade" }),
      provinceId: int().notNull().references(() => provinces.id, { onDelete: "cascade" }),
      currentAvgPrice: int(),
      currentMedianPrice: int(),
      currentMinPrice: int(),
      currentMaxPrice: int(),
      currentPriceCount: int(),
      sixMonthGrowthPercent: int(),
      threeMonthGrowthPercent: int(),
      oneMonthGrowthPercent: int(),
      totalProperties: int(),
      activeListings: int(),
      averageDaysOnMarket: int(),
      luxurySegmentPercent: int(),
      midRangePercent: int(),
      affordablePercent: int(),
      lastUpdated: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    commissions = mysqlTable("commissions", {
      id: int().autoincrement().notNull(),
      agentId: int().notNull().references(() => agents.id, { onDelete: "cascade" }),
      propertyId: int().references(() => properties.id, { onDelete: "set null" }),
      leadId: int().references(() => leads.id, { onDelete: "set null" }),
      amount: int().notNull(),
      percentage: int(),
      status: mysqlEnum(["pending", "approved", "paid", "cancelled"]).default("pending").notNull(),
      transactionType: mysqlEnum(["sale", "rent", "referral", "other"]).default("sale").notNull(),
      description: text(),
      payoutDate: timestamp({ mode: "string" }),
      paymentReference: varchar({ length: 100 }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    coupons = mysqlTable("coupons", {
      id: int().autoincrement().notNull(),
      code: varchar({ length: 50 }).notNull(),
      stripeCouponId: varchar({ length: 100 }),
      name: varchar({ length: 100 }),
      description: text(),
      discountType: mysqlEnum(["amount", "percent"]).default("percent").notNull(),
      discountAmount: int(),
      maxRedemptions: int(),
      redemptionsUsed: int().notNull(),
      validFrom: timestamp({ mode: "string" }),
      validUntil: timestamp({ mode: "string" }),
      isActive: int().default(1).notNull(),
      appliesToPlans: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    developerNotifications = mysqlTable(
      "developer_notifications",
      {
        id: int().autoincrement().notNull(),
        developerId: int("developer_id").notNull().references(() => developers.id, { onDelete: "cascade" }),
        userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
        title: varchar({ length: 255 }).notNull(),
        body: text().notNull(),
        type: varchar({ length: 50 }).notNull(),
        severity: mysqlEnum(["info", "warning", "error", "success"]).default("info").notNull(),
        read: tinyint().default(0).notNull(),
        actionUrl: varchar("action_url", { length: 500 }),
        metadata: json(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_developer_notifications_developer_id").on(table.developerId),
        index("idx_developer_notifications_user_id").on(table.userId),
        index("idx_developer_notifications_read").on(table.read),
        index("idx_developer_notifications_created_at").on(table.createdAt),
        index("idx_developer_notifications_type").on(table.type),
        index("idx_developer_notifications_feed").on(table.developerId, table.read, table.createdAt)
      ]
    );
    developerSubscriptionLimits = mysqlTable(
      "developer_subscription_limits",
      {
        id: int().autoincrement().notNull(),
        subscriptionId: int("subscription_id").notNull().references(() => developerSubscriptions.id, { onDelete: "cascade" }),
        maxDevelopments: int("max_developments").default(1).notNull(),
        maxLeadsPerMonth: int("max_leads_per_month").default(50).notNull(),
        maxTeamMembers: int("max_team_members").default(1).notNull(),
        analyticsRetentionDays: int("analytics_retention_days").default(30).notNull(),
        crmIntegrationEnabled: tinyint("crm_integration_enabled").default(0).notNull(),
        advancedAnalyticsEnabled: tinyint("advanced_analytics_enabled").default(0).notNull(),
        bondIntegrationEnabled: tinyint("bond_integration_enabled").default(0).notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_developer_subscription_limits_subscription_id").on(table.subscriptionId)
      ]
    );
    developerSubscriptionUsage = mysqlTable(
      "developer_subscription_usage",
      {
        id: int().autoincrement().notNull(),
        subscriptionId: int("subscription_id").notNull().references(() => developerSubscriptions.id, { onDelete: "cascade" }),
        developmentsCount: int("developments_count").default(0).notNull(),
        leadsThisMonth: int("leads_this_month").default(0).notNull(),
        teamMembersCount: int("team_members_count").default(0).notNull(),
        lastResetAt: timestamp("last_reset_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_developer_subscription_usage_subscription_id").on(table.subscriptionId)
      ]
    );
    developerSubscriptions = mysqlTable(
      "developer_subscriptions",
      {
        id: int().autoincrement().notNull(),
        developerId: int("developer_id").notNull().references(() => developers.id, { onDelete: "cascade" }),
        planId: int("plan_id").references(() => plans.id, { onDelete: "set null" }),
        tier: mysqlEnum(["free_trial", "basic", "premium"]).default("free_trial").notNull(),
        status: mysqlEnum(["active", "cancelled", "expired"]).default("active").notNull(),
        trialEndsAt: timestamp("trial_ends_at", { mode: "string" }),
        currentPeriodStart: timestamp("current_period_start", { mode: "string" }),
        currentPeriodEnd: timestamp("current_period_end", { mode: "string" }),
        stripeSubscriptionId: varchar("stripe_subscription_id", { length: 100 }),
        stripeCustomerId: varchar("stripe_customer_id", { length: 100 }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_developer_subscriptions_developer_id").on(table.developerId),
        index("idx_developer_subscriptions_status").on(table.status),
        index("idx_developer_subscriptions_tier").on(table.tier)
      ]
    );
    developers = mysqlTable(
      "developers",
      {
        id: int().autoincrement().notNull(),
        name: varchar({ length: 255 }).notNull(),
        slug: varchar({ length: 255 }),
        description: text(),
        logo: text(),
        website: varchar({ length: 255 }),
        email: varchar({ length: 320 }),
        phone: varchar({ length: 50 }),
        address: text(),
        city: varchar({ length: 100 }),
        province: varchar({ length: 100 }),
        category: mysqlEnum(["residential", "commercial", "mixed_use", "industrial"]).default("residential").notNull(),
        establishedYear: int(),
        totalProjects: int(),
        rating: int(),
        reviewCount: int(),
        isVerified: int().notNull(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
        userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
        status: mysqlEnum(["pending", "approved", "rejected"]).default("pending").notNull(),
        rejectionReason: text(),
        approvedBy: int().references(() => users.id, { onDelete: "set null" }),
        approvedAt: timestamp({ mode: "string" }),
        rejectedBy: int().references(() => users.id, { onDelete: "set null" }),
        rejectedAt: timestamp({ mode: "string" }),
        kpiCache: json(),
        lastKpiCalculation: timestamp({ mode: "string" }),
        completedProjects: int().default(0),
        currentProjects: int().default(0),
        upcomingProjects: int().default(0),
        trackRecord: text(),
        pastProjects: int(),
        specializations: json(),
        isTrusted: boolean("is_trusted").default(false).notNull()
      },
      (table) => [
        index("idx_developers_userId").on(table.userId),
        index("idx_developers_status").on(table.status),
        index("idx_developers_last_kpi_calculation").on(table.lastKpiCalculation)
      ]
    );
    developerBrandProfiles = mysqlTable("developer_brand_profiles", {
      id: int().autoincrement().notNull(),
      // Brand Identity
      brandName: varchar("brand_name", { length: 255 }).notNull(),
      slug: varchar({ length: 255 }).notNull(),
      logoUrl: text("logo_url"),
      about: text(),
      foundedYear: int("founded_year"),
      headOfficeLocation: varchar("head_office_location", { length: 255 }),
      operatingProvinces: json("operating_provinces").$type(),
      propertyFocus: json("property_focus").$type(),
      // estates, apartments, mixed-use
      websiteUrl: varchar("website_url", { length: 500 }),
      publicContactEmail: varchar("public_contact_email", { length: 320 }),
      // Brand Classification
      brandTier: mysqlEnum("brand_tier", ["national", "regional", "boutique"]).default("regional"),
      sourceAttribution: varchar("source_attribution", { length: 255 }),
      // where data came from
      // Governance & State
      profileType: mysqlEnum("profile_type", ["industry_reference", "verified_partner"]).default("industry_reference"),
      identityType: mysqlEnum("identity_type", ["developer", "marketing_agency", "hybrid"]).default("developer").notNull(),
      // NEW: Distinguish roles
      isSubscriber: tinyint("is_subscriber").default(0).notNull(),
      isClaimable: tinyint("is_claimable").default(1).notNull(),
      isVisible: tinyint("is_visible").default(1).notNull(),
      isContactVerified: tinyint("is_contact_verified").default(0).notNull(),
      // Refinement #2: track email verification
      linkedDeveloperAccountId: int("linked_developer_account_id").references(() => developers.id, { onDelete: "set null" }),
      ownerType: mysqlEnum("owner_type", ["platform", "developer"]).default("platform").notNull(),
      claimRequestedAt: timestamp("claim_requested_at", { mode: "string" }),
      // Refinement #5: sales SLA tracking
      // Lead Tracking (Monetisation Layer)
      totalLeadsReceived: int("total_leads_received").default(0).notNull(),
      lastLeadDate: timestamp("last_lead_date", { mode: "string" }),
      unclaimedLeadCount: int("unclaimed_lead_count").default(0).notNull(),
      // Audit
      createdBy: int("created_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
    }, (table) => [
      index("idx_brand_profiles_slug").on(table.slug),
      index("idx_brand_profiles_tier").on(table.brandTier),
      index("idx_brand_profiles_visible").on(table.isVisible),
      index("idx_brand_profiles_subscriber").on(table.isSubscriber),
      index("idx_brand_profiles_owner").on(table.ownerType)
    ]);
    developmentPhases = mysqlTable(
      "development_phases",
      {
        id: int().autoincrement().notNull(),
        developmentId: int("development_id").notNull().references(() => developments.id, { onDelete: "cascade" }),
        name: varchar({ length: 255 }).notNull(),
        phaseNumber: int("phase_number").notNull(),
        description: text(),
        status: mysqlEnum(["planning", "pre_launch", "selling", "sold_out", "completed"]).default("planning").notNull(),
        totalUnits: int("total_units").default(0).notNull(),
        availableUnits: int("available_units").default(0).notNull(),
        priceFrom: int("price_from"),
        priceTo: int("price_to"),
        launchDate: timestamp("launch_date", { mode: "string" }),
        completionDate: timestamp("completion_date", { mode: "string" }),
        // Phase optimization fields
        specType: mysqlEnum("spec_type", ["affordable", "gap", "luxury", "custom"]).default("affordable"),
        customSpecType: varchar("custom_spec_type", { length: 100 }),
        finishingDifferences: json("finishing_differences"),
        phaseHighlights: json("phase_highlights"),
        latitude: varchar({ length: 50 }),
        longitude: varchar({ length: 50 }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_development_phases_development_id").on(table.developmentId),
        index("idx_development_phases_status").on(table.status),
        index("idx_development_phases_spec_type").on(table.specType)
      ]
    );
    developmentUnits = mysqlTable(
      "development_units",
      {
        id: int().autoincrement().notNull(),
        developmentId: int("development_id").notNull().references(() => developments.id, { onDelete: "cascade" }),
        phaseId: int("phase_id").references(() => developmentPhases.id, { onDelete: "set null" }),
        unitNumber: varchar("unit_number", { length: 100 }).notNull(),
        unitType: mysqlEnum("unit_type", ["studio", "1bed", "2bed", "3bed", "4bed+", "penthouse", "townhouse", "house"]).notNull(),
        bedrooms: int(),
        bathrooms: decimal({ precision: 3, scale: 1 }),
        size: decimal({ precision: 10, scale: 2 }),
        price: decimal({ precision: 12, scale: 2 }).notNull(),
        floorPlan: text("floor_plan"),
        floor: int(),
        facing: varchar({ length: 50 }),
        features: text(),
        status: mysqlEnum(["available", "reserved", "sold"]).default("available").notNull(),
        reservedAt: timestamp("reserved_at", { mode: "string" }),
        reservedBy: int("reserved_by"),
        soldAt: timestamp("sold_at", { mode: "string" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("unique_unit_per_development").on(table.developmentId, table.unitNumber),
        index("idx_units_development_id").on(table.developmentId),
        index("idx_units_phase_id").on(table.phaseId),
        index("idx_units_status").on(table.status),
        index("idx_units_unit_type").on(table.unitType),
        index("idx_units_price").on(table.price)
      ]
    );
    developments = mysqlTable(
      "developments",
      {
        id: int().autoincrement().primaryKey().notNull(),
        developerId: int().references(() => developers.id, { onDelete: "cascade" }),
        developerBrandProfileId: int("developer_brand_profile_id").references(() => developerBrandProfiles.id, { onDelete: "set null" }),
        marketingBrandProfileId: int("marketing_brand_profile_id").references(() => developerBrandProfiles.id, { onDelete: "set null" }),
        // NEW: Marketing Agency
        marketingRole: mysqlEnum("marketing_role", ["exclusive", "joint", "open"]).default("exclusive"),
        // NEW: Mandate type
        name: varchar({ length: 255 }).notNull(),
        tagline: varchar({ length: 255 }),
        // NEW: Marketing tagline for hero section
        subtitle: varchar("subtitle", { length: 255 }),
        // NEW: Hero subtitle
        marketingName: varchar("marketing_name", { length: 255 }),
        // NEW: Optional branding name
        metaTitle: varchar("meta_title", { length: 255 }),
        // SEO Title
        metaDescription: text("meta_description"),
        // SEO Description
        slug: varchar({ length: 255 }),
        description: text(),
        rating: decimal({ precision: 3, scale: 2 }),
        // Auto-calculated rating
        developmentType: mysqlEnum(["residential", "commercial", "mixed_use", "land"]).notNull(),
        status: mysqlEnum([
          "launching-soon",
          "selling",
          "sold-out"
        ]).default("launching-soon").notNull(),
        legacyStatus: mysqlEnum("legacy_status", [
          "now-selling",
          "launching-soon",
          "under-construction",
          "ready-to-move",
          "sold-out",
          "phase-completed",
          "new-phase-launching",
          "planning",
          "completed",
          "coming_soon",
          "pre_launch",
          "ready"
        ]),
        // Retained for safety/audit
        constructionPhase: mysqlEnum("construction_phase", [
          "planning",
          "under_construction",
          "completed",
          "phase_completed"
        ]),
        // Internal operational status
        address: text(),
        city: varchar({ length: 100 }).notNull(),
        province: varchar({ length: 100 }).notNull(),
        suburb: varchar({ length: 100 }),
        locationId: int("location_id").references(() => locations.id, { onDelete: "set null" }),
        postalCode: varchar("postal_code", { length: 20 }),
        latitude: varchar({ length: 50 }),
        longitude: varchar({ length: 50 }),
        gpsAccuracy: mysqlEnum("gps_accuracy", ["accurate", "approximate"]).default("approximate"),
        totalUnits: int(),
        availableUnits: int(),
        priceFrom: int(),
        priceTo: int(),
        // Classification & Specs
        ownershipType: mysqlEnum("ownership_type", ["full-title", "sectional-title", "leasehold", "life-rights"]),
        structuralType: mysqlEnum("structural_type", ["apartment", "freestanding-house", "simplex", "duplex", "penthouse", "plot-and-plan", "townhouse", "studio"]),
        floors: mysqlEnum(["single-storey", "double-storey", "triplex"]),
        amenities: json().$type(),
        // Development amenities (Swimming Pool, Clubhouse, etc.)
        highlights: json().$type(),
        // Up to 5 development highlights
        features: json().$type(),
        // Estate-level features (Perimeter Wall, Fibre Ready, etc.)
        estateSpecs: json().$type(),
        // Structured specifications (Ownership, Power, Security, etc.)
        images: text(),
        videos: text(),
        floorPlans: text(),
        brochures: text(),
        completionDate: timestamp({ mode: "string" }),
        isFeatured: int().default(0).notNull(),
        isPublished: int().default(0).notNull(),
        publishedAt: timestamp({ mode: "string" }),
        // Approval Workflow
        approvalStatus: mysqlEnum("approval_status", ["draft", "pending", "approved", "rejected"]).default("draft"),
        readinessScore: int("readiness_score").default(0).notNull(),
        rejectionReasons: json("rejection_reasons"),
        rejectionNote: text("rejection_note"),
        showHouseAddress: int().default(1).notNull(),
        views: int().default(0).notNull(),
        inquiriesCount: int("inquiries_count").default(0),
        demandScore: int("demand_score").default(0),
        isHotSelling: int("is_hot_selling").default(0),
        // Identity & Classification (New)
        nature: mysqlEnum(["new", "phase", "extension", "redevelopment"]).default("new"),
        totalDevelopmentArea: int("total_development_area"),
        // mÂ²
        propertyTypes: json("property_types").$type(),
        // Multi-select: ['apartments', 'houses', 'townhouses']
        customClassification: varchar("custom_classification", { length: 255 }),
        // User input: "Loft, Duplex"
        // Global Financials
        monthlyLevyFrom: decimal("monthly_levy_from", { precision: 10, scale: 2 }),
        monthlyLevyTo: decimal("monthly_levy_to", { precision: 10, scale: 2 }),
        ratesFrom: decimal("rates_from", { precision: 10, scale: 2 }),
        ratesTo: decimal("rates_to", { precision: 10, scale: 2 }),
        transferCostsIncluded: tinyint("transfer_costs_included").default(0),
        isHighDemand: int("is_high_demand").default(0),
        // Brand Profile Ownership
        devOwnerType: mysqlEnum("dev_owner_type", ["platform", "developer"]).default("developer"),
        // platform = seeded/unmanaged, developer = subscriber-managed
        isShowcase: tinyint("is_showcase").default(0),
        // showcase listings for brand profiles
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_developments_developer_id").on(table.developerId),
        index("idx_developments_status").on(table.status),
        index("idx_developments_gps_accuracy").on(table.gpsAccuracy),
        index("idx_developments_suburb").on(table.suburb),
        index("idx_developments_location_id").on(table.locationId),
        unique("unique_slug").on(table.slug),
        index("idx_developments_rating").on(table.rating),
        index("idx_developments_published").on(table.isPublished, table.publishedAt)
      ]
    );
    developmentPartners = mysqlTable(
      "development_partners",
      {
        id: int().autoincrement().primaryKey(),
        developmentId: int("development_id").notNull().references(() => developments.id, { onDelete: "cascade" }),
        brandProfileId: int("brand_profile_id").notNull().references(() => developerBrandProfiles.id, { onDelete: "cascade" }),
        partnerType: mysqlEnum("partner_type", ["co_developer", "joint_venture", "investor", "builder", "marketing_agency", "selling_agency"]).default("co_developer").notNull(),
        permissions: json("permissions").$type(),
        visibilityScope: mysqlEnum("visibility_scope", ["profile_public", "internal_only", "marketing_only"]).default("profile_public").notNull(),
        displayOrder: int("display_order").default(0).notNull(),
        isPrimary: tinyint("is_primary").default(0).notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_dev_partners_development_id").on(table.developmentId),
        index("idx_dev_partners_brand_profile_id").on(table.brandProfileId),
        index("idx_dev_partners_partner_type").on(table.partnerType),
        unique("idx_dev_partner_unique").on(table.developmentId, table.brandProfileId)
      ]
    );
    developmentLeadRoutes = mysqlTable(
      "development_lead_routes",
      {
        id: int().autoincrement().primaryKey(),
        developmentId: int("development_id").notNull().references(() => developments.id, { onDelete: "cascade" }),
        sourceType: mysqlEnum("source_type", ["developer_profile", "agency_profile", "development_page", "campaign"]).notNull(),
        sourceBrandProfileId: int("source_brand_profile_id").references(() => developerBrandProfiles.id, { onDelete: "cascade" }),
        receiverBrandProfileId: int("receiver_brand_profile_id").notNull().references(() => developerBrandProfiles.id, { onDelete: "cascade" }),
        fallbackBrandProfileId: int("fallback_brand_profile_id").references(() => developerBrandProfiles.id, { onDelete: "set null" }),
        priority: int("priority").default(0).notNull(),
        isActive: tinyint("is_active").default(1).notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_lead_routes_development_id").on(table.developmentId),
        index("idx_lead_routes_source_type").on(table.sourceType),
        index("idx_lead_routes_lookup").on(table.developmentId, table.sourceType, table.sourceBrandProfileId)
      ]
    );
    developmentApprovalQueue = mysqlTable(
      "development_approval_queue",
      {
        id: int().autoincrement().notNull(),
        developmentId: int("development_id").notNull().references(() => developments.id, { onDelete: "cascade" }),
        submittedBy: int("submitted_by").notNull().references(() => users.id, { onDelete: "restrict" }),
        status: mysqlEnum(["pending", "reviewing", "approved", "rejected"]).default("pending").notNull(),
        submissionType: mysqlEnum("submission_type", ["initial", "update"]).default("initial").notNull(),
        reviewNotes: text("review_notes"),
        rejectionReason: text("rejection_reason"),
        complianceChecks: json("compliance_checks"),
        submittedAt: timestamp("submitted_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        reviewedAt: timestamp("reviewed_at", { mode: "string" }),
        reviewedBy: int("reviewed_by").references(() => users.id, { onDelete: "set null" })
      },
      (table) => [
        index("idx_dev_approval_status").on(table.status),
        index("idx_dev_approval_dev_id").on(table.developmentId)
      ]
    );
    developmentDrafts = mysqlTable(
      "development_drafts",
      {
        id: int().autoincrement().notNull(),
        developerId: int().references(() => developers.id, { onDelete: "cascade" }),
        developerBrandProfileId: int("developer_brand_profile_id").references(() => developerBrandProfiles.id, { onDelete: "cascade" }),
        draftName: varchar({ length: 255 }),
        draftData: json().notNull(),
        progress: int().default(0).notNull(),
        currentStep: int().default(0).notNull(),
        lastModified: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_dev_drafts_developer_id").on(table.developerId),
        index("idx_dev_drafts_brand_profile_id").on(table.developerBrandProfileId),
        index("idx_dev_drafts_last_modified").on(table.lastModified)
      ]
    );
    heroCampaigns = mysqlTable(
      "hero_campaigns",
      {
        id: int().autoincrement().primaryKey(),
        locationType: mysqlEnum("location_type", ["province", "city", "suburb"]).notNull(),
        targetSlug: varchar("target_slug", { length: 255 }).notNull(),
        imageUrl: varchar("image_url", { length: 1024 }).notNull(),
        landingPageUrl: varchar("landing_page_url", { length: 1024 }),
        altText: varchar("alt_text", { length: 255 }),
        startDate: timestamp("start_date", { mode: "string" }),
        endDate: timestamp("end_date", { mode: "string" }),
        isActive: tinyint("is_active").default(1).notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull()
      },
      (table) => [
        index("idx_hero_campaigns_slug").on(table.targetSlug),
        index("idx_hero_campaigns_active").on(table.isActive),
        index("idx_hero_campaigns_dates").on(table.startDate, table.endDate)
      ]
    );
    unitTypes = mysqlTable(
      "unit_types",
      {
        id: varchar({ length: 36 }).primaryKey(),
        developmentId: int("development_id").notNull().references(() => developments.id, { onDelete: "cascade" }),
        // Basic Configuration - NEW columns added to match production
        label: varchar({ length: 255 }),
        name: varchar({ length: 255 }).notNull(),
        description: text(),
        ownershipType: mysqlEnum("ownership_type", ["full-title", "sectional-title", "leasehold", "life-rights"]).default("sectional-title"),
        structuralType: mysqlEnum("structural_type", ["apartment", "freestanding-house", "simplex", "duplex", "penthouse", "plot-and-plan", "townhouse", "studio"]).default("apartment"),
        floors: mysqlEnum(["single-storey", "double-storey", "triplex"]),
        // Room Configuration
        bedrooms: int().notNull(),
        bathrooms: decimal({ precision: 3, scale: 1 }).notNull(),
        // Parking
        parking: mysqlEnum(["none", "1", "2", "carport", "garage"]).default("none"),
        parkingType: varchar("parking_type", { length: 50 }),
        parkingBays: int("parking_bays").default(0),
        // Sizes
        unitSize: int("unit_size"),
        yardSize: int("yard_size"),
        sizeFrom: int("size_from"),
        sizeTo: int("size_to"),
        // Pricing - NEW price_from/price_to columns
        priceFrom: decimal("price_from", { precision: 15, scale: 2 }),
        priceTo: decimal("price_to", { precision: 15, scale: 2 }),
        basePriceFrom: decimal("base_price_from", { precision: 15, scale: 2 }).notNull(),
        basePriceTo: decimal("base_price_to", { precision: 15, scale: 2 }),
        depositRequired: decimal("deposit_required", { precision: 15, scale: 2 }),
        // Stock Tracking
        totalUnits: int("total_units").default(0).notNull(),
        availableUnits: int("available_units").default(0).notNull(),
        reservedUnits: int("reserved_units").default(0),
        completionDate: date("completion_date"),
        // Pricing Details
        transferCostsIncluded: tinyint("transfer_costs_included").default(0),
        monthlyLevy: int("monthly_levy"),
        monthlyLevyFrom: int("monthly_levy_from"),
        monthlyLevyTo: int("monthly_levy_to"),
        ratesAndTaxesFrom: int("rates_and_taxes_from"),
        ratesAndTaxesTo: int("rates_and_taxes_to"),
        // Pricing Extras
        extras: json("extras").$type(),
        // Base Features (Defaults for all specs)
        baseFeatures: json("base_features").$type(),
        // Base Finishes
        baseFinishes: json("base_finishes").$type(),
        // Base Media (Inherited by all specs)
        baseMedia: json("base_media").$type(),
        // NEW: Structured JSON columns
        specOverrides: json("spec_overrides"),
        specifications: json("specifications"),
        amenities: json("amenities"),
        features: json("features"),
        // NEW: Description/Notes columns
        configDescription: text("config_description"),
        virtualTourLink: varchar("virtual_tour_link", { length: 500 }),
        internalNotes: text("internal_notes"),
        // Metadata
        displayOrder: int("display_order").default(0),
        isActive: tinyint("is_active").default(1),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_unit_types_development_id").on(table.developmentId),
        index("idx_unit_types_price_range").on(table.basePriceFrom, table.basePriceTo),
        index("idx_unit_types_bedrooms_bathrooms").on(table.bedrooms, table.bathrooms),
        index("idx_unit_types_display_order").on(table.displayOrder)
      ]
    );
    specVariations = mysqlTable(
      "spec_variations",
      {
        id: varchar({ length: 36 }).primaryKey(),
        unitTypeId: varchar("unit_type_id", { length: 36 }).notNull().references(() => unitTypes.id, { onDelete: "cascade" }),
        // Basic Info
        name: varchar({ length: 255 }).notNull(),
        price: decimal({ precision: 15, scale: 2 }).notNull(),
        description: text(),
        // Overrides (optional - only store if different from base)
        overrides: json().$type(),
        // Feature Overrides
        featureOverrides: json("feature_overrides").$type(),
        // Spec-Specific Media (overrides base media)
        media: json().$type(),
        // Metadata
        displayOrder: int("display_order").default(0),
        isActive: tinyint("is_active").default(1),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_spec_variations_unit_type_id").on(table.unitTypeId),
        index("idx_spec_variations_price").on(table.price),
        index("idx_spec_variations_display_order").on(table.displayOrder)
      ]
    );
    developmentDocuments = mysqlTable(
      "development_documents",
      {
        id: varchar({ length: 36 }).primaryKey(),
        developmentId: int("development_id").notNull().references(() => developments.id, { onDelete: "cascade" }),
        unitTypeId: varchar("unit_type_id", { length: 36 }).references(() => unitTypes.id, { onDelete: "cascade" }),
        name: varchar({ length: 255 }).notNull(),
        type: mysqlEnum(["brochure", "site-plan", "pricing-sheet", "estate-rules", "engineering-pack", "other"]).notNull(),
        url: varchar({ length: 500 }).notNull(),
        fileSize: int("file_size"),
        mimeType: varchar("mime_type", { length: 100 }),
        uploadedAt: timestamp("uploaded_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_dev_docs_development_id").on(table.developmentId),
        index("idx_dev_docs_unit_type_id").on(table.unitTypeId),
        index("idx_dev_docs_type").on(table.type)
      ]
    );
    exploreCategories = mysqlTable("explore_categories", {
      id: int().autoincrement().notNull(),
      name: varchar({ length: 100 }).notNull(),
      slug: varchar({ length: 100 }).notNull(),
      icon: varchar({ length: 50 }),
      image: text(),
      type: mysqlEnum(["lifestyle", "property", "investment", "demographic"]).default("lifestyle").notNull(),
      displayOrder: int().default(0),
      isActive: int().default(1),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    exploreTopics = mysqlTable("explore_topics", {
      id: int().autoincrement().notNull(),
      name: varchar({ length: 100 }).notNull(),
      slug: varchar({ length: 100 }).notNull(),
      description: text(),
      coverImage: text(),
      type: mysqlEnum(["curated", "algorithmic", "seasonal", "sponsored"]).default("curated").notNull(),
      isActive: int().default(1),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    exploreNeighbourhoodStories = mysqlTable(
      "explore_neighbourhood_stories",
      {
        id: int().autoincrement().notNull(),
        suburbId: int("suburb_id").references(() => suburbs.id, { onDelete: "cascade" }),
        title: varchar({ length: 255 }).notNull(),
        coverImage: text("cover_image"),
        videoUrl: text("video_url"),
        storyData: json("story_data"),
        category: varchar({ length: 100 }),
        isPublished: int("is_published").default(1),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_ens_suburb_id").on(table.suburbId)
      ]
    );
    exploreSponsorships = mysqlTable(
      "explore_sponsorships",
      {
        id: int().autoincrement().notNull(),
        targetType: mysqlEnum("target_type", ["listing", "development", "agent", "video", "neighbourhood"]).notNull(),
        targetId: int("target_id").notNull(),
        tier: mysqlEnum(["basic", "premium", "exclusive"]).default("basic").notNull(),
        startDate: timestamp("start_date", { mode: "string" }).notNull(),
        endDate: timestamp("end_date", { mode: "string" }).notNull(),
        impressionsTarget: int("impressions_target"),
        impressionsDelivered: int("impressions_delivered").default(0),
        clicksDelivered: int("clicks_delivered").default(0),
        status: mysqlEnum(["active", "scheduled", "completed", "paused"]).default("scheduled").notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_es_target").on(table.targetType, table.targetId),
        index("idx_es_status").on(table.status)
      ]
    );
    emailTemplates = mysqlTable("email_templates", {
      id: int().autoincrement().notNull(),
      templateKey: varchar({ length: 100 }).notNull(),
      subject: varchar({ length: 255 }).notNull(),
      htmlContent: text().notNull(),
      textContent: text(),
      agencyId: int().references(() => agencies.id, { onDelete: "cascade" }),
      isActive: int().default(1).notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    exploreComments = mysqlTable("exploreComments", {
      id: varchar({ length: 191 }).notNull(),
      videoId: varchar({ length: 191 }).notNull(),
      userId: int().notNull(),
      comment: text().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    exploreFollows = mysqlTable(
      "exploreFollows",
      {
        id: varchar({ length: 191 }).notNull(),
        followerId: int().notNull(),
        followingId: int().notNull(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
      },
      (table) => [
        index("unique_follow").on(table.followerId, table.followingId)
      ]
    );
    exploreLikes = mysqlTable(
      "exploreLikes",
      {
        id: varchar({ length: 191 }).notNull(),
        videoId: varchar({ length: 191 }).notNull(),
        userId: int().notNull(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
      },
      (table) => [
        index("unique_like").on(table.videoId, table.userId)
      ]
    );
    exploreVideoViews = mysqlTable("exploreVideoViews", {
      id: varchar({ length: 191 }).notNull(),
      videoId: varchar({ length: 191 }).notNull(),
      userId: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    exploreVideos = mysqlTable("exploreVideos", {
      id: int().autoincrement().notNull(),
      agentId: int().references(() => agents.id, { onDelete: "cascade" }),
      propertyId: int().references(() => properties.id, { onDelete: "set null" }),
      developmentId: int().references(() => developments.id, { onDelete: "set null" }),
      title: varchar({ length: 255 }).notNull(),
      description: text(),
      videoUrl: text().notNull(),
      thumbnailUrl: text(),
      duration: int(),
      views: int().notNull(),
      likes: int().notNull(),
      shares: int().notNull(),
      isPublished: int().default(1).notNull(),
      isFeatured: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    exploreHighlightTags = mysqlTable(
      "explore_highlight_tags",
      {
        id: int().autoincrement().notNull(),
        tagKey: varchar("tag_key", { length: 50 }).notNull(),
        label: varchar({ length: 100 }).notNull(),
        icon: varchar({ length: 50 }),
        color: varchar({ length: 7 }),
        category: varchar({ length: 50 }),
        displayOrder: int("display_order").default(0).notNull(),
        isActive: tinyint("is_active").default(1).notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_explore_highlight_tags_category").on(table.category),
        index("idx_explore_highlight_tags_display_order").on(table.displayOrder),
        index("tag_key").on(table.tagKey)
      ]
    );
    exploreInteractions = mysqlTable(
      "explore_interactions",
      {
        id: int().autoincrement().notNull(),
        shortId: int("short_id").notNull(),
        userId: int("user_id"),
        sessionId: varchar("session_id", { length: 255 }).notNull(),
        interactionType: mysqlEnum("interaction_type", ["impression", "view", "skip", "save", "share", "contact", "whatsapp", "book_viewing"]).notNull(),
        duration: int(),
        timestamp: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        feedType: mysqlEnum("feed_type", ["recommended", "area", "category", "agent", "developer"]).notNull(),
        feedContext: json("feed_context"),
        deviceType: mysqlEnum("device_type", ["mobile", "tablet", "desktop"]).notNull(),
        userAgent: text("user_agent"),
        ipAddress: varchar("ip_address", { length: 45 }),
        metadata: json()
      },
      (table) => [
        index("idx_explore_interactions_short_id").on(table.shortId),
        index("idx_explore_interactions_user_id").on(table.userId),
        index("idx_explore_interactions_session_id").on(table.sessionId),
        index("idx_explore_interactions_type").on(table.interactionType),
        index("idx_explore_interactions_timestamp").on(table.timestamp)
      ]
    );
    exploreShorts = mysqlTable(
      "explore_shorts",
      {
        id: int().autoincrement().notNull(),
        listingId: int("listing_id"),
        developmentId: int("development_id"),
        agentId: int("agent_id"),
        developerId: int("developer_id"),
        agencyId: int("agency_id"),
        partnerId: varchar("partner_id", { length: 36 }),
        contentType: mysqlEnum("content_type", ["property_tour", "development_promo", "agent_intro", "neighbourhood_tour", "market_insight", "lifestyle", "education"]).default("property_tour").notNull(),
        topicId: int("topic_id").references(() => exploreTopics.id, { onDelete: "set null" }),
        categoryId: int("category_id").references(() => exploreCategories.id, { onDelete: "set null" }),
        contentCategory: mysqlEnum("content_category", ["primary", "secondary", "tertiary"]).default("primary"),
        badgeType: varchar("badge_type", { length: 50 }),
        isLaunchContent: boolean("is_launch_content").default(false),
        title: varchar({ length: 255 }).notNull(),
        caption: text(),
        primaryMediaId: int("primary_media_id").notNull(),
        mediaIds: json("media_ids").notNull(),
        highlights: json(),
        performanceScore: decimal("performance_score", { precision: 5, scale: 2 }).default("0").notNull(),
        boostPriority: int("boost_priority").default(0).notNull(),
        viewCount: int("view_count").default(0).notNull(),
        uniqueViewCount: int("unique_view_count").default(0).notNull(),
        saveCount: int("save_count").default(0).notNull(),
        shareCount: int("share_count").default(0).notNull(),
        skipCount: int("skip_count").default(0).notNull(),
        averageWatchTime: int("average_watch_time").default(0).notNull(),
        viewThroughRate: decimal("view_through_rate", { precision: 5, scale: 2 }).default("0").notNull(),
        saveRate: decimal("save_rate", { precision: 5, scale: 2 }).default("0").notNull(),
        shareRate: decimal("share_rate", { precision: 5, scale: 2 }).default("0").notNull(),
        skipRate: decimal("skip_rate", { precision: 5, scale: 2 }).default("0").notNull(),
        isPublished: tinyint("is_published").default(1).notNull(),
        isFeatured: tinyint("is_featured").default(0).notNull(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull(),
        publishedAt: timestamp("published_at", { mode: "string" })
      },
      (table) => [
        index("idx_explore_shorts_listing_id").on(table.listingId),
        index("idx_explore_shorts_development_id").on(table.developmentId),
        index("idx_explore_shorts_agent_id").on(table.agentId),
        index("idx_explore_shorts_agency_id").on(table.agencyId),
        index("idx_shorts_partner").on(table.partnerId),
        index("idx_shorts_category").on(table.contentCategory),
        index("idx_explore_shorts_performance_score").on(table.performanceScore),
        index("idx_explore_shorts_boost_priority").on(table.boostPriority),
        index("idx_explore_shorts_published").on(table.isPublished, table.publishedAt),
        index("idx_explore_shorts_agency_published").on(table.agencyId, table.isPublished, table.publishedAt),
        index("idx_explore_shorts_agency_performance").on(table.agencyId, table.performanceScore, table.viewCount)
      ]
    );
    exploreUserPreferences = mysqlTable(
      "explore_user_preferences",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull(),
        preferredLocations: json("preferred_locations"),
        budgetMin: int("budget_min"),
        budgetMax: int("budget_max"),
        propertyTypes: json("property_types"),
        interactionHistory: json("interaction_history"),
        savedProperties: json("saved_properties"),
        inferredPreferences: json("inferred_preferences"),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("user_id").on(table.userId)
      ]
    );
    favorites = mysqlTable("favorites", {
      id: int().autoincrement().notNull(),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    invitations = mysqlTable("invitations", {
      id: int().autoincrement().notNull(),
      agencyId: int().notNull().references(() => agencies.id, { onDelete: "cascade" }),
      invitedBy: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      email: varchar({ length: 320 }).notNull(),
      role: varchar({ length: 50 }).default("agent").notNull(),
      token: varchar({ length: 255 }).notNull(),
      status: mysqlEnum(["pending", "accepted", "expired", "cancelled"]).default("pending").notNull(),
      expiresAt: timestamp({ mode: "string" }).notNull(),
      acceptedAt: timestamp({ mode: "string" }),
      acceptedBy: int().references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    invites = mysqlTable("invites", {
      id: int().autoincrement().notNull(),
      agencyId: int().notNull().references(() => agencies.id, { onDelete: "cascade" }),
      email: varchar({ length: 255 }).notNull(),
      token: varchar({ length: 255 }).notNull(),
      role: varchar({ length: 30 }).default("agent"),
      expiresAt: timestamp({ mode: "string" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      used: int().notNull(),
      usedAt: timestamp({ mode: "string" }),
      usedBy: int().references(() => users.id, { onDelete: "set null" })
    });
    invoices = mysqlTable("invoices", {
      id: int().autoincrement().notNull(),
      agencyId: int().notNull().references(() => agencies.id, { onDelete: "cascade" }),
      subscriptionId: int().references(() => agencySubscriptions.id, { onDelete: "set null" }),
      stripeInvoiceId: varchar({ length: 100 }),
      stripeCustomerId: varchar({ length: 100 }),
      amount: int().notNull(),
      currency: varchar({ length: 3 }).default("ZAR").notNull(),
      status: mysqlEnum(["draft", "open", "paid", "void", "uncollectible"]).default("draft").notNull(),
      invoicePdf: text(),
      hostedInvoiceUrl: text(),
      invoiceNumber: varchar({ length: 50 }),
      description: text(),
      billingReason: mysqlEnum(["subscription_cycle", "subscription_create", "subscription_update", "subscription_finalize", "manual"]).default("subscription_cycle").notNull(),
      periodStart: timestamp({ mode: "string" }),
      periodEnd: timestamp({ mode: "string" }),
      paidAt: timestamp({ mode: "string" }),
      dueDate: timestamp({ mode: "string" }),
      metadata: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    partners = mysqlTable("partners", {
      id: int().autoincrement().notNull(),
      name: varchar({ length: 255 }).notNull(),
      category: mysqlEnum(["mortgage_broker", "lawyer", "photographer", "inspector", "mover", "other"]).default("other").notNull(),
      description: text(),
      contactPerson: varchar("contact_person", { length: 255 }),
      email: varchar({ length: 320 }),
      phone: varchar({ length: 50 }),
      website: varchar({ length: 255 }),
      logo: text(),
      status: mysqlEnum(["active", "inactive", "pending"]).default("active").notNull(),
      rating: int(),
      isVerified: int("is_verified").default(0).notNull(),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
    }, (table) => [
      index("idx_partners_status").on(table.status),
      index("idx_partners_category").on(table.category)
    ]);
    leadActivities = mysqlTable("lead_activities", {
      id: int().autoincrement().notNull(),
      leadId: int().notNull().references(() => leads.id, { onDelete: "cascade" }),
      agentId: int().references(() => agents.id, { onDelete: "set null" }),
      activityType: mysqlEnum(["call", "email", "meeting", "note", "status_change", "viewing_scheduled", "offer_sent"]).notNull(),
      description: text(),
      metadata: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    leads = mysqlTable(
      "leads",
      {
        id: int().autoincrement().notNull(),
        propertyId: int().references(() => properties.id, { onDelete: "set null" }),
        developmentId: int().references(() => developments.id, { onDelete: "set null" }),
        developerBrandProfileId: int("developer_brand_profile_id").references(() => developerBrandProfiles.id, { onDelete: "set null" }),
        agencyId: int().references(() => agencies.id, { onDelete: "set null" }),
        agentId: int().references(() => agents.id, { onDelete: "set null" }),
        name: varchar({ length: 200 }).notNull(),
        email: varchar({ length: 320 }).notNull(),
        phone: varchar({ length: 50 }),
        message: text(),
        leadType: mysqlEnum(["inquiry", "viewing_request", "offer", "callback"]).default("inquiry").notNull(),
        status: mysqlEnum(["new", "contacted", "qualified", "converted", "closed", "viewing_scheduled", "offer_sent", "lost"]).default("new").notNull(),
        source: varchar({ length: 100 }),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
        nextFollowUp: timestamp({ mode: "string" }),
        lastContactedAt: timestamp({ mode: "string" }),
        notes: text(),
        affordabilityData: json("affordability_data"),
        qualificationStatus: mysqlEnum("qualification_status", ["qualified", "partially_qualified", "unqualified", "pending"]).default("pending"),
        qualificationScore: int("qualification_score").default(0),
        leadSource: varchar("lead_source", { length: 100 }),
        referrerUrl: text("referrer_url"),
        utmSource: varchar("utm_source", { length: 100 }),
        utmMedium: varchar("utm_medium", { length: 100 }),
        utmCampaign: varchar("utm_campaign", { length: 100 }),
        funnelStage: mysqlEnum("funnel_stage", ["interest", "affordability", "qualification", "viewing", "offer", "bond", "sale"]).default("interest"),
        assignedTo: int("assigned_to"),
        assignedAt: timestamp("assigned_at", { mode: "string" }),
        convertedAt: timestamp("converted_at", { mode: "string" }),
        lostReason: text("lost_reason"),
        // Brand Lead Tracking
        brandLeadStatus: mysqlEnum("brand_lead_status", ["captured", "delivered_unsubscribed", "delivered_subscriber", "claimed"]).default("captured"),
        leadDeliveryMethod: mysqlEnum("lead_delivery_method", ["email", "crm_export", "manual", "none"]).default("email")
      },
      (table) => [
        index("idx_leads_qualification_status").on(table.qualificationStatus),
        index("idx_leads_funnel_stage").on(table.funnelStage),
        index("idx_leads_assigned_to").on(table.assignedTo),
        index("idx_leads_lead_source").on(table.leadSource)
      ]
    );
    listingAnalytics = mysqlTable("listing_analytics", {
      id: int().autoincrement().notNull(),
      listingId: int().notNull().references(() => listings.id, { onDelete: "cascade" }),
      totalViews: int().default(0).notNull(),
      uniqueVisitors: int().default(0).notNull(),
      viewsByDay: json(),
      totalLeads: int().default(0).notNull(),
      contactFormLeads: int().default(0).notNull(),
      whatsappClicks: int().default(0).notNull(),
      phoneReveals: int().default(0).notNull(),
      bookingViewingRequests: int().default(0).notNull(),
      totalFavorites: int().default(0).notNull(),
      totalShares: int().default(0).notNull(),
      averageTimeOnPage: int(),
      trafficSources: json(),
      conversionRate: decimal({ precision: 5, scale: 2 }),
      leadConversionRate: decimal({ precision: 5, scale: 2 }),
      lastUpdated: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    listingApprovalQueue = mysqlTable("listing_approval_queue", {
      id: int().autoincrement().notNull(),
      listingId: int().notNull().references(() => listings.id, { onDelete: "cascade" }),
      submittedBy: int().notNull(),
      submittedAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      status: mysqlEnum(["pending", "reviewing", "approved", "rejected"]).default("pending").notNull(),
      priority: mysqlEnum(["low", "normal", "high", "urgent"]).default("normal").notNull(),
      reviewedBy: int(),
      reviewedAt: timestamp({ mode: "string" }),
      reviewNotes: text(),
      rejectionReason: text(),
      complianceChecks: json(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    listingLeads = mysqlTable("listing_leads", {
      id: int().autoincrement().notNull(),
      listingId: int().notNull().references(() => listings.id, { onDelete: "cascade" }),
      name: varchar({ length: 200 }).notNull(),
      email: varchar({ length: 320 }),
      phone: varchar({ length: 50 }),
      message: text(),
      leadType: mysqlEnum(["contact_form", "whatsapp_click", "phone_reveal", "book_viewing", "make_offer", "request_info"]).notNull(),
      source: varchar({ length: 100 }),
      referrer: text(),
      utmSource: varchar({ length: 100 }),
      utmMedium: varchar({ length: 100 }),
      utmCampaign: varchar({ length: 100 }),
      assignedTo: int(),
      assignedAt: timestamp({ mode: "string" }),
      status: mysqlEnum(["new", "contacted", "qualified", "viewing_scheduled", "offer_made", "converted", "lost"]).default("new").notNull(),
      crmSynced: int().default(0),
      crmSyncedAt: timestamp({ mode: "string" }),
      crmId: varchar({ length: 255 }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    listingMedia = mysqlTable("listing_media", {
      id: int().autoincrement().notNull(),
      listingId: int().notNull().references(() => listings.id, { onDelete: "cascade" }),
      mediaType: mysqlEnum(["image", "video", "floorplan", "pdf"]).notNull(),
      originalUrl: text().notNull(),
      originalFileName: varchar({ length: 255 }),
      originalFileSize: int(),
      processedUrl: text(),
      thumbnailUrl: text(),
      previewUrl: text(),
      width: int(),
      height: int(),
      duration: int(),
      mimeType: varchar({ length: 100 }),
      orientation: mysqlEnum(["vertical", "horizontal", "square"]),
      isVertical: int().default(0),
      displayOrder: int().default(0).notNull(),
      isPrimary: int().default(0).notNull(),
      processingStatus: mysqlEnum(["pending", "processing", "completed", "failed"]).default("pending"),
      processingError: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      uploadedAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      processedAt: timestamp({ mode: "string" })
    });
    listingSettings = mysqlTable("listing_settings", {
      id: int().autoincrement().notNull(),
      autoPublishForVerifiedAccounts: int().default(0).notNull(),
      maxImagesPerListing: int().default(30).notNull(),
      maxVideosPerListing: int().default(5).notNull(),
      maxFloorplansPerListing: int().default(5).notNull(),
      maxPdfsPerListing: int().default(3).notNull(),
      maxImageSizeMb: int().default(5).notNull(),
      maxVideoSizeMb: int().default(50).notNull(),
      maxVideoDurationSeconds: int().default(180).notNull(),
      videoCompressionEnabled: int().default(1).notNull(),
      videoThumbnailEnabled: int().default(1).notNull(),
      videoPreviewClipSeconds: int().default(3).notNull(),
      crmWebhookUrl: text(),
      crmEnabled: int().default(0).notNull(),
      newListingNotificationsEnabled: int().default(1).notNull(),
      leadNotificationsEnabled: int().default(1).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
      updatedBy: int()
    });
    listingViewings = mysqlTable("listing_viewings", {
      id: int().autoincrement().notNull(),
      listingId: int().notNull().references(() => listings.id, { onDelete: "cascade" }),
      leadId: int(),
      scheduledDate: timestamp({ mode: "string" }).notNull(),
      duration: int().default(30),
      visitorName: varchar({ length: 200 }).notNull(),
      visitorEmail: varchar({ length: 320 }),
      visitorPhone: varchar({ length: 50 }),
      status: mysqlEnum(["requested", "confirmed", "completed", "cancelled", "no_show"]).default("requested").notNull(),
      agentId: int(),
      agentNotes: text(),
      visitorFeedback: text(),
      visitorRating: int(),
      reminderSent: int().default(0),
      confirmationSent: int().default(0),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    listings = mysqlTable("listings", {
      id: int().autoincrement().notNull(),
      ownerId: int().notNull(),
      agentId: int(),
      agencyId: int(),
      action: mysqlEnum(["sell", "rent", "auction"]).notNull(),
      propertyType: mysqlEnum(["apartment", "house", "farm", "land", "commercial", "shared_living"]).notNull(),
      title: varchar({ length: 255 }).notNull(),
      description: text().notNull(),
      askingPrice: decimal({ precision: 12, scale: 2 }),
      negotiable: int().default(0),
      transferCostEstimate: decimal({ precision: 12, scale: 2 }),
      monthlyRent: decimal({ precision: 12, scale: 2 }),
      deposit: decimal({ precision: 12, scale: 2 }),
      leaseTerms: varchar({ length: 100 }),
      availableFrom: timestamp({ mode: "string" }),
      utilitiesIncluded: int().default(0),
      startingBid: decimal({ precision: 12, scale: 2 }),
      reservePrice: decimal({ precision: 12, scale: 2 }),
      auctionDateTime: timestamp({ mode: "string" }),
      auctionTermsDocumentUrl: text(),
      propertyDetails: json(),
      address: text().notNull(),
      latitude: decimal({ precision: 10, scale: 7 }).notNull(),
      longitude: decimal({ precision: 10, scale: 7 }).notNull(),
      city: varchar({ length: 100 }).notNull(),
      suburb: varchar({ length: 100 }),
      province: varchar({ length: 100 }).notNull(),
      postalCode: varchar({ length: 20 }),
      placeId: varchar({ length: 255 }),
      mainMediaId: int(),
      mainMediaType: mysqlEnum(["image", "video"]),
      status: mysqlEnum(["draft", "pending_review", "approved", "published", "rejected", "archived", "sold", "rented"]).default("draft").notNull(),
      approvalStatus: mysqlEnum(["pending", "approved", "rejected"]).default("pending"),
      reviewedBy: int(),
      reviewedAt: timestamp({ mode: "string" }),
      rejectionReason: text(),
      autoPublished: int().default(0),
      slug: varchar({ length: 255 }).notNull(),
      readinessScore: int("readiness_score").default(0).notNull(),
      qualityScore: int("quality_score").default(0).notNull(),
      qualityBreakdown: json("quality_breakdown"),
      rejectionReasons: json("rejection_reasons"),
      rejectionNote: text("rejection_note"),
      metaTitle: varchar({ length: 255 }),
      metaDescription: text(),
      canonicalUrl: text(),
      searchTags: text(),
      featured: int().default(0).notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
      publishedAt: timestamp({ mode: "string" }),
      archivedAt: timestamp({ mode: "string" })
    });
    locationSearchCache = mysqlTable("location_search_cache", {
      id: int().autoincrement().notNull(),
      searchQuery: varchar({ length: 255 }).notNull(),
      searchType: mysqlEnum(["province", "city", "suburb", "address", "all"]).notNull(),
      resultsJson: text().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      expiresAt: timestamp({ mode: "string" }).notNull()
    });
    locations = mysqlTable(
      "locations",
      {
        id: int().autoincrement().notNull(),
        name: varchar({ length: 200 }).notNull(),
        slug: varchar({ length: 200 }).notNull(),
        type: mysqlEnum(["province", "city", "suburb", "neighborhood"]).notNull(),
        parentId: int(),
        placeId: varchar("place_id", { length: 255 }),
        description: text(),
        latitude: varchar({ length: 50 }),
        longitude: varchar({ length: 50 }),
        viewportNeLat: decimal("viewport_ne_lat", { precision: 10, scale: 8 }),
        viewportNeLng: decimal("viewport_ne_lng", { precision: 11, scale: 8 }),
        viewportSwLat: decimal("viewport_sw_lat", { precision: 10, scale: 8 }),
        viewportSwLng: decimal("viewport_sw_lng", { precision: 11, scale: 8 }),
        seoTitle: varchar("seo_title", { length: 255 }),
        seoDescription: text("seo_description"),
        heroImage: varchar("hero_image", { length: 500 }),
        propertyCount: int(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_locations_place_id").on(table.placeId),
        index("idx_locations_slug").on(table.slug),
        index("idx_locations_parent_id").on(table.parentId)
      ]
    );
    locationAnalyticsEvents = mysqlTable("location_analytics_events", {
      id: int().autoincrement().notNull(),
      eventType: varchar("event_type", { length: 50 }).notNull(),
      locationId: int("location_id"),
      developmentId: int("development_id"),
      listingId: int("listing_id"),
      targetId: int("target_id"),
      metadata: json(),
      sessionId: varchar("session_id", { length: 100 }),
      userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    }, (table) => [
      index("idx_loc_analytics_event").on(table.eventType),
      index("idx_loc_analytics_created").on(table.createdAt),
      index("idx_loc_analytics_location").on(table.locationId),
      index("idx_loc_analytics_development").on(table.developmentId)
    ]);
    locationTargeting = mysqlTable(
      "location_targeting",
      {
        id: int().autoincrement().notNull(),
        targetType: mysqlEnum("target_type", ["hero_ad", "featured_developer", "recommended_agent"]).notNull(),
        targetId: int("target_id").notNull(),
        locationType: mysqlEnum("location_type", ["province", "city", "suburb"]).notNull(),
        locationId: int("location_id").notNull(),
        ranking: int().default(0),
        startDate: timestamp("start_date", { mode: "string" }),
        endDate: timestamp("end_date", { mode: "string" }),
        status: mysqlEnum(["active", "scheduled", "expired", "paused"]).default("scheduled").notNull(),
        metadata: json(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_location_targeting").on(table.locationType, table.locationId, table.status)
      ]
    );
    locationSearches = mysqlTable(
      "location_searches",
      {
        id: int().autoincrement().notNull(),
        locationId: int("location_id").notNull().references(() => locations.id, { onDelete: "cascade" }),
        userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
        searchedAt: timestamp("searched_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_location_searched").on(table.locationId, table.searchedAt),
        index("idx_user_id").on(table.userId)
      ]
    );
    recentSearches = mysqlTable(
      "recent_searches",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        locationId: int("location_id").notNull().references(() => locations.id, { onDelete: "cascade" }),
        searchedAt: timestamp("searched_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_user_recent").on(table.userId, table.searchedAt),
        index("unique_user_location").on(table.userId, table.locationId)
      ]
    );
    marketInsightsCache = mysqlTable("market_insights_cache", {
      id: int().autoincrement().notNull(),
      cacheKey: varchar({ length: 255 }).notNull(),
      cacheData: text().notNull(),
      cacheType: mysqlEnum(["suburb_heatmap", "city_trends", "popular_areas", "price_predictions", "user_recommendations"]).notNull(),
      expiresAt: timestamp({ mode: "string" }).notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    notifications = mysqlTable("notifications", {
      id: int().autoincrement().notNull(),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      type: mysqlEnum(["lead_assigned", "offer_received", "showing_scheduled", "system_alert"]).notNull(),
      title: varchar({ length: 255 }).notNull(),
      content: text().notNull(),
      data: text(),
      isRead: int().notNull(),
      readAt: timestamp({ mode: "string" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    offers = mysqlTable("offers", {
      id: int().autoincrement().notNull(),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      leadId: int().references(() => leads.id, { onDelete: "set null" }),
      agentId: int().references(() => agents.id, { onDelete: "set null" }),
      buyerName: varchar({ length: 200 }).notNull(),
      buyerEmail: varchar({ length: 320 }),
      buyerPhone: varchar({ length: 50 }),
      offerAmount: int().notNull(),
      status: mysqlEnum(["pending", "accepted", "rejected", "countered", "withdrawn"]).default("pending").notNull(),
      conditions: text(),
      expiresAt: timestamp({ mode: "string" }),
      respondedAt: timestamp({ mode: "string" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    paymentMethods = mysqlTable("payment_methods", {
      id: int().autoincrement().notNull(),
      agencyId: int().notNull().references(() => agencies.id, { onDelete: "cascade" }),
      stripePaymentMethodId: varchar({ length: 100 }),
      type: mysqlEnum(["card", "bank_account"]).default("card").notNull(),
      cardBrand: varchar({ length: 20 }),
      cardLast4: varchar({ length: 4 }),
      cardExpMonth: int(),
      cardExpYear: int(),
      bankName: varchar({ length: 100 }),
      bankLast4: varchar({ length: 4 }),
      isDefault: int().notNull(),
      isActive: int().default(1).notNull(),
      metadata: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    plans = mysqlTable("plans", {
      id: int().autoincrement().notNull(),
      name: varchar({ length: 100 }).notNull(),
      displayName: varchar({ length: 100 }).notNull(),
      description: text(),
      price: int().notNull(),
      currency: varchar({ length: 3 }).default("ZAR").notNull(),
      interval: mysqlEnum(["month", "year"]).default("month").notNull(),
      stripePriceId: varchar({ length: 100 }),
      features: text(),
      limits: text(),
      isActive: int().default(1).notNull(),
      isPopular: int().notNull(),
      sortOrder: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    platformSettings = mysqlTable("platform_settings", {
      id: int().autoincrement().notNull(),
      key: varchar({ length: 100 }).notNull(),
      value: text().notNull(),
      description: text(),
      category: mysqlEnum(["pricing", "features", "notifications", "limits", "other"]).default("other").notNull(),
      isPublic: int().notNull(),
      updatedBy: int().references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    platformInquiries = mysqlTable("platform_inquiries", {
      id: int().autoincrement().notNull(),
      name: varchar({ length: 255 }).notNull(),
      email: varchar({ length: 320 }).notNull(),
      phone: varchar({ length: 50 }),
      userType: mysqlEnum(["agent", "developer", "seller", "partner", "other"]).notNull(),
      intent: mysqlEnum(["advertise", "software", "partnership", "support"]).default("advertise").notNull(),
      message: text(),
      status: mysqlEnum(["new", "contacted", "converted", "closed"]).default("new").notNull(),
      metadata: json(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    priceAnalytics = mysqlTable("price_analytics", {
      id: int().autoincrement().notNull(),
      locationId: int().notNull(),
      locationType: mysqlEnum(["suburb", "city", "province"]).notNull(),
      currentAvgPrice: int(),
      currentMedianPrice: int(),
      currentMinPrice: int(),
      currentMaxPrice: int(),
      currentPriceCount: int(),
      oneMonthGrowthPercent: int(),
      threeMonthGrowthPercent: int(),
      sixMonthGrowthPercent: int(),
      oneYearGrowthPercent: int(),
      luxurySegmentPercent: int(),
      midRangePercent: int(),
      affordablePercent: int(),
      avgDaysOnMarket: int(),
      newListingsMonthly: int(),
      soldPropertiesMonthly: int(),
      trendingDirection: mysqlEnum(["up", "down", "stable"]).default("stable").notNull(),
      trendConfidence: int(),
      totalProperties: int(),
      activeListings: int(),
      userInteractions: int(),
      priceVolatility: int(),
      marketMomentum: int(),
      investmentScore: int(),
      lastUpdated: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    priceHistory = mysqlTable("price_history", {
      id: int().autoincrement().notNull(),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      suburbId: int(),
      cityId: int(),
      provinceId: int(),
      price: int().notNull(),
      pricePerSqm: int(),
      propertyType: mysqlEnum(["apartment", "house", "villa", "plot", "commercial", "townhouse", "cluster_home", "farm", "shared_living"]).notNull(),
      listingType: mysqlEnum(["sale", "rent", "rent_to_buy", "auction", "shared_living"]).notNull(),
      recordedAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      source: mysqlEnum(["new_listing", "price_change", "sold", "rented", "market_update"]).default("market_update").notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    pricePredictions = mysqlTable("price_predictions", {
      id: int().autoincrement().notNull(),
      propertyId: int().references(() => properties.id, { onDelete: "cascade" }),
      suburbId: int().references(() => suburbs.id, { onDelete: "cascade" }),
      cityId: int().references(() => cities.id, { onDelete: "cascade" }),
      provinceId: int().references(() => provinces.id, { onDelete: "cascade" }),
      predictedPrice: int().notNull(),
      predictedPriceRangeMin: int(),
      predictedPriceRangeMax: int(),
      confidenceScore: int(),
      modelVersion: varchar({ length: 50 }),
      modelFeatures: text(),
      trainingDataSize: int(),
      actualPrice: int(),
      predictionError: int(),
      predictionAccuracy: int(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      validatedAt: timestamp({ mode: "string" })
    });
    properties = mysqlTable(
      "properties",
      {
        id: int().autoincrement().notNull(),
        title: varchar({ length: 255 }).notNull(),
        description: text().notNull(),
        propertyType: mysqlEnum(["apartment", "house", "villa", "plot", "commercial", "townhouse", "cluster_home", "farm", "shared_living"]).notNull(),
        listingType: mysqlEnum(["sale", "rent", "rent_to_buy", "auction", "shared_living"]).notNull(),
        transactionType: mysqlEnum(["sale", "rent", "rent_to_buy", "auction"]).default("sale").notNull(),
        price: int().notNull(),
        bedrooms: int(),
        bathrooms: int(),
        area: int().notNull(),
        address: text().notNull(),
        city: varchar({ length: 100 }).notNull(),
        province: varchar({ length: 100 }).notNull(),
        zipCode: varchar({ length: 20 }),
        latitude: varchar({ length: 50 }),
        longitude: varchar({ length: 50 }),
        provinceId: int().references(() => provinces.id, { onDelete: "set null" }),
        cityId: int().references(() => cities.id, { onDelete: "set null" }),
        suburbId: int().references(() => suburbs.id, { onDelete: "set null" }),
        locationId: int("location_id").references(() => locations.id, { onDelete: "set null" }),
        locationText: text(),
        placeId: varchar({ length: 255 }),
        amenities: text(),
        yearBuilt: int(),
        status: mysqlEnum(["available", "sold", "rented", "pending", "draft", "published", "archived"]).default("available").notNull(),
        featured: int().notNull(),
        views: int().notNull(),
        enquiries: int().notNull(),
        agentId: int().references(() => agents.id, { onDelete: "set null" }),
        developmentId: int().references(() => developments.id, { onDelete: "set null" }),
        developerBrandProfileId: int("developer_brand_profile_id").references(() => developerBrandProfiles.id, { onDelete: "set null" }),
        ownerId: int().notNull().references(() => users.id),
        propertySettings: text(),
        videoUrl: text(),
        virtualTourUrl: text(),
        levies: int(),
        ratesAndTaxes: int(),
        mainImage: varchar({ length: 1024 }),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("price_idx").on(table.price),
        index("status_idx").on(table.status),
        index("city_idx").on(table.city),
        index("province_idx").on(table.province),
        index("property_type_idx").on(table.propertyType),
        index("listing_type_idx").on(table.listingType),
        index("bedrooms_idx").on(table.bedrooms),
        index("bathrooms_idx").on(table.bathrooms),
        index("idx_properties_cityId").on(table.cityId),
        index("idx_properties_suburbId").on(table.suburbId),
        index("idx_properties_location_id").on(table.locationId),
        index("idx_properties_cityId_status").on(table.cityId, table.status),
        index("idx_properties_cityId_area").on(table.cityId, table.area)
      ]
    );
    propertyImages = mysqlTable("propertyImages", {
      id: int().autoincrement().notNull(),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      imageUrl: text().notNull(),
      isPrimary: int().notNull(),
      displayOrder: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    propertySimilarityIndex = mysqlTable("property_similarity_index", {
      id: int().autoincrement().notNull(),
      propertyId1: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      propertyId2: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      locationSimilarity: int(),
      priceSimilarity: int(),
      typeSimilarity: int(),
      featureSimilarity: int(),
      overallSimilarity: int(),
      similarityReason: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    prospectFavorites = mysqlTable("prospect_favorites", {
      id: int().autoincrement().notNull(),
      prospectId: int().notNull().references(() => prospects.id, { onDelete: "cascade" }),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    prospects = mysqlTable("prospects", {
      id: int().autoincrement().notNull(),
      sessionId: varchar({ length: 255 }).notNull(),
      email: varchar({ length: 320 }),
      phone: varchar({ length: 50 }),
      income: int(),
      incomeRange: mysqlEnum(["under_15k", "15k_25k", "25k_50k", "50k_100k", "over_100k"]),
      employmentStatus: mysqlEnum(["employed", "self_employed", "business_owner", "student", "retired", "unemployed"]),
      combinedIncome: int(),
      monthlyExpenses: int(),
      monthlyDebts: int(),
      dependents: int(),
      savingsDeposit: int(),
      creditScore: int(),
      hasCreditConsent: int(),
      buyabilityScore: mysqlEnum(["low", "medium", "high"]),
      affordabilityMin: int(),
      affordabilityMax: int(),
      monthlyPaymentCapacity: int(),
      profileProgress: int(),
      badges: text(),
      lastActivity: timestamp({ mode: "string" }),
      preferredPropertyType: mysqlEnum(["apartment", "house", "villa", "plot", "commercial", "townhouse", "cluster_home", "farm", "shared_living"]),
      preferredLocation: varchar({ length: 100 }),
      maxCommuteTime: int(),
      ipAddress: varchar({ length: 45 }),
      userAgent: text(),
      referrer: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    provinces = mysqlTable(
      "provinces",
      {
        id: int().autoincrement().notNull(),
        name: varchar({ length: 100 }).notNull(),
        slug: varchar({ length: 200 }),
        placeId: varchar("place_id", { length: 255 }),
        seoTitle: varchar("seo_title", { length: 255 }),
        seoDescription: text("seo_description"),
        code: varchar({ length: 10 }).notNull(),
        latitude: varchar({ length: 20 }),
        longitude: varchar({ length: 21 }),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_provinces_slug").on(table.slug),
        index("idx_provinces_place_id").on(table.placeId)
      ]
    );
    recentlyViewed = mysqlTable("recently_viewed", {
      id: int().autoincrement().notNull(),
      prospectId: int().notNull().references(() => prospects.id, { onDelete: "cascade" }),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      viewedAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    reviews = mysqlTable("reviews", {
      id: int().autoincrement().notNull(),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      reviewType: mysqlEnum(["agent", "developer", "property"]).notNull(),
      targetId: int().notNull(),
      rating: int().notNull(),
      title: varchar({ length: 255 }),
      comment: text(),
      isVerified: int().notNull(),
      isPublished: int().default(1).notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    savedSearches = mysqlTable("saved_searches", {
      id: int().autoincrement().notNull(),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar({ length: 255 }).notNull(),
      criteria: json().notNull(),
      filters: json(),
      notificationMethod: varchar({ length: 20 }).default("email"),
      notificationFrequency: mysqlEnum(["never", "daily", "weekly", "instant"]).default("never"),
      lastNotifiedAt: timestamp({ mode: "string" }),
      lastNotified: timestamp({ mode: "string" }),
      isActive: tinyint().default(1),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow()
    });
    searchAnalytics = mysqlTable(
      "search_analytics",
      {
        id: int().autoincrement().notNull(),
        userId: int().references(() => users.id, { onDelete: "set null" }),
        sessionId: varchar({ length: 255 }),
        filters: json().notNull(),
        resultCount: int(),
        sortOrder: varchar({ length: 50 }),
        viewMode: varchar({ length: 20 }),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
      },
      (table) => [
        index("idx_search_analytics_created").on(table.createdAt),
        index("idx_search_analytics_user").on(table.userId),
        index("idx_search_analytics_session").on(table.sessionId)
      ]
    );
    propertyClicks = mysqlTable(
      "property_clicks",
      {
        id: int().autoincrement().notNull(),
        propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
        userId: int().references(() => users.id, { onDelete: "set null" }),
        sessionId: varchar({ length: 255 }),
        position: int(),
        searchFilters: json(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
      },
      (table) => [
        index("idx_property_clicks_property").on(table.propertyId),
        index("idx_property_clicks_created").on(table.createdAt),
        index("idx_property_clicks_session").on(table.sessionId)
      ]
    );
    scheduledViewings = mysqlTable("scheduled_viewings", {
      id: int().autoincrement().notNull(),
      prospectId: int().notNull().references(() => prospects.id, { onDelete: "cascade" }),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      agentId: int().references(() => agents.id, { onDelete: "set null" }),
      scheduledAt: timestamp({ mode: "string" }).notNull(),
      status: mysqlEnum(["scheduled", "confirmed", "completed", "cancelled", "no_show"]).default("scheduled").notNull(),
      notes: text(),
      prospectName: varchar({ length: 200 }),
      prospectEmail: varchar({ length: 320 }),
      prospectPhone: varchar({ length: 50 }),
      notificationSent: int(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    services = mysqlTable("services", {
      id: int().autoincrement().notNull(),
      name: varchar({ length: 255 }).notNull(),
      category: mysqlEnum(["home_loan", "insurance", "interior_design", "legal", "moving", "other"]).notNull(),
      description: text(),
      logo: text(),
      website: varchar({ length: 255 }),
      email: varchar({ length: 320 }),
      phone: varchar({ length: 50 }),
      commissionRate: int(),
      isActive: int().default(1).notNull(),
      isFeatured: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    showings = mysqlTable("showings", {
      id: int().autoincrement().notNull(),
      propertyId: int().notNull().references(() => properties.id, { onDelete: "cascade" }),
      leadId: int().references(() => leads.id, { onDelete: "set null" }),
      agentId: int().references(() => agents.id, { onDelete: "set null" }),
      scheduledAt: timestamp({ mode: "string" }).notNull(),
      status: mysqlEnum(["requested", "confirmed", "completed", "cancelled"]).default("requested").notNull(),
      notes: text(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    subscriptionEvents = mysqlTable(
      "subscription_events",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        subscriptionId: int("subscription_id"),
        eventType: mysqlEnum("event_type", ["trial_started", "trial_expiring_soon", "trial_expired", "subscription_created", "subscription_renewed", "subscription_upgraded", "subscription_downgraded", "subscription_cancelled", "payment_succeeded", "payment_failed", "feature_locked", "limit_reached"]).notNull(),
        eventData: json("event_data"),
        metadata: json(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
      },
      (table) => [
        index("idx_user").on(table.userId),
        index("idx_event_type").on(table.eventType)
      ]
    );
    subscriptionPlans = mysqlTable(
      "subscription_plans",
      {
        id: int().autoincrement().notNull(),
        planId: varchar("plan_id", { length: 100 }).notNull(),
        category: mysqlEnum(["agent", "agency", "developer"]).notNull(),
        name: varchar({ length: 100 }).notNull(),
        displayName: varchar("display_name", { length: 150 }).notNull(),
        description: text(),
        priceZar: int("price_zar").notNull(),
        billingInterval: mysqlEnum("billing_interval", ["monthly", "yearly"]).default("monthly").notNull(),
        trialDays: int("trial_days").default(14),
        isTrialPlan: tinyint("is_trial_plan").default(0),
        isFreePlan: tinyint("is_free_plan").default(0),
        priorityLevel: int("priority_level").default(0),
        sortOrder: int("sort_order").default(0),
        isActive: tinyint("is_active").default(1),
        features: json(),
        limits: json(),
        permissions: json(),
        upgradeToPlanId: varchar("upgrade_to_plan_id", { length: 100 }),
        downgradeToPlanId: varchar("downgrade_to_plan_id", { length: 100 }),
        stripePriceId: varchar("stripe_price_id", { length: 255 }),
        paystackPlanCode: varchar("paystack_plan_code", { length: 255 }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow()
      },
      (table) => [
        index("idx_category").on(table.category),
        index("idx_active").on(table.isActive),
        index("plan_id").on(table.planId)
      ]
    );
    subscriptionUsage = mysqlTable(
      "subscription_usage",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        subscriptionId: int("subscription_id").notNull(),
        periodStart: timestamp("period_start", { mode: "string" }).notNull(),
        periodEnd: timestamp("period_end", { mode: "string" }).notNull(),
        listingsCreated: int("listings_created").default(0),
        projectsCreated: int("projects_created").default(0),
        agentsAdded: int("agents_added").default(0),
        boostsUsed: int("boosts_used").default(0),
        apiCalls: int("api_calls").default(0),
        storageMb: int("storage_mb").default(0),
        crmContacts: int("crm_contacts").default(0),
        emailsSent: int("emails_sent").default(0),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow()
      },
      (table) => [
        index("idx_user_period").on(table.userId, table.periodStart, table.periodEnd)
      ]
    );
    suburbPriceAnalytics = mysqlTable("suburb_price_analytics", {
      id: int().autoincrement().notNull(),
      suburbId: int().notNull().references(() => suburbs.id, { onDelete: "cascade" }),
      cityId: int().notNull().references(() => cities.id, { onDelete: "cascade" }),
      provinceId: int().notNull().references(() => provinces.id, { onDelete: "cascade" }),
      currentAvgPrice: int(),
      currentMedianPrice: int(),
      currentMinPrice: int(),
      currentMaxPrice: int(),
      currentPriceCount: int(),
      lastMonthAvgPrice: int(),
      lastMonthMedianPrice: int(),
      lastMonthPriceCount: int(),
      sixMonthGrowthPercent: int(),
      threeMonthGrowthPercent: int(),
      oneMonthGrowthPercent: int(),
      trendingDirection: mysqlEnum(["up", "down", "stable"]).default("stable").notNull(),
      trendConfidence: int(),
      lastUpdated: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    suburbs = mysqlTable(
      "suburbs",
      {
        id: int().autoincrement().notNull(),
        cityId: int().notNull().references(() => cities.id, { onDelete: "cascade" }),
        name: varchar({ length: 200 }).notNull(),
        slug: varchar({ length: 200 }),
        placeId: varchar("place_id", { length: 255 }),
        seoTitle: varchar("seo_title", { length: 255 }),
        seoDescription: text("seo_description"),
        latitude: varchar({ length: 20 }),
        longitude: varchar({ length: 21 }),
        postalCode: varchar({ length: 10 }),
        // AI Insights
        pros: json("pros"),
        cons: json("cons"),
        aiGenerationDate: timestamp("ai_generation_date", { mode: "string" }),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_suburbs_slug").on(table.slug),
        index("idx_suburbs_place_id").on(table.placeId),
        index("idx_suburbs_slug_city").on(table.slug, table.cityId)
      ]
    );
    suburbReviews = mysqlTable(
      "suburb_reviews",
      {
        id: int().autoincrement().notNull(),
        suburbId: int("suburb_id").notNull().references(() => suburbs.id, { onDelete: "cascade" }),
        userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
        rating: int().notNull(),
        // 1-5
        userType: mysqlEnum("user_type", ["resident", "tenant", "landlord", "visitor"]).default("resident").notNull(),
        pros: text(),
        cons: text(),
        comment: text(),
        isVerified: tinyint("is_verified").default(0),
        isPublished: tinyint("is_published").default(0),
        // Default to unpublished for moderation, or 1 for auto-approve
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_suburb_reviews_suburb").on(table.suburbId),
        index("idx_suburb_reviews_user").on(table.userId),
        index("idx_suburb_reviews_rating").on(table.rating),
        index("idx_suburb_reviews_published").on(table.isPublished)
      ]
    );
    suburbsRelations = relations(suburbs, ({ one, many }) => ({
      city: one(cities, {
        fields: [suburbs.cityId],
        references: [cities.id]
      }),
      reviews: many(suburbReviews)
    }));
    suburbReviewsRelations = relations(suburbReviews, ({ one }) => ({
      suburb: one(suburbs, {
        fields: [suburbReviews.suburbId],
        references: [suburbs.id]
      }),
      user: one(users, {
        fields: [suburbReviews.userId],
        references: [users.id]
      })
    }));
    userBehaviorEvents = mysqlTable("user_behavior_events", {
      id: int().autoincrement().notNull(),
      userId: int().references(() => users.id, { onDelete: "set null" }),
      sessionId: varchar({ length: 255 }).notNull(),
      eventType: mysqlEnum(["property_view", "search", "save_property", "contact_agent", "map_interaction", "price_filter", "location_filter", "property_type_filter"]).notNull(),
      eventData: text(),
      propertyId: int().references(() => properties.id, { onDelete: "set null" }),
      suburbId: int().references(() => suburbs.id, { onDelete: "set null" }),
      cityId: int().references(() => cities.id, { onDelete: "set null" }),
      provinceId: int().references(() => provinces.id, { onDelete: "set null" }),
      priceRangeMin: int(),
      priceRangeMax: int(),
      propertyType: varchar({ length: 50 }),
      listingType: varchar({ length: 50 }),
      pageUrl: varchar({ length: 500 }),
      referrer: varchar({ length: 500 }),
      userAgent: text(),
      ipAddress: varchar({ length: 45 }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    userPreferences = mysqlTable("user_preferences", {
      id: int().autoincrement().notNull(),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      preferredPropertyTypes: text(),
      preferredPriceMin: int(),
      preferredPriceMax: int(),
      preferredBedrooms: int(),
      preferredBathrooms: int(),
      preferredPropertySize: text(),
      preferredLocations: text(),
      preferredDistance: int(),
      preferredProvices: text(),
      preferredCities: text(),
      preferredSuburbs: text(),
      requiredAmenities: text(),
      preferredAmenities: text(),
      propertyFeatures: text(),
      petFriendly: int(),
      furnished: mysqlEnum(["unfurnished", "semi_furnished", "fully_furnished"]),
      alertFrequency: mysqlEnum(["never", "instant", "daily", "weekly"]).default("daily"),
      emailNotifications: int().default(1),
      smsNotifications: int(),
      pushNotifications: int().default(1),
      isActive: int().default(1),
      locationWeight: int().default(30),
      priceWeight: int().default(25),
      featuresWeight: int().default(25),
      sizeWeight: int().default(20),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
      lastUsed: timestamp({ mode: "string" })
    });
    userRecommendations = mysqlTable("user_recommendations", {
      id: int().autoincrement().notNull(),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      preferredSuburbs: text(),
      preferredCities: text(),
      preferredPriceRange: text(),
      preferredPropertyTypes: text(),
      preferredListingTypes: text(),
      recommendedSuburbs: text(),
      recommendedProperties: text(),
      recommendedSimilarUsers: text(),
      recommendationClickCount: int(),
      recommendationConversionCount: int(),
      lastRecommendationUpdate: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    userSubscriptions = mysqlTable(
      "user_subscriptions",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        planId: varchar("plan_id", { length: 100 }).notNull(),
        status: mysqlEnum(["trial_active", "trial_expired", "active_paid", "past_due", "cancelled", "downgraded", "grace_period"]).default("trial_active").notNull(),
        trialStartedAt: timestamp("trial_started_at", { mode: "string" }),
        trialEndsAt: timestamp("trial_ends_at", { mode: "string" }),
        trialUsed: tinyint("trial_used").default(0),
        currentPeriodStart: timestamp("current_period_start", { mode: "string" }),
        currentPeriodEnd: timestamp("current_period_end", { mode: "string" }),
        cancelledAt: timestamp("cancelled_at", { mode: "string" }),
        endsAt: timestamp("ends_at", { mode: "string" }),
        stripeSubscriptionId: varchar("stripe_subscription_id", { length: 255 }),
        stripeCustomerId: varchar("stripe_customer_id", { length: 255 }),
        paystackSubscriptionCode: varchar("paystack_subscription_code", { length: 255 }),
        paystackCustomerCode: varchar("paystack_customer_code", { length: 255 }),
        amountZar: int("amount_zar"),
        billingInterval: mysqlEnum("billing_interval", ["monthly", "yearly"]),
        nextBillingDate: timestamp("next_billing_date", { mode: "string" }),
        paymentMethodLast4: varchar("payment_method_last4", { length: 4 }),
        paymentMethodType: varchar("payment_method_type", { length: 50 }),
        previousPlanId: varchar("previous_plan_id", { length: 100 }),
        downgradeScheduled: tinyint("downgrade_scheduled").default(0),
        downgradeToPlanId: varchar("downgrade_to_plan_id", { length: 100 }),
        downgradeEffectiveDate: timestamp("downgrade_effective_date", { mode: "string" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow()
      },
      (table) => [
        index("idx_user").on(table.userId),
        index("idx_status").on(table.status),
        index("unique_user_subscription").on(table.userId)
      ]
    );
    users = mysqlTable(
      "users",
      {
        id: int().autoincrement().notNull(),
        openId: varchar({ length: 64 }),
        email: varchar({ length: 320 }),
        passwordHash: varchar({ length: 255 }),
        name: text(),
        firstName: varchar({ length: 100 }),
        lastName: varchar({ length: 100 }),
        phone: varchar({ length: 30 }),
        loginMethod: varchar({ length: 64 }),
        emailVerified: int().notNull(),
        role: mysqlEnum(["visitor", "agent", "agency_admin", "property_developer", "super_admin"]).default("visitor").notNull(),
        agencyId: int().references(() => agencies.id, { onDelete: "set null" }),
        isSubaccount: int().notNull(),
        createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull(),
        lastSignedIn: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        passwordResetToken: varchar({ length: 255 }),
        passwordResetTokenExpiresAt: timestamp({ mode: "string" }),
        emailVerificationToken: varchar({ length: 255 })
      },
      (table) => [
        index("email_idx").on(table.email),
        index("role_idx").on(table.role)
      ]
    );
    videoLikes = mysqlTable("videoLikes", {
      id: int().autoincrement().notNull(),
      videoId: int().notNull().references(() => videos.id, { onDelete: "cascade" }),
      userId: int().notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    videos = mysqlTable("videos", {
      id: int().autoincrement().notNull(),
      agentId: int().references(() => agents.id, { onDelete: "cascade" }),
      propertyId: int().references(() => properties.id, { onDelete: "set null" }),
      developmentId: int().references(() => developments.id, { onDelete: "set null" }),
      videoUrl: text().notNull(),
      caption: text(),
      type: mysqlEnum(["listing", "content"]).default("content").notNull(),
      duration: int(),
      views: int().notNull(),
      likes: int().notNull(),
      shares: int().notNull(),
      isPublished: int().default(1).notNull(),
      isFeatured: int().notNull(),
      createdAt: timestamp({ mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
      updatedAt: timestamp({ mode: "string" }).defaultNow().onUpdateNow().notNull()
    });
    exploreContent = mysqlTable(
      "explore_content",
      {
        id: int().autoincrement().notNull(),
        contentType: varchar("content_type", { length: 50 }).notNull(),
        referenceId: int("reference_id").notNull(),
        creatorId: int("creator_id"),
        creatorType: mysqlEnum("creator_type", ["user", "agent", "developer", "agency"]).default("user").notNull(),
        agencyId: int("agency_id"),
        partnerId: varchar("partner_id", { length: 36 }),
        contentCategory: mysqlEnum("content_category", ["primary", "secondary", "tertiary"]).default("primary"),
        badgeType: varchar("badge_type", { length: 50 }),
        isLaunchContent: boolean("is_launch_content").default(false),
        title: varchar({ length: 255 }),
        description: text(),
        thumbnailUrl: varchar("thumbnail_url", { length: 500 }),
        videoUrl: varchar("video_url", { length: 500 }),
        metadata: json(),
        tags: json(),
        lifestyleCategories: json("lifestyle_categories"),
        locationLat: decimal("location_lat", { precision: 10, scale: 8 }),
        locationLng: decimal("location_lng", { precision: 11, scale: 8 }),
        priceMin: int("price_min"),
        priceMax: int("price_max"),
        viewCount: int("view_count").default(0),
        engagementScore: decimal("engagement_score", { precision: 5, scale: 2 }).default("0"),
        isActive: tinyint("is_active").default(1),
        isFeatured: tinyint("is_featured").default(0),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_explore_content_type").on(table.contentType),
        index("idx_explore_content_creator").on(table.creatorId),
        index("idx_explore_content_creator_type").on(table.creatorType),
        index("idx_explore_content_agency_id").on(table.agencyId),
        index("idx_content_partner").on(table.partnerId),
        index("idx_content_category").on(table.contentCategory),
        index("idx_explore_content_location").on(table.locationLat, table.locationLng),
        index("idx_explore_content_engagement").on(table.engagementScore),
        index("idx_explore_content_active").on(table.isActive, table.createdAt),
        index("idx_explore_content_agency_active").on(table.agencyId, table.isActive, table.createdAt)
      ]
    );
    exploreDiscoveryVideos = mysqlTable(
      "explore_discovery_videos",
      {
        id: int().autoincrement().notNull(),
        exploreContentId: int("explore_content_id").notNull().references(() => exploreContent.id, { onDelete: "cascade" }),
        propertyId: int("property_id").references(() => properties.id, { onDelete: "set null" }),
        developmentId: int("development_id").references(() => developments.id, { onDelete: "set null" }),
        videoUrl: varchar("video_url", { length: 500 }).notNull(),
        thumbnailUrl: varchar("thumbnail_url", { length: 500 }).notNull(),
        duration: int().notNull(),
        transcodedUrls: json("transcoded_urls"),
        musicTrack: varchar("music_track", { length: 255 }),
        hasSubtitles: tinyint("has_subtitles").default(0),
        subtitleUrl: varchar("subtitle_url", { length: 500 }),
        totalViews: int("total_views").default(0),
        totalWatchTime: int("total_watch_time").default(0),
        completionRate: decimal("completion_rate", { precision: 5, scale: 2 }).default("0"),
        saveCount: int("save_count").default(0),
        shareCount: int("share_count").default(0),
        clickThroughCount: int("click_through_count").default(0),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_explore_discovery_videos_content").on(table.exploreContentId),
        index("idx_explore_discovery_videos_property").on(table.propertyId),
        index("idx_explore_discovery_videos_development").on(table.developmentId),
        index("idx_explore_discovery_videos_performance").on(table.completionRate, table.totalViews)
      ]
    );
    exploreNeighbourhoods = mysqlTable(
      "explore_neighbourhoods",
      {
        id: int().autoincrement().notNull(),
        name: varchar({ length: 255 }).notNull(),
        slug: varchar({ length: 255 }).notNull(),
        city: varchar({ length: 100 }),
        province: varchar({ length: 100 }),
        heroBannerUrl: varchar("hero_banner_url", { length: 500 }),
        description: text(),
        locationLat: decimal("location_lat", { precision: 10, scale: 8 }),
        locationLng: decimal("location_lng", { precision: 11, scale: 8 }),
        boundaryPolygon: json("boundary_polygon"),
        amenities: json(),
        safetyRating: decimal("safety_rating", { precision: 3, scale: 2 }),
        walkabilityScore: int("walkability_score"),
        avgPropertyPrice: int("avg_property_price"),
        priceTrend: json("price_trend"),
        highlights: json(),
        followerCount: int("follower_count").default(0),
        propertyCount: int("property_count").default(0),
        videoCount: int("video_count").default(0),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_explore_neighbourhoods_location").on(table.locationLat, table.locationLng),
        index("idx_explore_neighbourhoods_slug").on(table.slug),
        index("idx_explore_neighbourhoods_city").on(table.city, table.province)
      ]
    );
    exploreUserPreferencesNew = mysqlTable(
      "explore_user_preferences_new",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        priceRangeMin: int("price_range_min"),
        priceRangeMax: int("price_range_max"),
        preferredLocations: json("preferred_locations"),
        preferredPropertyTypes: json("preferred_property_types"),
        preferredLifestyleCategories: json("preferred_lifestyle_categories"),
        followedNeighbourhoods: json("followed_neighbourhoods"),
        followedCreators: json("followed_creators"),
        engagementHistory: json("engagement_history"),
        lastActive: timestamp("last_active", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_explore_user_pref_user").on(table.userId),
        index("idx_explore_user_pref_active").on(table.lastActive)
      ]
    );
    exploreFeedSessions = mysqlTable(
      "explore_feed_sessions",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
        sessionStart: timestamp("session_start", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
        sessionEnd: timestamp("session_end", { mode: "string" }),
        totalDuration: int("total_duration"),
        videosViewed: int("videos_viewed").default(0),
        videosCompleted: int("videos_completed").default(0),
        propertiesSaved: int("properties_saved").default(0),
        clickThroughs: int("click_throughs").default(0),
        deviceType: varchar("device_type", { length: 50 }),
        sessionData: json("session_data")
      },
      (table) => [
        index("idx_explore_sessions_user").on(table.userId),
        index("idx_explore_sessions_start").on(table.sessionStart)
      ]
    );
    exploreEngagements = mysqlTable(
      "explore_engagements",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
        contentId: int("content_id").notNull().references(() => exploreContent.id, { onDelete: "cascade" }),
        engagementType: varchar("engagement_type", { length: 50 }).notNull(),
        watchTime: int("watch_time"),
        completed: tinyint().default(0),
        sessionId: int("session_id").references(() => exploreFeedSessions.id, { onDelete: "set null" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_explore_engagement_user").on(table.userId),
        index("idx_explore_engagement_content").on(table.contentId),
        index("idx_explore_engagement_type").on(table.engagementType),
        index("idx_explore_engagement_created").on(table.createdAt)
      ]
    );
    exploreBoostCampaigns = mysqlTable(
      "explore_boost_campaigns",
      {
        id: int().autoincrement().notNull(),
        creatorId: int("creator_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        contentId: int("content_id").notNull().references(() => exploreContent.id, { onDelete: "cascade" }),
        campaignName: varchar("campaign_name", { length: 255 }),
        budget: decimal({ precision: 10, scale: 2 }),
        spent: decimal({ precision: 10, scale: 2 }).default("0"),
        durationDays: int("duration_days"),
        startDate: timestamp("start_date", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
        endDate: timestamp("end_date", { mode: "string" }),
        targetAudience: json("target_audience"),
        status: varchar({ length: 50 }).default("active"),
        impressions: int().default(0),
        clicks: int().default(0),
        conversions: int().default(0),
        costPerClick: decimal("cost_per_click", { precision: 10, scale: 2 }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_boost_campaigns_creator").on(table.creatorId),
        index("idx_boost_campaigns_status").on(table.status),
        index("idx_boost_campaigns_dates").on(table.startDate, table.endDate),
        index("idx_boost_campaigns_active").on(table.status, table.endDate)
      ]
    );
    exploreSavedProperties = mysqlTable(
      "explore_saved_properties",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        contentId: int("content_id").notNull().references(() => exploreContent.id, { onDelete: "cascade" }),
        collectionName: varchar("collection_name", { length: 255 }).default("Default"),
        notes: text(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("unique_user_content").on(table.userId, table.contentId),
        index("idx_explore_saved_user").on(table.userId, table.createdAt),
        index("idx_explore_saved_collection").on(table.userId, table.collectionName)
      ]
    );
    exploreNeighbourhoodFollows = mysqlTable(
      "explore_neighbourhood_follows",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        neighbourhoodId: int("neighbourhood_id").notNull().references(() => exploreNeighbourhoods.id, { onDelete: "cascade" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("unique_user_neighbourhood").on(table.userId, table.neighbourhoodId),
        index("idx_explore_neighbourhood_follows_user").on(table.userId)
      ]
    );
    exploreCreatorFollows = mysqlTable(
      "explore_creator_follows",
      {
        id: int().autoincrement().notNull(),
        userId: int("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        creatorId: int("creator_id").notNull().references(() => users.id, { onDelete: "cascade" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("unique_user_creator").on(table.userId, table.creatorId),
        index("idx_explore_creator_follows_user").on(table.userId),
        index("idx_explore_creator_follows_creator").on(table.creatorId)
      ]
    );
    developerSubscriptionsRelations = relations(developerSubscriptions, ({ one }) => ({
      limits: one(developerSubscriptionLimits, {
        fields: [developerSubscriptions.id],
        references: [developerSubscriptionLimits.subscriptionId]
      }),
      usage: one(developerSubscriptionUsage, {
        fields: [developerSubscriptions.id],
        references: [developerSubscriptionUsage.subscriptionId]
      })
    }));
    developerSubscriptionLimitsRelations = relations(developerSubscriptionLimits, ({ one }) => ({
      subscription: one(developerSubscriptions, {
        fields: [developerSubscriptionLimits.subscriptionId],
        references: [developerSubscriptions.id]
      })
    }));
    developerSubscriptionUsageRelations = relations(developerSubscriptionUsage, ({ one }) => ({
      subscription: one(developerSubscriptions, {
        fields: [developerSubscriptionUsage.subscriptionId],
        references: [developerSubscriptions.id]
      })
    }));
    usersRelations = relations(users, ({ one, many }) => ({
      developerProfiles: many(developers),
      auditLogs: many(auditLogs)
    }));
    developersRelations = relations(developers, ({ one, many }) => ({
      user: one(users, {
        fields: [developers.userId],
        references: [users.id]
      }),
      developments: many(developments),
      subscriptions: many(developerSubscriptions),
      activities: many(activities),
      drafts: many(developmentDrafts)
    }));
    developmentsRelations = relations(developments, ({ one, many }) => ({
      developer: one(developers, {
        fields: [developments.developerId],
        references: [developers.id]
      }),
      phases: many(developmentPhases),
      units: many(developmentUnits),
      approvalRecords: many(developmentApprovalQueue),
      documents: many(developmentDocuments)
    }));
    developmentPhasesRelations = relations(developmentPhases, ({ one, many }) => ({
      development: one(developments, {
        fields: [developmentPhases.developmentId],
        references: [developments.id]
      }),
      units: many(developmentUnits)
    }));
    developmentUnitsRelations = relations(developmentUnits, ({ one }) => ({
      development: one(developments, {
        fields: [developmentUnits.developmentId],
        references: [developments.id]
      }),
      phase: one(developmentPhases, {
        fields: [developmentUnits.phaseId],
        references: [developmentPhases.id]
      })
    }));
    developmentApprovalQueueRelations = relations(developmentApprovalQueue, ({ one }) => ({
      development: one(developments, {
        fields: [developmentApprovalQueue.developmentId],
        references: [developments.id]
      }),
      reviewedByUser: one(users, {
        fields: [developmentApprovalQueue.reviewedBy],
        references: [users.id]
      })
    }));
    auditLogsRelations = relations(auditLogs, ({ one }) => ({
      user: one(users, {
        fields: [auditLogs.userId],
        references: [users.id]
      })
    }));
    partnerTiers = mysqlTable("partner_tiers", {
      id: int().notNull(),
      name: varchar({ length: 100 }).notNull(),
      allowedContentTypes: json("allowed_content_types").notNull(),
      allowedCtas: json("allowed_ctas").notNull(),
      requiresCredentials: boolean("requires_credentials").default(false),
      maxMonthlyContent: int("max_monthly_content").default(10),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    explorePartners = mysqlTable("explore_partners", {
      id: varchar({ length: 36 }).primaryKey(),
      userId: varchar("user_id", { length: 36 }).notNull(),
      tierId: int("tier_id").notNull().references(() => partnerTiers.id),
      companyName: varchar("company_name", { length: 255 }).notNull(),
      description: text(),
      logoUrl: varchar("logo_url", { length: 500 }),
      verificationStatus: mysqlEnum("verification_status", ["pending", "verified", "rejected"]).default("pending"),
      trustScore: decimal("trust_score", { precision: 5, scale: 2 }).default("50.00"),
      serviceLocations: json("service_locations"),
      approvedContentCount: int("approved_content_count").default(0),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
      updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow()
    }, (table) => [
      index("idx_partner_tier").on(table.tierId),
      index("idx_partner_verification").on(table.verificationStatus),
      index("idx_partner_trust").on(table.trustScore)
    ]);
    topics = mysqlTable("topics", {
      id: varchar({ length: 36 }).primaryKey(),
      slug: varchar({ length: 100 }).notNull().unique(),
      name: varchar({ length: 100 }).notNull(),
      description: text(),
      icon: varchar({ length: 50 }),
      displayOrder: int("display_order").default(0),
      isActive: boolean("is_active").default(true),
      contentTags: json("content_tags"),
      propertyFeatures: json("property_features"),
      partnerCategories: json("partner_categories"),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      index("idx_topic_slug").on(table.slug),
      index("idx_topic_active").on(table.isActive, table.displayOrder)
    ]);
    contentTopics = mysqlTable("content_topics", {
      contentId: varchar("content_id", { length: 36 }).notNull(),
      topicId: varchar("topic_id", { length: 36 }).notNull().references(() => topics.id, { onDelete: "cascade" }),
      relevanceScore: decimal("relevance_score", { precision: 5, scale: 2 }).default("1.00"),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      index("idx_content_topic").on(table.topicId)
    ]);
    contentApprovalQueue = mysqlTable("content_approval_queue", {
      id: varchar({ length: 36 }).primaryKey(),
      contentId: varchar("content_id", { length: 36 }).notNull(),
      partnerId: varchar("partner_id", { length: 36 }).notNull().references(() => explorePartners.id, { onDelete: "cascade" }),
      status: mysqlEnum(["pending", "approved", "rejected", "revision_requested"]).default("pending"),
      submittedAt: timestamp("submitted_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
      reviewedAt: timestamp("reviewed_at", { mode: "string" }),
      reviewerId: varchar("reviewer_id", { length: 36 }),
      feedback: text(),
      autoApprovalEligible: boolean("auto_approval_eligible").default(false)
    }, (table) => [
      index("idx_approval_status").on(table.status),
      index("idx_approval_partner").on(table.partnerId)
    ]);
    partnerSubscriptions = mysqlTable("partner_subscriptions", {
      id: varchar({ length: 36 }).primaryKey(),
      partnerId: varchar("partner_id", { length: 36 }).notNull().references(() => explorePartners.id, { onDelete: "cascade" }),
      tier: mysqlEnum(["free", "basic", "premium", "featured"]).notNull(),
      priceMonthly: decimal("price_monthly", { precision: 10, scale: 2 }).notNull(),
      startDate: timestamp("start_date", { mode: "string" }).notNull(),
      endDate: timestamp("end_date", { mode: "string" }),
      status: mysqlEnum(["active", "cancelled", "expired"]).default("active"),
      features: json().notNull(),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      index("idx_subscription_partner").on(table.partnerId),
      index("idx_subscription_status").on(table.status)
    ]);
    contentQualityScores = mysqlTable("content_quality_scores", {
      contentId: varchar("content_id", { length: 36 }).primaryKey(),
      overallScore: decimal("overall_score", { precision: 5, scale: 2 }).default("50.00"),
      metadataScore: decimal("metadata_score", { precision: 5, scale: 2 }).default("0"),
      engagementScore: decimal("engagement_score", { precision: 5, scale: 2 }).default("0"),
      productionScore: decimal("production_score", { precision: 5, scale: 2 }).default("0"),
      negativeSignals: int("negative_signals").default(0),
      lastCalculatedAt: timestamp("last_calculated_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      index("idx_quality_score").on(table.overallScore)
    ]);
    boostCampaigns = mysqlTable("boost_campaigns", {
      id: varchar({ length: 36 }).primaryKey(),
      partnerId: varchar("partner_id", { length: 36 }).notNull().references(() => explorePartners.id, { onDelete: "cascade" }),
      contentId: varchar("content_id", { length: 36 }).notNull(),
      topicId: varchar("topic_id", { length: 36 }).notNull().references(() => topics.id, { onDelete: "cascade" }),
      budget: decimal({ precision: 10, scale: 2 }).notNull(),
      spent: decimal({ precision: 10, scale: 2 }).default("0"),
      status: mysqlEnum(["draft", "active", "paused", "completed", "depleted"]).default("draft"),
      startDate: timestamp("start_date", { mode: "string" }).notNull(),
      endDate: timestamp("end_date", { mode: "string" }),
      impressions: int().default(0),
      clicks: int().default(0),
      costPerImpression: decimal("cost_per_impression", { precision: 6, scale: 4 }).default("0.10"),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      index("idx_boost_status").on(table.status),
      index("idx_boost_topic").on(table.topicId, table.status),
      index("idx_boost_partner").on(table.partnerId)
    ]);
    partnerLeads = mysqlTable("partner_leads", {
      id: varchar({ length: 36 }).primaryKey(),
      partnerId: varchar("partner_id", { length: 36 }).notNull().references(() => explorePartners.id, { onDelete: "cascade" }),
      userId: varchar("user_id", { length: 36 }).notNull(),
      contentId: varchar("content_id", { length: 36 }),
      type: mysqlEnum(["quote_request", "consultation", "eligibility_check"]).notNull(),
      status: mysqlEnum(["new", "contacted", "converted", "disputed", "refunded"]).default("new"),
      price: decimal({ precision: 10, scale: 2 }).notNull(),
      contactInfo: json("contact_info").notNull(),
      intentDetails: text("intent_details"),
      disputeReason: text("dispute_reason"),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
      updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow()
    }, (table) => [
      index("idx_lead_partner").on(table.partnerId),
      index("idx_lead_status").on(table.status),
      index("idx_lead_type").on(table.type)
    ]);
    marketplaceBundles = mysqlTable("marketplace_bundles", {
      id: varchar({ length: 36 }).primaryKey(),
      slug: varchar({ length: 100 }).notNull().unique(),
      name: varchar({ length: 255 }).notNull(),
      description: text(),
      targetAudience: varchar("target_audience", { length: 100 }),
      isActive: boolean("is_active").default(true),
      displayOrder: int("display_order").default(0),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    bundlePartners = mysqlTable("bundle_partners", {
      bundleId: varchar("bundle_id", { length: 36 }).notNull().references(() => marketplaceBundles.id, { onDelete: "cascade" }),
      partnerId: varchar("partner_id", { length: 36 }).notNull().references(() => explorePartners.id, { onDelete: "cascade" }),
      category: varchar({ length: 100 }).notNull(),
      displayOrder: int("display_order").default(0),
      inclusionFee: decimal("inclusion_fee", { precision: 10, scale: 2 }),
      performanceScore: decimal("performance_score", { precision: 5, scale: 2 }).default("50.00")
    }, (table) => [
      index("idx_bundle_category").on(table.bundleId, table.category)
    ]);
    launchPhases = mysqlTable("launch_phases", {
      id: varchar({ length: 36 }).primaryKey(),
      phase: mysqlEnum(["pre_launch", "launch_period", "ramp_up", "ecosystem_maturity"]).notNull(),
      startDate: timestamp("start_date", { mode: "string" }).notNull(),
      endDate: timestamp("end_date", { mode: "string" }),
      primaryContentRatio: decimal("primary_content_ratio", { precision: 3, scale: 2 }).default("0.70"),
      algorithmWeight: decimal("algorithm_weight", { precision: 3, scale: 2 }).default("0.00"),
      editorialWeight: decimal("editorial_weight", { precision: 3, scale: 2 }).default("1.00"),
      isActive: boolean("is_active").default(false),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    launchContentQuotas = mysqlTable("launch_content_quotas", {
      id: varchar({ length: 36 }).primaryKey(),
      contentType: varchar("content_type", { length: 50 }).notNull().unique(),
      requiredCount: int("required_count").notNull(),
      currentCount: int("current_count").default(0),
      lastUpdated: timestamp("last_updated", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    launchMetrics = mysqlTable("launch_metrics", {
      id: varchar({ length: 36 }).primaryKey(),
      metricDate: timestamp("metric_date", { mode: "string" }).notNull(),
      topicEngagementRate: decimal("topic_engagement_rate", { precision: 5, scale: 2 }),
      partnerContentWatchRate: decimal("partner_content_watch_rate", { precision: 5, scale: 2 }),
      saveShareRate: decimal("save_share_rate", { precision: 5, scale: 2 }),
      weeklyVisitsPerUser: decimal("weekly_visits_per_user", { precision: 5, scale: 2 }),
      algorithmConfidenceScore: decimal("algorithm_confidence_score", { precision: 5, scale: 2 }),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      index("idx_metrics_date").on(table.metricDate)
    ]);
    userOnboardingState = mysqlTable("user_onboarding_state", {
      userId: varchar("user_id", { length: 36 }).primaryKey(),
      isFirstSession: boolean("is_first_session").default(true),
      welcomeOverlayShown: boolean("welcome_overlay_shown").default(false),
      welcomeOverlayDismissed: boolean("welcome_overlay_dismissed").default(false),
      suggestedTopics: json("suggested_topics"),
      tooltipsShown: json("tooltips_shown").default("[]"),
      contentViewCount: int("content_view_count").default(0),
      saveCount: int("save_count").default(0),
      partnerEngagementCount: int("partner_engagement_count").default(0),
      featuresUnlocked: json("features_unlocked").default("[]"),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`),
      updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow()
    });
    foundingPartners = mysqlTable("founding_partners", {
      partnerId: varchar("partner_id", { length: 36 }).primaryKey().references(() => explorePartners.id, { onDelete: "cascade" }),
      enrollmentDate: timestamp("enrollment_date", { mode: "string" }).notNull(),
      benefitsEndDate: timestamp("benefits_end_date", { mode: "string" }).notNull(),
      preLaunchContentDelivered: int("pre_launch_content_delivered").default(0),
      weeklyContentDelivered: json("weekly_content_delivered").default("[]"),
      warningCount: int("warning_count").default(0),
      status: mysqlEnum(["active", "warning", "revoked"]).default("active"),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    explorePartnersRelations = relations(explorePartners, ({ one, many }) => ({
      tier: one(partnerTiers, {
        fields: [explorePartners.tierId],
        references: [partnerTiers.id]
      }),
      subscriptions: many(partnerSubscriptions),
      boostCampaigns: many(boostCampaigns),
      leads: many(partnerLeads),
      content: many(exploreContent),
      shorts: many(exploreShorts)
    }));
    partnerTiersRelations = relations(partnerTiers, ({ many }) => ({
      partners: many(explorePartners)
    }));
    topicsRelations = relations(topics, ({ many }) => ({
      contentTopics: many(contentTopics),
      boostCampaigns: many(boostCampaigns)
    }));
    contentTopicsRelations = relations(contentTopics, ({ one }) => ({
      topic: one(topics, {
        fields: [contentTopics.topicId],
        references: [topics.id]
      })
    }));
    partnerSubscriptionsRelations = relations(partnerSubscriptions, ({ one }) => ({
      partner: one(explorePartners, {
        fields: [partnerSubscriptions.partnerId],
        references: [explorePartners.id]
      })
    }));
    boostCampaignsRelations = relations(boostCampaigns, ({ one }) => ({
      partner: one(explorePartners, {
        fields: [boostCampaigns.partnerId],
        references: [explorePartners.id]
      }),
      topic: one(topics, {
        fields: [boostCampaigns.topicId],
        references: [topics.id]
      })
    }));
    partnerLeadsRelations = relations(partnerLeads, ({ one }) => ({
      partner: one(explorePartners, {
        fields: [partnerLeads.partnerId],
        references: [explorePartners.id]
      })
    }));
    contentApprovalQueueRelations = relations(contentApprovalQueue, ({ one }) => ({
      partner: one(explorePartners, {
        fields: [contentApprovalQueue.partnerId],
        references: [explorePartners.id]
      })
    }));
    foundingPartnersRelations = relations(foundingPartners, ({ one }) => ({
      partner: one(explorePartners, {
        fields: [foundingPartners.partnerId],
        references: [explorePartners.id]
      })
    }));
    agentMemory = mysqlTable(
      "agent_memory",
      {
        id: int().autoincrement().primaryKey().notNull(),
        sessionId: varchar("session_id", { length: 100 }).notNull(),
        conversationId: varchar("conversation_id", { length: 100 }),
        userId: int("user_id").references(() => users.id, { onDelete: "cascade" }),
        userInput: text("user_input").notNull(),
        agentResponse: text("agent_response").notNull(),
        metadata: json().$type(),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull()
      },
      (table) => [
        index("idx_agent_memory_session").on(table.sessionId),
        index("idx_agent_memory_conversation").on(table.conversationId),
        index("idx_agent_memory_user").on(table.userId),
        index("idx_agent_memory_created").on(table.createdAt)
      ]
    );
    agentTasks = mysqlTable(
      "agent_tasks",
      {
        id: int().autoincrement().primaryKey().notNull(),
        taskId: varchar("task_id", { length: 100 }).notNull(),
        sessionId: varchar("session_id", { length: 100 }),
        userId: int("user_id").references(() => users.id, { onDelete: "set null" }),
        taskType: varchar("task_type", { length: 50 }).notNull(),
        status: mysqlEnum(["pending", "running", "completed", "failed"]).default("pending").notNull(),
        priority: int().default(0).notNull(),
        inputData: json("input_data"),
        outputData: json("output_data"),
        errorMessage: text("error_message"),
        startedAt: timestamp("started_at", { mode: "string" }),
        completedAt: timestamp("completed_at", { mode: "string" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        unique("unique_task_id").on(table.taskId),
        index("idx_agent_tasks_status").on(table.status),
        index("idx_agent_tasks_type").on(table.taskType),
        index("idx_agent_tasks_user").on(table.userId),
        index("idx_agent_tasks_session").on(table.sessionId),
        index("idx_agent_tasks_created").on(table.createdAt)
      ]
    );
    agentKnowledge = mysqlTable(
      "agent_knowledge",
      {
        id: int().autoincrement().primaryKey().notNull(),
        topic: varchar({ length: 200 }).notNull(),
        content: text().notNull(),
        category: varchar({ length: 100 }),
        tags: json().$type(),
        metadata: json().$type(),
        // Optional: Vector embedding for semantic search (uncomment if needed)
        // embedding: vector({ dimensions: 1536 }), // For OpenAI embeddings
        isActive: int("is_active").default(1).notNull(),
        createdBy: int("created_by").references(() => users.id, { onDelete: "set null" }),
        createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
        updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().onUpdateNow().notNull()
      },
      (table) => [
        index("idx_agent_knowledge_topic").on(table.topic),
        index("idx_agent_knowledge_category").on(table.category),
        index("idx_agent_knowledge_active").on(table.isActive),
        index("idx_agent_knowledge_created").on(table.createdAt)
      ]
    );
  }
});

// server/_core/env.ts
var env_exports = {};
__export(env_exports, {
  ENV: () => ENV
});
var ENV;
var init_env = __esm({
  "server/_core/env.ts"() {
    "use strict";
    ENV = {
      appId: process.env.VITE_APP_ID ?? "",
      cookieSecret: process.env.JWT_SECRET ?? "",
      appUrl: process.env.VITE_APP_URL ?? "http://localhost:5173",
      databaseUrl: process.env.DATABASE_URL ?? "",
      oAuthServerUrl: process.env.OAUTH_SERVER_URL ?? "",
      ownerId: process.env.OWNER_OPEN_ID ?? "",
      isProduction: process.env.NODE_ENV === "production",
      forgeApiUrl: process.env.BUILT_IN_FORGE_API_URL ?? "",
      forgeApiKey: process.env.BUILT_IN_FORGE_API_KEY ?? "",
      // Stripe configuration
      stripePublishableKey: process.env.STRIPE_PUBLISHABLE_KEY ?? "",
      stripeSecretKey: process.env.STRIPE_SECRET_KEY ?? "",
      stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET ?? "",
      // Google Maps configuration
      googleMapsApiKey: process.env.GOOGLE_MAPS_API_KEY ?? "",
      googlePlacesApiKey: process.env.GOOGLE_PLACES_API_KEY ?? "",
      googleGeocodingApiKey: process.env.GOOGLE_GEOCODING_API_KEY ?? "",
      googleStreetViewApiKey: process.env.GOOGLE_STREET_VIEW_API_KEY ?? "",
      // AWS S3 + CloudFront configuration
      awsRegion: process.env.AWS_REGION ?? "us-east-1",
      awsAccessKeyId: process.env.AWS_ACCESS_KEY_ID ?? "",
      awsSecretAccessKey: process.env.AWS_SECRET_ACCESS_KEY ?? "",
      s3BucketName: process.env.S3_BUCKET_NAME ?? "",
      cloudFrontUrl: process.env.CLOUDFRONT_URL ?? "",
      maxImageSizeMb: parseInt(process.env.MAX_IMAGE_SIZE_MB ?? "10"),
      // Email configuration
      resendApiKey: process.env.RESEND_API_KEY ?? "",
      resendFromEmail: process.env.RESEND_FROM_EMAIL ?? "onboarding@resend.dev"
    };
  }
});

// server/utils/locationUtils.ts
function normalizeLocationFields(data) {
  return {
    ...data,
    province: data.province ? data.province.toLowerCase().trim() : data.province,
    city: data.city ? data.city.toLowerCase().trim() : data.city
    // Keep suburb as-is for now since it's often in address field
  };
}
function validateLocationForPublish(data) {
  const publishingStatuses = ["available", "published"];
  if (data.status && publishingStatuses.includes(data.status)) {
    if (!data.province || data.province.trim() === "") {
      return "Province is required to publish a property";
    }
    if (!data.city || data.city.trim() === "") {
      return "City is required to publish a property";
    }
  }
  return null;
}
var init_locationUtils = __esm({
  "server/utils/locationUtils.ts"() {
    "use strict";
  }
});

// server/db-connection.ts
import { drizzle } from "drizzle-orm/mysql2";
import mysql from "mysql2/promise";
async function getDb() {
  if (_db) return _db;
  if (!process.env.DATABASE_URL) {
    throw new Error(
      "DATABASE_URL is missing. Set it in .env.local (dev) or .env.production (prod)."
    );
  }
  try {
    const isProduction = process.env.NODE_ENV === "production";
    console.log("[Database] Attempting connection...");
    const poolConnection = mysql.createPool({
      uri: process.env.DATABASE_URL,
      ssl: {
        // TiDB Cloud / PlanetScale often require this to be false on some platforms
        // unless you provide the CA certificate explicitly.
        // We set it to false to ensure connectivity, relying on the encrypted channel.
        rejectUnauthorized: false
      },
      connectionLimit: 10,
      maxIdle: 10,
      idleTimeout: 6e4,
      enableKeepAlive: true,
      keepAliveInitialDelay: 0
    });
    _db = drizzle(poolConnection, { schema: schema_exports, mode: "default" });
    console.log("[Database] Connection pool initialized.");
    return _db;
  } catch (error) {
    console.error("[Database] Failed to connect:", error);
    _db = null;
    return null;
  }
}
var _db;
var init_db_connection = __esm({
  "server/db-connection.ts"() {
    "use strict";
    init_schema();
    _db = null;
  }
});

// server/services/locationResolverService.ts
import { eq, and, sql as sql2 } from "drizzle-orm";
var LocationResolverService, locationResolver;
var init_locationResolverService = __esm({
  "server/services/locationResolverService.ts"() {
    "use strict";
    init_db_connection();
    init_schema();
    LocationResolverService = class {
      /**
       * Resolve location slugs to full location data with IDs
       * Returns null if no valid location found
       */
      async resolveLocation(opts) {
        const db3 = await getDb();
        if (!db3) return null;
        const { provinceSlug, citySlug, suburbSlug } = opts;
        if (!provinceSlug) return null;
        const parts = [];
        if (suburbSlug) parts.push(suburbSlug);
        if (citySlug) parts.push(citySlug);
        if (provinceSlug) parts.push(provinceSlug);
        const originalIntent = parts.join(", ");
        const provinceResult = await db3.select({
          id: provinces.id,
          name: provinces.name,
          slug: provinces.slug,
          code: provinces.code
        }).from(provinces).where(sql2`LOWER(${provinces.slug}) = LOWER(${provinceSlug})`).limit(1);
        if (provinceResult.length === 0) {
          console.warn(`[LocationResolver] Province not found: ${provinceSlug}`);
          return null;
        }
        const province2 = {
          id: provinceResult[0].id,
          name: provinceResult[0].name,
          slug: provinceResult[0].slug || provinceSlug,
          code: provinceResult[0].code
        };
        if (!citySlug) {
          return {
            level: "province",
            province: province2,
            confidence: "exact",
            fallbackLevel: "none",
            originalIntent
          };
        }
        const cityResult = await db3.select({
          id: cities.id,
          name: cities.name,
          slug: cities.slug,
          provinceId: cities.provinceId,
          latitude: cities.latitude,
          longitude: cities.longitude
        }).from(cities).where(
          and(
            sql2`LOWER(${cities.slug}) = LOWER(${citySlug})`,
            eq(cities.provinceId, province2.id)
          )
        ).limit(1);
        if (cityResult.length === 0) {
          console.warn(`[LocationResolver] City not found: ${citySlug} in ${provinceSlug}, falling back to province`);
          return {
            level: "province",
            province: province2,
            confidence: "expanded",
            fallbackLevel: "city_to_province",
            originalIntent
          };
        }
        const city = {
          id: cityResult[0].id,
          name: cityResult[0].name,
          slug: cityResult[0].slug || citySlug,
          provinceId: cityResult[0].provinceId,
          latitude: cityResult[0].latitude || void 0,
          longitude: cityResult[0].longitude || void 0
        };
        if (!suburbSlug) {
          return {
            level: "city",
            province: province2,
            city,
            confidence: "exact",
            fallbackLevel: "none",
            originalIntent
          };
        }
        const suburbResult = await db3.select({
          id: suburbs.id,
          name: suburbs.name,
          slug: suburbs.slug,
          cityId: suburbs.cityId,
          latitude: suburbs.latitude,
          longitude: suburbs.longitude
        }).from(suburbs).where(
          and(
            sql2`LOWER(${suburbs.slug}) = LOWER(${suburbSlug})`,
            eq(suburbs.cityId, city.id)
          )
        ).limit(1);
        if (suburbResult.length === 0) {
          console.warn(`[LocationResolver] Suburb not found: ${suburbSlug} in ${citySlug}, falling back to city`);
          return {
            level: "city",
            province: province2,
            city,
            confidence: "expanded",
            fallbackLevel: "suburb_to_city",
            originalIntent
          };
        }
        const suburb = {
          id: suburbResult[0].id,
          name: suburbResult[0].name,
          slug: suburbResult[0].slug || suburbSlug,
          cityId: suburbResult[0].cityId,
          latitude: suburbResult[0].latitude || void 0,
          longitude: suburbResult[0].longitude || void 0
        };
        return {
          level: "suburb",
          province: province2,
          city,
          suburb,
          confidence: "exact",
          fallbackLevel: "none",
          originalIntent
        };
      }
      /**
       * Validate that a location hierarchy is valid
       * Returns true if the hierarchy is correct
       */
      async validateHierarchy(provinceSlug, citySlug, suburbSlug) {
        const location = await this.resolveLocation({
          provinceSlug,
          citySlug,
          suburbSlug
        });
        if (!location) return false;
        if (citySlug && !location.city) return false;
        if (suburbSlug && !location.suburb) return false;
        return true;
      }
      /**
       * Get location IDs for property queries
       * Returns an object with the available IDs
       */
      async getLocationIds(opts) {
        const location = await this.resolveLocation(opts);
        if (!location) return {};
        return {
          provinceId: location.province.id,
          cityId: location.city?.id,
          suburbId: location.suburb?.id
        };
      }
      /**
       * Get all cities in a province
       */
      async getCitiesInProvince(provinceSlug) {
        const db3 = await getDb();
        if (!db3) return [];
        const location = await this.resolveLocation({ provinceSlug });
        if (!location) return [];
        const result = await db3.select({
          id: cities.id,
          name: cities.name,
          slug: cities.slug,
          provinceId: cities.provinceId,
          latitude: cities.latitude,
          longitude: cities.longitude
        }).from(cities).where(eq(cities.provinceId, location.province.id)).orderBy(cities.name);
        return result.map((c) => ({
          id: c.id,
          name: c.name,
          slug: c.slug || "",
          provinceId: c.provinceId,
          latitude: c.latitude || void 0,
          longitude: c.longitude || void 0
        }));
      }
      /**
       * Get all suburbs in a city
       */
      async getSuburbsInCity(provinceSlug, citySlug) {
        const db3 = await getDb();
        if (!db3) return [];
        const location = await this.resolveLocation({ provinceSlug, citySlug });
        if (!location?.city) return [];
        const result = await db3.select({
          id: suburbs.id,
          name: suburbs.name,
          slug: suburbs.slug,
          cityId: suburbs.cityId,
          latitude: suburbs.latitude,
          longitude: suburbs.longitude
        }).from(suburbs).where(eq(suburbs.cityId, location.city.id)).orderBy(suburbs.name);
        return result.map((s) => ({
          id: s.id,
          name: s.name,
          slug: s.slug || "",
          cityId: s.cityId,
          latitude: s.latitude || void 0,
          longitude: s.longitude || void 0
        }));
      }
      /**
       * Create a new suburb if it doesn't exist
       * Returns the suburb ID (existing or newly created)
       */
      async ensureSuburbExists(opts) {
        const db3 = await getDb();
        if (!db3) return null;
        const { provinceSlug, citySlug, suburbName, suburbSlug, latitude, longitude } = opts;
        const slug = suburbSlug || this.slugify(suburbName);
        const location = await this.resolveLocation({
          provinceSlug,
          citySlug,
          suburbSlug: slug
        });
        if (location?.suburb) {
          return location.suburb.id;
        }
        if (!location?.city) {
          console.error(`[LocationResolver] Cannot create suburb: city not found (${citySlug})`);
          return null;
        }
        try {
          const result = await db3.insert(suburbs).values({
            cityId: location.city.id,
            name: suburbName,
            slug,
            latitude: latitude || null,
            longitude: longitude || null
          });
          console.log(`[LocationResolver] Created suburb: ${suburbName} (${slug})`);
          return Number(result[0].insertId);
        } catch (error) {
          console.error(`[LocationResolver] Failed to create suburb:`, error);
          return null;
        }
      }
      /**
       * Slugify a location name
       */
      slugify(name) {
        return name.toLowerCase().trim().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "").replace(/-+/g, "-").replace(/^-|-$/g, "");
      }
    };
    locationResolver = new LocationResolverService();
  }
});

// server/campaignBoost.ts
var campaignBoost_exports = {};
__export(campaignBoost_exports, {
  calculateListingBoostScore: () => calculateListingBoostScore,
  getActiveCampaignForListing: () => getActiveCampaignForListing,
  getBoostedListingsForChannel: () => getBoostedListingsForChannel,
  trackCampaignClick: () => trackCampaignClick,
  trackCampaignImpression: () => trackCampaignImpression
});
import { eq as eq2, and as and2, sql as sql3 } from "drizzle-orm";
async function calculateListingBoostScore(listingId) {
  const db3 = await getDb();
  if (!db3) return 0;
  try {
    const activeCampaigns = await db3.select({
      campaignId: marketingCampaigns.id,
      budgetAmount: campaignBudgets.budgetAmount,
      budgetType: campaignBudgets.budgetType
    }).from(marketingCampaigns).leftJoin(campaignBudgets, eq2(campaignBudgets.campaignId, marketingCampaigns.id)).where(
      and2(
        eq2(marketingCampaigns.targetType, "listing"),
        eq2(marketingCampaigns.targetId, listingId),
        eq2(marketingCampaigns.status, "active")
      )
    );
    if (activeCampaigns.length === 0) return 0;
    let totalBoost = 0;
    for (const campaign of activeCampaigns) {
      const budget = parseFloat(campaign.budgetAmount || "0");
      const multiplier = campaign.budgetType === "daily" ? 1.5 : 1;
      const boost = Math.log10(budget + 1) * multiplier;
      totalBoost += boost;
    }
    return totalBoost;
  } catch (error) {
    console.error("Error calculating boost score:", error);
    return 0;
  }
}
async function getBoostedListingsForChannel(channel, limit = 10) {
  const db3 = await getDb();
  if (!db3) return [];
  try {
    const boostedListings = await db3.select({
      listingId: marketingCampaigns.targetId,
      budgetAmount: campaignBudgets.budgetAmount,
      budgetType: campaignBudgets.budgetType
    }).from(marketingCampaigns).leftJoin(campaignBudgets, eq2(campaignBudgets.campaignId, marketingCampaigns.id)).leftJoin(campaignChannels, eq2(campaignChannels.campaignId, marketingCampaigns.id)).where(
      and2(
        eq2(marketingCampaigns.targetType, "listing"),
        eq2(marketingCampaigns.status, "active"),
        eq2(campaignChannels.type, channel),
        eq2(campaignChannels.enabled, true)
      )
    );
    const scoredListings = boostedListings.map((item) => {
      const budget = parseFloat(item.budgetAmount || "0");
      const multiplier = item.budgetType === "daily" ? 1.5 : 1;
      const score = Math.log10(budget + 1) * multiplier;
      return {
        listingId: item.listingId,
        score
      };
    });
    return scoredListings.sort((a, b) => b.score - a.score).slice(0, limit).map((item) => item.listingId);
  } catch (error) {
    console.error("Error getting boosted listings:", error);
    return [];
  }
}
async function trackCampaignImpression(campaignId) {
  const db3 = await getDb();
  if (!db3) return;
  try {
    await db3.execute(sql3`
      INSERT INTO campaign_performance (campaign_id, impressions, date)
      VALUES (${campaignId}, 1, CURDATE())
      ON DUPLICATE KEY UPDATE impressions = impressions + 1
    `);
  } catch (error) {
    console.error("Error tracking impression:", error);
  }
}
async function trackCampaignClick(campaignId) {
  const db3 = await getDb();
  if (!db3) return;
  try {
    await db3.execute(sql3`
      INSERT INTO campaign_performance (campaign_id, clicks, date)
      VALUES (${campaignId}, 1, CURDATE())
      ON DUPLICATE KEY UPDATE clicks = clicks + 1
    `);
  } catch (error) {
    console.error("Error tracking click:", error);
  }
}
async function getActiveCampaignForListing(listingId) {
  const db3 = await getDb();
  if (!db3) return null;
  try {
    const campaign = await db3.query.marketingCampaigns.findFirst({
      where: and2(
        eq2(marketingCampaigns.targetType, "listing"),
        eq2(marketingCampaigns.targetId, listingId),
        eq2(marketingCampaigns.status, "active")
      )
    });
    return campaign?.id || null;
  } catch (error) {
    console.error("Error getting active campaign:", error);
    return null;
  }
}
var marketingCampaigns, campaignBudgets, campaignChannels;
var init_campaignBoost = __esm({
  "server/campaignBoost.ts"() {
    "use strict";
    init_db();
    marketingCampaigns = { id: null, targetType: null, targetId: null, status: null };
    campaignBudgets = { campaignId: null, budgetAmount: null, budgetType: null };
    campaignChannels = { campaignId: null, type: null, enabled: null };
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  addFavorite: () => addFavorite,
  addProspectFavorite: () => addProspectFavorite,
  approveDeveloper: () => approveDeveloper,
  approveListing: () => approveListing,
  archiveListing: () => archiveListing,
  archiveProperty: () => archiveProperty,
  countPendingAgents: () => countPendingAgents,
  countPendingDevelopments: () => countPendingDevelopments,
  countPendingListings: () => countPendingListings,
  createAgentProfile: () => createAgentProfile,
  createDeveloper: () => createDeveloper,
  createLead: () => createLead,
  createListing: () => createListing,
  createPartner: () => createPartner,
  createProperty: () => createProperty,
  createPropertyImage: () => createPropertyImage,
  createProspect: () => createProspect,
  createReview: () => createReview,
  createUser: () => createUser,
  db: () => db,
  deleteListing: () => deleteListing,
  deletePartner: () => deletePartner,
  deleteProperty: () => deleteProperty,
  deletePropertyImage: () => deletePropertyImage,
  earnBadge: () => earnBadge,
  getAgencyAgents: () => getAgencyAgents,
  getAgencyCommissionStats: () => getAgencyCommissionStats,
  getAgencyDashboardStats: () => getAgencyDashboardStats,
  getAgencyPerformanceData: () => getAgencyPerformanceData,
  getAgencyRecentLeads: () => getAgencyRecentLeads,
  getAgencyRecentListings: () => getAgencyRecentListings,
  getAgentById: () => getAgentById,
  getAgentByUserId: () => getAgentByUserId,
  getAgentPerformanceLeaderboard: () => getAgentPerformanceLeaderboard,
  getAllAgents: () => getAllAgents,
  getAllDevelopments: () => getAllDevelopments,
  getAllExploreVideos: () => getAllExploreVideos,
  getAllLocations: () => getAllLocations,
  getAllPlatformSettings: () => getAllPlatformSettings,
  getAllServices: () => getAllServices,
  getApprovalQueue: () => getApprovalQueue,
  getDb: () => getDb,
  getDeveloperById: () => getDeveloperById,
  getDeveloperByUserId: () => getDeveloperByUserId,
  getDevelopmentById: () => getDevelopmentById,
  getDevelopmentProperties: () => getDevelopmentProperties,
  getEcosystemStats: () => getEcosystemStats,
  getExploreVideoById: () => getExploreVideoById,
  getFeaturedAgents: () => getFeaturedAgents,
  getFeaturedDevelopments: () => getFeaturedDevelopments,
  getFeaturedListings: () => getFeaturedListings,
  getFeaturedProperties: () => getFeaturedProperties,
  getLeadConversionStats: () => getLeadConversionStats,
  getLeadsByAgent: () => getLeadsByAgent,
  getListingAnalytics: () => getListingAnalytics,
  getListingById: () => getListingById,
  getListingMedia: () => getListingMedia,
  getListingStats: () => getListingStats,
  getLocationsByType: () => getLocationsByType,
  getPlatformAnalytics: () => getPlatformAnalytics,
  getPlatformSetting: () => getPlatformSetting,
  getPropertyById: () => getPropertyById,
  getPropertyImages: () => getPropertyImages,
  getProspect: () => getProspect,
  getProspectFavorites: () => getProspectFavorites,
  getRecentlyViewed: () => getRecentlyViewed,
  getRecommendedProperties: () => getRecommendedProperties,
  getReviewsByTarget: () => getReviewsByTarget,
  getScheduledViewings: () => getScheduledViewings,
  getServicesByCategory: () => getServicesByCategory,
  getSubscriptionStats: () => getSubscriptionStats,
  getUser: () => getUser,
  getUserByEmail: () => getUserByEmail,
  getUserByEmailVerificationToken: () => getUserByEmailVerificationToken,
  getUserById: () => getUserById,
  getUserByPasswordResetToken: () => getUserByPasswordResetToken,
  getUserFavorites: () => getUserFavorites,
  getUserListings: () => getUserListings,
  getUserProperties: () => getUserProperties,
  incrementPropertyViews: () => incrementPropertyViews,
  incrementVideoViews: () => incrementVideoViews,
  isFavorite: () => isFavorite,
  listDevelopers: () => listDevelopers,
  listPartners: () => listPartners,
  listPendingDevelopers: () => listPendingDevelopers,
  rejectDeveloper: () => rejectDeveloper,
  rejectListing: () => rejectListing,
  removeFavorite: () => removeFavorite,
  removeProspectFavorite: () => removeProspectFavorite,
  scheduleViewing: () => scheduleViewing,
  searchDevelopers: () => searchDevelopers,
  searchDevelopments: () => searchDevelopments,
  searchListings: () => searchListings,
  searchProperties: () => searchProperties,
  setDeveloperTrust: () => setDeveloperTrust,
  setPlatformSetting: () => setPlatformSetting,
  submitListingForReview: () => submitListingForReview,
  trackPropertyView: () => trackPropertyView,
  transformListingToProperty: () => transformListingToProperty,
  updateDeveloper: () => updateDeveloper,
  updateListing: () => updateListing,
  updatePartner: () => updatePartner,
  updateProperty: () => updateProperty,
  updateProspect: () => updateProspect,
  updateProspectProgress: () => updateProspectProgress,
  updateUserLastSignIn: () => updateUserLastSignIn,
  updateUserPassword: () => updateUserPassword,
  updateUserPasswordResetToken: () => updateUserPasswordResetToken,
  updateViewingStatus: () => updateViewingStatus,
  upsertUser: () => upsertUser,
  verifyUserEmail: () => verifyUserEmail
});
import {
  eq as eq3,
  desc,
  getTableColumns,
  and as and3,
  like,
  gte,
  lte,
  inArray,
  or,
  sql as sql4,
  count
} from "drizzle-orm";
async function upsertUser(user) {
  if (!user.openId) {
    throw new Error("User openId is required for upsert");
  }
  const db3 = await getDb();
  if (!db3) {
    console.warn("[Database] Cannot upsert user: database not available");
    return;
  }
  try {
    const values = {
      openId: user.openId
    };
    const updateSet = {};
    const textFields = ["name", "email", "loginMethod"];
    const assignNullable = (field) => {
      const value = user[field];
      if (value === void 0) return;
      const normalized = value ?? null;
      values[field] = normalized;
      updateSet[field] = normalized;
    };
    textFields.forEach(assignNullable);
    if (user.lastSignedIn !== void 0) {
      values.lastSignedIn = user.lastSignedIn;
      updateSet.lastSignedIn = user.lastSignedIn;
    }
    if (user.role !== void 0) {
      values.role = user.role;
      updateSet.role = user.role;
    } else if (user.openId === ENV.ownerId) {
      values.role = "super_admin";
      updateSet.role = "super_admin";
    }
    if (!values.lastSignedIn) {
      values.lastSignedIn = /* @__PURE__ */ new Date();
    }
    if (Object.keys(updateSet).length === 0) {
      updateSet.lastSignedIn = /* @__PURE__ */ new Date();
    }
    await db3.insert(users).values(values).onDuplicateKeyUpdate({
      set: updateSet
    });
  } catch (error) {
    console.error("[Database] Failed to upsert user:", error);
    throw error;
  }
}
async function getUser(openId) {
  const db3 = await getDb();
  if (!db3) {
    console.warn("[Database] Cannot get user: database not available");
    return void 0;
  }
  const result = await db3.select().from(users).where(eq3(users.openId, openId)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getUserById(id) {
  const db3 = await getDb();
  if (!db3) {
    console.warn("[Database] Cannot get user: database not available");
    return void 0;
  }
  const result = await db3.select().from(users).where(eq3(users.id, id)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getUserByEmail(email) {
  const db3 = await getDb();
  if (!db3) {
    console.warn("[Database] Cannot get user: database not available");
    return void 0;
  }
  const result = await db3.select().from(users).where(eq3(users.email, email)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function createUser(userData) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.insert(users).values({
    ...userData,
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date(),
    lastSignedIn: /* @__PURE__ */ new Date()
  });
  return Number(result[0].insertId);
}
async function updateUserLastSignIn(userId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(users).set({ lastSignedIn: /* @__PURE__ */ new Date() }).where(eq3(users.id, userId));
}
async function updateUserPasswordResetToken(userId, token, expiresAt) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(users).set({
    passwordResetToken: token,
    passwordResetTokenExpiresAt: expiresAt
  }).where(eq3(users.id, userId));
}
async function getUserByPasswordResetToken(token) {
  const db3 = await getDb();
  if (!db3) {
    console.warn("[Database] Cannot get user: database not available");
    return void 0;
  }
  const result = await db3.select().from(users).where(eq3(users.passwordResetToken, token)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateUserPassword(userId, passwordHash) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(users).set({
    passwordHash,
    passwordResetToken: null,
    passwordResetTokenExpiresAt: null
  }).where(eq3(users.id, userId));
}
async function getUserByEmailVerificationToken(token) {
  const db3 = await getDb();
  if (!db3) {
    console.warn("[Database] Cannot get user: database not available");
    return void 0;
  }
  const result = await db3.select().from(users).where(eq3(users.emailVerificationToken, token)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function verifyUserEmail(userId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(users).set({
    emailVerified: 1,
    emailVerificationToken: null
  }).where(eq3(users.id, userId));
}
async function createProperty(property) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const normalizedProperty = normalizeLocationFields(property);
  const validationError = validateLocationForPublish(normalizedProperty);
  if (validationError) {
    throw new Error(validationError);
  }
  try {
    if (normalizedProperty.province && !normalizedProperty.provinceId) {
      const locationIds = await locationResolver.getLocationIds({
        provinceSlug: normalizedProperty.province,
        citySlug: normalizedProperty.city || void 0
      });
      if (locationIds.provinceId) {
        normalizedProperty.provinceId = locationIds.provinceId;
      }
      if (locationIds.cityId) {
        normalizedProperty.cityId = locationIds.cityId;
      }
    }
  } catch (error) {
    console.warn("[createProperty] Location ID resolution failed:", error);
  }
  const result = await db3.insert(properties).values(normalizedProperty);
  return result[0].insertId;
}
async function createPropertyImage(image) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.insert(propertyImages).values(image);
}
async function getPropertyById(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.select().from(properties).where(eq3(properties.id, id)).limit(1);
  return result[0];
}
async function getPropertyImages(propertyId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(propertyImages).where(eq3(propertyImages.propertyId, propertyId)).orderBy(propertyImages.displayOrder);
}
async function getUserProperties(userId, limit = 20, offset = 0) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(properties).where(eq3(properties.ownerId, userId)).orderBy(desc(properties.createdAt)).limit(limit).offset(offset);
}
async function updateProperty(propertyId, userId, updates, userRole) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const property = await getPropertyById(propertyId);
  if (!property) {
    throw new Error("Property not found");
  }
  const isAdmin = userRole === "super_admin" || userRole === "agency_admin";
  if (property.ownerId !== userId && !isAdmin) {
    throw new Error("Unauthorized: You can only update your own properties");
  }
  const normalizedUpdates = normalizeLocationFields(updates);
  const finalData = { ...property, ...normalizedUpdates };
  const validationError = validateLocationForPublish(finalData);
  if (validationError) {
    throw new Error(validationError);
  }
  try {
    const province2 = normalizedUpdates.province || property.province;
    const city = normalizedUpdates.city || property.city;
    if (province2 && (normalizedUpdates.province || normalizedUpdates.city)) {
      const locationIds = await locationResolver.getLocationIds({
        provinceSlug: province2,
        citySlug: city || void 0
      });
      if (locationIds.provinceId) {
        normalizedUpdates.provinceId = locationIds.provinceId;
      }
      if (locationIds.cityId) {
        normalizedUpdates.cityId = locationIds.cityId;
      }
    }
  } catch (error) {
    console.warn("[updateProperty] Location ID resolution failed:", error);
  }
  await db3.update(properties).set({
    ...normalizedUpdates,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq3(properties.id, propertyId));
}
async function deleteProperty(propertyId, userId, userRole) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const property = await getPropertyById(propertyId);
  if (!property) {
    throw new Error("Property not found");
  }
  const isAdmin = userRole === "super_admin" || userRole === "agency_admin";
  if (property.ownerId !== userId && !isAdmin) {
    throw new Error("Unauthorized: You can only delete your own properties");
  }
  await db3.delete(properties).where(eq3(properties.id, propertyId));
}
async function deletePropertyImage(imageId, userId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const image = await db3.select().from(propertyImages).where(eq3(propertyImages.id, imageId)).limit(1);
  if (image.length === 0) {
    throw new Error("Image not found");
  }
  const property = await getPropertyById(image[0].propertyId);
  if (!property || property.ownerId !== userId) {
    throw new Error("Unauthorized: You can only delete images from your own properties");
  }
  await db3.delete(propertyImages).where(eq3(propertyImages.id, imageId));
}
async function searchProperties(params) {
  const db3 = await getDb();
  if (!db3) return [];
  const conditions = [];
  if (params.city) conditions.push(like(properties.city, `%${params.city}%`));
  if (params.province) conditions.push(like(properties.province, `%${params.province}%`));
  if (params.propertyType) conditions.push(eq3(properties.propertyType, params.propertyType));
  if (params.listingType) conditions.push(eq3(properties.listingType, params.listingType));
  if (params.minPrice) conditions.push(gte(properties.price, params.minPrice));
  if (params.maxPrice) conditions.push(lte(properties.price, params.maxPrice));
  if (params.minBedrooms) conditions.push(gte(properties.bedrooms, params.minBedrooms));
  if (params.maxBedrooms) conditions.push(lte(properties.bedrooms, params.maxBedrooms));
  if (params.minArea) conditions.push(gte(properties.area, params.minArea));
  if (params.maxArea) conditions.push(lte(properties.area, params.maxArea));
  if (params.status) conditions.push(eq3(properties.status, params.status));
  if (params.minLat && params.maxLat && params.minLng && params.maxLng) {
    conditions.push(
      and3(
        gte(sql4`CAST(${properties.latitude} AS DECIMAL)`, params.minLat),
        lte(sql4`CAST(${properties.latitude} AS DECIMAL)`, params.maxLat),
        gte(sql4`CAST(${properties.longitude} AS DECIMAL)`, params.minLng),
        lte(sql4`CAST(${properties.longitude} AS DECIMAL)`, params.maxLng)
      )
    );
  }
  if (params.amenities && params.amenities.length > 0) {
    for (const amenity of params.amenities) {
      conditions.push(like(properties.amenities, `%${amenity}%`));
    }
  }
  if (params.postedBy && params.postedBy.length > 0) {
    const roleConditions = [];
    if (params.postedBy.includes("Owner")) {
      roleConditions.push(eq3(users.role, "visitor"));
    }
    if (params.postedBy.includes("Dealer") || params.postedBy.includes("Agent")) {
      roleConditions.push(or(eq3(users.role, "agent"), eq3(users.role, "agency_admin")));
    }
    if (params.postedBy.includes("Builder") || params.postedBy.includes("Developer")) {
      roleConditions.push(eq3(users.role, "property_developer"));
    }
    if (roleConditions.length > 0) {
      conditions.push(
        inArray(
          properties.ownerId,
          db3.select({ id: users.id }).from(users).where(or(...roleConditions))
        )
      );
    }
  }
  if (params.minLat !== void 0 && params.maxLat !== void 0) {
    conditions.push(
      sql4`CAST(${properties.latitude} AS DECIMAL(10, 6)) >= ${params.minLat} AND CAST(${properties.latitude} AS DECIMAL(10, 6)) <= ${params.maxLat}`
    );
  }
  if (params.minLng !== void 0 && params.maxLng !== void 0) {
    conditions.push(
      sql4`CAST(${properties.longitude} AS DECIMAL(10, 6)) >= ${params.minLng} AND CAST(${properties.longitude} AS DECIMAL(10, 6)) <= ${params.maxLng}`
    );
  }
  let query = db3.select().from(properties);
  if (conditions.length > 0) {
    query = query.where(and3(...conditions));
  }
  query = query.orderBy(desc(properties.createdAt));
  if (params.limit) {
    query = query.limit(params.limit);
  }
  if (params.offset) {
    query = query.offset(params.offset);
  }
  const results = await query;
  try {
    const { getBoostedListingsForChannel: getBoostedListingsForChannel2 } = await Promise.resolve().then(() => (init_campaignBoost(), campaignBoost_exports));
    const boostedIds = await getBoostedListingsForChannel2("search", 3);
    if (boostedIds.length > 0) {
      const boostedProperties = await db3.select().from(properties).where(inArray(properties.id, boostedIds));
      const filteredResults = results.filter(
        (prop) => !boostedIds.includes(prop.id)
      );
      return [...boostedProperties, ...filteredResults].slice(0, params.limit || 20);
    }
  } catch (error) {
    console.error("Error applying campaign boost:", error);
  }
  return results;
}
async function getFeaturedProperties(limit = 6) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(properties).where(and3(eq3(properties.featured, 1), eq3(properties.status, "available"))).orderBy(desc(properties.createdAt)).limit(limit);
}
async function incrementPropertyViews(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(properties).set({ views: sql4`${properties.views} + 1` }).where(eq3(properties.id, id));
}
async function addFavorite(userId, propertyId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.insert(favorites).values({ userId, propertyId });
}
async function removeFavorite(userId, propertyId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.delete(favorites).where(and3(eq3(favorites.userId, userId), eq3(favorites.propertyId, propertyId)));
}
async function getUserFavorites(userId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select({
    id: favorites.id,
    propertyId: favorites.propertyId,
    property: properties,
    createdAt: favorites.createdAt
  }).from(favorites).innerJoin(properties, eq3(favorites.propertyId, properties.id)).where(eq3(favorites.userId, userId)).orderBy(desc(favorites.createdAt));
}
async function isFavorite(userId, propertyId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.select().from(favorites).where(and3(eq3(favorites.userId, userId), eq3(favorites.propertyId, propertyId))).limit(1);
  return result.length > 0;
}
async function getAllAgents() {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from((init_schema(), __toCommonJS(schema_exports)).agents);
}
async function getAgentById(id) {
  const db3 = await getDb();
  if (!db3) return void 0;
  const result = await db3.select().from((init_schema(), __toCommonJS(schema_exports)).agents).where(eq3((init_schema(), __toCommonJS(schema_exports)).agents.id, id)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getFeaturedAgents(limit = 6) {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from((init_schema(), __toCommonJS(schema_exports)).agents).where(eq3((init_schema(), __toCommonJS(schema_exports)).agents.isFeatured, 1)).limit(limit);
}
async function getAllDevelopments() {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from((init_schema(), __toCommonJS(schema_exports)).developments);
}
async function getDevelopmentById(id) {
  const db3 = await getDb();
  if (!db3) return void 0;
  const result = await db3.select().from((init_schema(), __toCommonJS(schema_exports)).developments).where(eq3((init_schema(), __toCommonJS(schema_exports)).developments.id, id)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getFeaturedDevelopments(limit = 6) {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from((init_schema(), __toCommonJS(schema_exports)).developments).where(eq3((init_schema(), __toCommonJS(schema_exports)).developments.isFeatured, 1)).limit(limit);
}
async function getDevelopmentProperties(developmentId) {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from(properties).where(eq3(properties.developmentId, developmentId));
}
async function searchDevelopers(query, limit = 10) {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select({
    id: developers.id,
    name: developers.name,
    city: developers.city,
    province: developers.province,
    status: developers.status,
    logo: developers.logo
  }).from(developers).where(
    and3(
      sql4`LOWER(${developers.name}) LIKE ${`%${query.toLowerCase()}%`}`,
      eq3(developers.status, "approved")
      // Only show approved developers
    )
  ).limit(limit);
}
async function searchDevelopments(query, developerId, limit = 10) {
  const db3 = await getDb();
  if (!db3) return [];
  const conditions = [
    sql4`LOWER(${developments.name}) LIKE ${`%${query.toLowerCase()}%`}`,
    eq3(developments.isPublished, 1)
    // Only show published developments
  ];
  if (developerId) {
    conditions.push(eq3(developments.developerId, developerId));
  }
  return await db3.select({
    id: developments.id,
    name: developments.name,
    city: developments.city,
    province: developments.province,
    developerId: developments.developerId,
    developmentType: developments.developmentType,
    status: developments.status
  }).from(developments).where(and3(...conditions)).limit(limit);
}
async function getAllServices() {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from((init_schema(), __toCommonJS(schema_exports)).services);
}
async function getServicesByCategory(category) {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from((init_schema(), __toCommonJS(schema_exports)).services).where(eq3((init_schema(), __toCommonJS(schema_exports)).services.category, category));
}
async function getReviewsByTarget(reviewType, targetId) {
  const db3 = await getDb();
  if (!db3) return [];
  const { reviews: reviews2 } = (init_schema(), __toCommonJS(schema_exports));
  return await db3.select().from(reviews2).where(
    and3(
      eq3(reviews2.reviewType, reviewType),
      eq3(reviews2.targetId, targetId),
      eq3(reviews2.isPublished, 1)
    )
  );
}
async function createReview(reviewData) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const { reviews: reviews2 } = (init_schema(), __toCommonJS(schema_exports));
  const result = await db3.insert(reviews2).values(reviewData);
  return result[0].insertId;
}
async function createLead(leadData) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const { leads: leads3 } = (init_schema(), __toCommonJS(schema_exports));
  const result = await db3.insert(leads3).values(leadData);
  return result[0].insertId;
}
async function getLeadsByAgent(agentId) {
  const db3 = await getDb();
  if (!db3) return [];
  const { leads: leads3 } = (init_schema(), __toCommonJS(schema_exports));
  return await db3.select().from(leads3).where(eq3(leads3.agentId, agentId));
}
async function getAllExploreVideos(limit = 20) {
  const db3 = await getDb();
  if (!db3) return [];
  const { exploreVideos: exploreVideos2 } = (init_schema(), __toCommonJS(schema_exports));
  return await db3.select().from(exploreVideos2).where(eq3(exploreVideos2.isPublished, 1)).limit(limit);
}
async function getExploreVideoById(id) {
  const db3 = await getDb();
  if (!db3) return void 0;
  const { exploreVideos: exploreVideos2 } = (init_schema(), __toCommonJS(schema_exports));
  const result = await db3.select().from(exploreVideos2).where(eq3(exploreVideos2.id, id)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function incrementVideoViews(id) {
  const db3 = await getDb();
  if (!db3) return;
  const { exploreVideos: exploreVideos2 } = (init_schema(), __toCommonJS(schema_exports));
  await db3.update(exploreVideos2).set({ views: __require("drizzle-orm").sql`views + 1` }).where(eq3(exploreVideos2.id, id));
}
async function getAllLocations() {
  const db3 = await getDb();
  if (!db3) return [];
  const { locations: locations3 } = (init_schema(), __toCommonJS(schema_exports));
  return await db3.select().from(locations3);
}
async function getLocationsByType(type) {
  const db3 = await getDb();
  if (!db3) return [];
  const { locations: locations3 } = (init_schema(), __toCommonJS(schema_exports));
  return await db3.select().from(locations3).where(eq3(locations3.locationType, type));
}
async function getAgencyDashboardStats(agencyId) {
  const db3 = await getDb();
  if (!db3) {
    return {
      totalListings: 0,
      totalSales: 0,
      totalLeads: 0,
      totalAgents: 0,
      activeListings: 0,
      pendingListings: 0,
      recentLeads: 0,
      recentSales: 0
    };
  }
  const { properties: properties4, leads: leads3, users: users6, agents: agents2 } = (init_schema(), __toCommonJS(schema_exports));
  const agencyProperties = await db3.select().from(properties4).where(
    sql4`EXISTS (SELECT 1 FROM agents WHERE agents.id = properties.agentId AND agents.agencyId = ${agencyId})`
  );
  const agencyLeads = await db3.select().from(leads3).where(eq3(leads3.agencyId, agencyId));
  const agencyAgents = await db3.select().from(users6).where(and3(eq3(users6.agencyId, agencyId), eq3(users6.isSubaccount, 1)));
  const totalListings = agencyProperties.length;
  const activeListings = agencyProperties.filter((p) => p.status === "available").length;
  const pendingListings = agencyProperties.filter((p) => p.status === "pending").length;
  const totalSales = agencyProperties.filter((p) => p.status === "sold").length;
  const totalLeads = agencyLeads.length;
  const totalAgents = agencyAgents.length;
  const thirtyDaysAgo = /* @__PURE__ */ new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const recentLeads = agencyLeads.filter(
    (lead) => new Date(lead.createdAt) > thirtyDaysAgo
  ).length;
  const recentSales = agencyProperties.filter(
    (p) => p.status === "sold" && new Date(p.updatedAt) > thirtyDaysAgo
  ).length;
  return {
    totalListings,
    totalSales,
    totalLeads,
    totalAgents,
    activeListings,
    pendingListings,
    recentLeads,
    recentSales
  };
}
async function createProspect(prospectData) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.insert(prospects).values(prospectData);
  return result[0].insertId;
}
async function updateProspect(sessionId, updates) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(prospects).set({
    ...updates,
    lastActivity: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq3(prospects.sessionId, sessionId));
  return { success: true };
}
async function getProspect(sessionId) {
  const db3 = await getDb();
  if (!db3) return void 0;
  const result = await db3.select().from(prospects).where(eq3(prospects.sessionId, sessionId)).limit(1);
  return result[0];
}
async function addProspectFavorite(sessionId, propertyId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const prospect = await getProspect(sessionId);
  if (!prospect) throw new Error("Prospect not found");
  await db3.insert(prospectFavorites).values({ prospectId: prospect.id, propertyId });
  return { success: true };
}
async function removeProspectFavorite(sessionId, propertyId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const prospect = await getProspect(sessionId);
  if (!prospect) throw new Error("Prospect not found");
  await db3.delete(prospectFavorites).where(
    and3(
      eq3(prospectFavorites.prospectId, prospect.id),
      eq3(prospectFavorites.propertyId, propertyId)
    )
  );
  return { success: true };
}
async function getProspectFavorites(sessionId) {
  const db3 = await getDb();
  if (!db3) return [];
  try {
    const prospect = await getProspect(sessionId);
    if (!prospect) {
      console.log("[getProspectFavorites] No prospect found for sessionId:", sessionId);
      return [];
    }
    const results = await db3.select({
      id: prospectFavorites.id,
      propertyId: prospectFavorites.propertyId,
      property: properties,
      createdAt: prospectFavorites.createdAt
    }).from(prospectFavorites).innerJoin(properties, eq3(prospectFavorites.propertyId, properties.id)).where(eq3(prospectFavorites.prospectId, prospect.id)).orderBy(desc(prospectFavorites.createdAt));
    return Array.isArray(results) ? results : [];
  } catch (error) {
    console.error("[getProspectFavorites] Database query failed:", error);
    return [];
  }
}
async function scheduleViewing(viewingData) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.insert(scheduledViewings).values(viewingData);
  return result[0].insertId;
}
async function getScheduledViewings(sessionId) {
  const db3 = await getDb();
  if (!db3) return [];
  try {
    const prospect = await getProspect(sessionId);
    if (!prospect) {
      console.log("[getScheduledViewings] No prospect found for sessionId:", sessionId);
      return [];
    }
    const results = await db3.select({
      id: scheduledViewings.id,
      propertyId: scheduledViewings.propertyId,
      property: properties,
      agentId: scheduledViewings.agentId,
      agent: agents,
      scheduledAt: scheduledViewings.scheduledAt,
      status: scheduledViewings.status,
      notes: scheduledViewings.notes,
      createdAt: scheduledViewings.createdAt
    }).from(scheduledViewings).innerJoin(properties, eq3(scheduledViewings.propertyId, properties.id)).leftJoin(agents, eq3(scheduledViewings.agentId, agents.id)).where(eq3(scheduledViewings.prospectId, prospect.id)).orderBy(scheduledViewings.scheduledAt);
    return Array.isArray(results) ? results : [];
  } catch (error) {
    console.error("[getScheduledViewings] Database query failed:", error);
    return [];
  }
}
async function updateViewingStatus(viewingId, status) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(scheduledViewings).set({
    status,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq3(scheduledViewings.id, viewingId));
  return { success: true };
}
async function trackPropertyView(sessionId, propertyId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const prospect = await getProspect(sessionId);
  if (!prospect) throw new Error("Prospect not found");
  const existing = await db3.select().from(recentlyViewed).where(
    and3(eq3(recentlyViewed.prospectId, prospect.id), eq3(recentlyViewed.propertyId, propertyId))
  ).limit(1);
  if (existing.length > 0) {
    await db3.update(recentlyViewed).set({
      viewedAt: /* @__PURE__ */ new Date()
    }).where(
      and3(eq3(recentlyViewed.prospectId, prospect.id), eq3(recentlyViewed.propertyId, propertyId))
    );
  } else {
    await db3.insert(recentlyViewed).values({
      prospectId: prospect.id,
      propertyId,
      viewedAt: /* @__PURE__ */ new Date()
    });
  }
  return { success: true };
}
async function getRecentlyViewed(sessionId) {
  const db3 = await getDb();
  if (!db3) return [];
  try {
    const prospect = await getProspect(sessionId);
    if (!prospect) {
      console.log("[getRecentlyViewed] No prospect found for sessionId:", sessionId);
      return [];
    }
    const results = await db3.select({
      id: recentlyViewed.id,
      propertyId: recentlyViewed.propertyId,
      property: properties,
      viewedAt: recentlyViewed.viewedAt
    }).from(recentlyViewed).innerJoin(properties, eq3(recentlyViewed.propertyId, properties.id)).where(eq3(recentlyViewed.prospectId, prospect.id)).orderBy(desc(recentlyViewed.viewedAt)).limit(10);
    return Array.isArray(results) ? results : [];
  } catch (error) {
    console.error("[getRecentlyViewed] Database query failed:", error);
    return [];
  }
}
async function updateProspectProgress(sessionId, progress, badges) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const updateData = {
    profileProgress: progress,
    lastActivity: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  if (badges) {
    updateData.badges = JSON.stringify(badges);
  }
  await db3.update(prospects).set(updateData).where(eq3(prospects.sessionId, sessionId));
  return { success: true };
}
async function earnBadge(sessionId, badge) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const prospect = await getProspect(sessionId);
  if (!prospect) throw new Error("Prospect not found");
  const currentBadges = prospect.badges ? JSON.parse(prospect.badges) : [];
  if (!currentBadges.includes(badge)) {
    currentBadges.push(badge);
    await db3.update(prospects).set({
      badges: JSON.stringify(currentBadges),
      lastActivity: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq3(prospects.sessionId, sessionId));
  }
  return { success: true, badges: currentBadges };
}
async function getRecommendedProperties(prospect, limit = 10) {
  const db3 = await getDb();
  if (!db3) return [];
  if (!prospect.affordabilityMax) return [];
  let conditions = [
    eq3(properties.status, "available"),
    lte(properties.price, prospect.affordabilityMax)
  ];
  if (prospect.affordabilityMin) {
    conditions.push(gte(properties.price, prospect.affordabilityMin));
  }
  if (prospect.preferredPropertyType) {
    conditions.push(eq3(properties.propertyType, prospect.preferredPropertyType));
  }
  if (prospect.preferredLocation) {
    conditions.push(like(properties.city, `%${prospect.preferredLocation}%`));
  }
  let query = db3.select().from(properties).where(and3(...conditions));
  query = query.orderBy(desc(properties.featured), desc(properties.createdAt)).limit(limit);
  return await query;
}
async function getAgencyPerformanceData(agencyId, months = 6) {
  const db3 = await getDb();
  if (!db3) return [];
  const { properties: properties4, leads: leads3 } = (init_schema(), __toCommonJS(schema_exports));
  const currentDate = /* @__PURE__ */ new Date();
  const performanceData = [];
  for (let i = months - 1; i >= 0; i--) {
    const monthStart = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
    const monthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() - i + 1, 0);
    const monthProperties = await db3.select().from(properties4).where(
      and3(
        sql4`EXISTS (SELECT 1 FROM agents WHERE agents.id = properties.agentId AND agents.agencyId = ${agencyId})`,
        sql4`${properties4.createdAt} >= ${monthStart}`,
        sql4`${properties4.createdAt} <= ${monthEnd}`
      )
    );
    const monthLeads = await db3.select().from(leads3).where(
      and3(
        eq3(leads3.agencyId, agencyId),
        sql4`${leads3.createdAt} >= ${monthStart}`,
        sql4`${leads3.createdAt} <= ${monthEnd}`
      )
    );
    const monthSales = monthProperties.filter((p) => p.status === "sold").length;
    performanceData.push({
      month: monthStart.toLocaleString("default", { month: "short", year: "2-digit" }),
      listings: monthProperties.length,
      leads: monthLeads.length,
      sales: monthSales
    });
  }
  return performanceData;
}
async function getAgencyRecentLeads(agencyId, limit = 5) {
  const db3 = await getDb();
  if (!db3) return [];
  const { leads: leads3 } = (init_schema(), __toCommonJS(schema_exports));
  return await db3.select().from(leads3).where(eq3(leads3.agencyId, agencyId)).orderBy(desc(leads3.createdAt)).limit(limit);
}
async function getAgencyRecentListings(agencyId, limit = 5) {
  const db3 = await getDb();
  if (!db3) return [];
  const { properties: properties4 } = (init_schema(), __toCommonJS(schema_exports));
  return await db3.select({
    id: properties4.id,
    title: properties4.title,
    price: properties4.price,
    status: properties4.status,
    city: properties4.city,
    createdAt: properties4.createdAt,
    ownerId: properties4.ownerId
  }).from(properties4).where(
    sql4`EXISTS (SELECT 1 FROM agents WHERE agents.id = properties.agentId AND agents.agencyId = ${agencyId})`
  ).orderBy(desc(properties4.createdAt)).limit(limit);
}
async function getAgencyAgents(agencyId) {
  const db3 = await getDb();
  if (!db3) return [];
  const { users: users6, agents: agents2 } = (init_schema(), __toCommonJS(schema_exports));
  const agencyUsers = await db3.select({
    id: users6.id,
    name: users6.name,
    firstName: users6.firstName,
    lastName: users6.lastName,
    email: users6.email,
    role: users6.role,
    createdAt: users6.createdAt,
    isSubaccount: users6.isSubaccount,
    agentProfile: agents2
  }).from(users6).leftJoin(agents2, eq3(users6.id, agents2.userId)).where(and3(eq3(users6.agencyId, agencyId), eq3(users6.isSubaccount, 1))).orderBy(desc(users6.createdAt));
  return agencyUsers;
}
async function getLeadConversionStats(agencyId, months = 6) {
  const db3 = await getDb();
  if (!db3) return { total: 0, converted: 0, conversionRate: 0, byStatus: [] };
  const { leads: leads3 } = (init_schema(), __toCommonJS(schema_exports));
  const startDate = /* @__PURE__ */ new Date();
  startDate.setMonth(startDate.getMonth() - months);
  const totalLeads = await db3.select({ count: sql4`count(*)` }).from(leads3).where(and3(eq3(leads3.agencyId, agencyId), sql4`${leads3.createdAt} >= ${startDate}`));
  const convertedLeads = await db3.select({ count: sql4`count(*)` }).from(leads3).where(
    and3(
      eq3(leads3.agencyId, agencyId),
      sql4`${leads3.createdAt} >= ${startDate}`,
      or(eq3(leads3.status, "converted"), eq3(leads3.status, "closed"))
    )
  );
  const statusStats = await db3.select({
    status: leads3.status,
    count: sql4`count(*)`
  }).from(leads3).where(and3(eq3(leads3.agencyId, agencyId), sql4`${leads3.createdAt} >= ${startDate}`)).groupBy(leads3.status);
  const total = Number(totalLeads[0]?.count || 0);
  const converted = Number(convertedLeads[0]?.count || 0);
  const conversionRate = total > 0 ? converted / total * 100 : 0;
  return {
    total,
    converted,
    conversionRate: Math.round(conversionRate * 100) / 100,
    // Round to 2 decimal places
    byStatus: statusStats.map((s) => ({
      status: s.status,
      count: Number(s.count),
      percentage: total > 0 ? Math.round(Number(s.count) / total * 100) : 0
    }))
  };
}
async function getAgencyCommissionStats(agencyId, months = 6) {
  const db3 = await getDb();
  if (!db3)
    return { totalEarnings: 0, paidCommissions: 0, pendingCommissions: 0, monthlyBreakdown: [] };
  const { commissions: commissions2, agents: agents2 } = (init_schema(), __toCommonJS(schema_exports));
  const startDate = /* @__PURE__ */ new Date();
  startDate.setMonth(startDate.getMonth() - months);
  const totalEarnings = await db3.select({ total: sql4`sum(${commissions2.amount})` }).from(commissions2).innerJoin(agents2, eq3(commissions2.agentId, agents2.id)).where(and3(eq3(agents2.agencyId, agencyId), sql4`${commissions2.createdAt} >= ${startDate}`));
  const paidCommissions = await db3.select({ total: sql4`sum(${commissions2.amount})` }).from(commissions2).innerJoin(agents2, eq3(commissions2.agentId, agents2.id)).where(
    and3(
      eq3(agents2.agencyId, agencyId),
      eq3(commissions2.status, "paid"),
      sql4`${commissions2.createdAt} >= ${startDate}`
    )
  );
  const pendingCommissions = await db3.select({ total: sql4`sum(${commissions2.amount})` }).from(commissions2).innerJoin(agents2, eq3(commissions2.agentId, agents2.id)).where(
    and3(
      eq3(agents2.agencyId, agencyId),
      eq3(commissions2.status, "pending"),
      sql4`${commissions2.createdAt} >= ${startDate}`
    )
  );
  const monthlyBreakdown = [];
  for (let i = months - 1; i >= 0; i--) {
    const monthStart = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
    const monthEnd = new Date(startDate.getFullYear(), startDate.getMonth() + i + 1, 0);
    const monthEarnings = await db3.select({ total: sql4`sum(${commissions2.amount})` }).from(commissions2).innerJoin(agents2, eq3(commissions2.agentId, agents2.id)).where(
      and3(
        eq3(agents2.agencyId, agencyId),
        sql4`${commissions2.createdAt} >= ${monthStart}`,
        sql4`${commissions2.createdAt} <= ${monthEnd}`
      )
    );
    monthlyBreakdown.push({
      month: monthStart.toLocaleString("default", { month: "short", year: "2-digit" }),
      earnings: Number(monthEarnings[0]?.total || 0) / 100
      // Convert cents to currency
    });
  }
  return {
    totalEarnings: Number(totalEarnings[0]?.total || 0) / 100,
    paidCommissions: Number(paidCommissions[0]?.total || 0) / 100,
    pendingCommissions: Number(pendingCommissions[0]?.total || 0) / 100,
    monthlyBreakdown
  };
}
async function getAgentPerformanceLeaderboard(agencyId, months = 3) {
  const db3 = await getDb();
  if (!db3) return [];
  const { commissions: commissions2, agents: agents2, leads: leads3, properties: properties4 } = (init_schema(), __toCommonJS(schema_exports));
  const startDate = /* @__PURE__ */ new Date();
  startDate.setMonth(startDate.getMonth() - months);
  const agencyAgents = await db3.select({
    id: agents2.id,
    userId: agents2.userId,
    firstName: agents2.firstName,
    lastName: agents2.lastName,
    displayName: agents2.displayName
  }).from(agents2).where(eq3(agents2.agencyId, agencyId));
  const leaderboard = await Promise.all(
    agencyAgents.map(async (agent) => {
      const earnings = await db3.select({ total: sql4`sum(${commissions2.amount})` }).from(commissions2).where(
        and3(eq3(commissions2.agentId, agent.id), sql4`${commissions2.createdAt} >= ${startDate}`)
      );
      const propertiesListed = await db3.select({ count: sql4`count(*)` }).from(properties4).where(and3(eq3(properties4.agentId, agent.id), sql4`${properties4.createdAt} >= ${startDate}`));
      const leadsGenerated = await db3.select({ count: sql4`count(*)` }).from(leads3).where(and3(eq3(leads3.agentId, agent.id), sql4`${leads3.createdAt} >= ${startDate}`));
      const propertiesSold = await db3.select({ count: sql4`count(*)` }).from(properties4).where(
        and3(
          eq3(properties4.agentId, agent.id),
          eq3(properties4.status, "sold"),
          sql4`${properties4.updatedAt} >= ${startDate}`
        )
      );
      return {
        agentId: agent.id,
        agentName: agent.displayName || `${agent.firstName} ${agent.lastName}`,
        earnings: Number(earnings[0]?.total || 0) / 100,
        propertiesListed: Number(propertiesListed[0]?.count || 0),
        leadsGenerated: Number(leadsGenerated[0]?.count || 0),
        propertiesSold: Number(propertiesSold[0]?.count || 0),
        conversionRate: Number(leadsGenerated[0]?.count || 0) > 0 ? Math.round(
          Number(propertiesSold[0]?.count || 0) / Number(leadsGenerated[0]?.count || 0) * 100
        ) : 0
      };
    })
  );
  return leaderboard.sort((a, b) => {
    if (b.earnings !== a.earnings) return b.earnings - a.earnings;
    return b.propertiesSold - a.propertiesSold;
  });
}
async function getPlatformSetting(key) {
  const db3 = await getDb();
  if (!db3) return null;
  const result = await db3.select().from(platformSettings).where(eq3(platformSettings.key, key)).limit(1);
  return result.length > 0 ? result[0] : null;
}
async function setPlatformSetting(key, value, updatedBy) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const settingData = {
    key,
    value: JSON.stringify(value),
    updatedBy,
    updatedAt: /* @__PURE__ */ new Date()
  };
  await db3.insert(platformSettings).values(settingData).onDuplicateKeyUpdate({
    set: settingData
  });
}
async function getAllPlatformSettings() {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from(platformSettings).orderBy(platformSettings.category, platformSettings.key);
}
async function getPlatformAnalytics() {
  const db3 = await getDb();
  if (!db3) {
    return {
      totalUsers: 0,
      totalAgencies: 0,
      totalProperties: 0,
      activeProperties: 0,
      totalAgents: 0,
      paidSubscriptions: 0,
      monthlyRevenue: 0,
      userGrowth: 0,
      propertyGrowth: 0
    };
  }
  const [counts] = await db3.execute(sql4`
    SELECT
      (SELECT COUNT(*) FROM ${users}) as userCount,
      (SELECT COUNT(*) FROM ${agencies}) as agencyCount,
      (SELECT COUNT(*) FROM ${listings}) as propertyCount,
      (SELECT COUNT(*) FROM ${listings} WHERE ${listings.status} IN ('pending_review', 'approved', 'published')) as activePropertyCount,
      (SELECT COUNT(*) FROM ${agents}) as agentCount,
      (SELECT COUNT(*) FROM ${agencies} WHERE ${agencies.subscriptionPlan} != 'free') as paidSubsCount,
      (SELECT COUNT(*) FROM ${developers}) as developerCount
  `);
  const thirtyDaysAgo = /* @__PURE__ */ new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const [growth] = await db3.execute(sql4`
    SELECT
      (SELECT SUM(${commissions.amount}) FROM ${commissions} WHERE ${commissions.createdAt} >= ${thirtyDaysAgo}) as monthlyRevenue,
      (SELECT COUNT(*) FROM ${users} WHERE ${users.createdAt} >= ${thirtyDaysAgo}) as userGrowth,
      (SELECT COUNT(*) FROM ${listings} WHERE ${listings.createdAt} >= ${thirtyDaysAgo}) as propertyGrowth
  `);
  const countsRow = counts[0];
  const growthRow = growth[0];
  return {
    totalUsers: Number(countsRow.userCount || 0),
    totalAgencies: Number(countsRow.agencyCount || 0),
    totalProperties: Number(countsRow.propertyCount || 0),
    activeProperties: Number(countsRow.activePropertyCount || 0),
    totalAgents: Number(countsRow.agentCount || 0),
    totalDevelopers: Number(countsRow.developerCount || 0),
    paidSubscriptions: Number(countsRow.paidSubsCount || 0),
    monthlyRevenue: Number(growthRow.monthlyRevenue || 0) / 100,
    // Convert cents to currency units
    userGrowth: Number(growthRow.userGrowth || 0),
    propertyGrowth: Number(growthRow.propertyGrowth || 0)
  };
}
async function getListingStats() {
  const db3 = await getDb();
  if (!db3) return { pending: 0, approved: 0, rejected: 0, total: 0 };
  const { properties: properties4 } = (init_schema(), __toCommonJS(schema_exports));
  const [pending] = await db3.select({ count: sql4`count(*)` }).from(properties4).where(eq3(properties4.status, "pending"));
  const [approved] = await db3.select({ count: sql4`count(*)` }).from(properties4).where(eq3(properties4.status, "available"));
  const [rejected] = await db3.select({ count: sql4`count(*)` }).from(properties4).where(eq3(properties4.status, "archived"));
  const [total] = await db3.select({ count: sql4`count(*)` }).from(properties4);
  return {
    pending: Number(pending?.count || 0),
    approved: Number(approved?.count || 0),
    rejected: Number(rejected?.count || 0),
    total: Number(total?.count || 0)
  };
}
async function getSubscriptionStats() {
  const db3 = await getDb();
  if (!db3) return { free: 0, basic: 0, premium: 0, enterprise: 0, total: 0 };
  const { agencies: agencies3 } = (init_schema(), __toCommonJS(schema_exports));
  const [free] = await db3.select({ count: sql4`count(*)` }).from(agencies3).where(eq3(agencies3.subscriptionPlan, "free"));
  const [basic] = await db3.select({ count: sql4`count(*)` }).from(agencies3).where(eq3(agencies3.subscriptionPlan, "basic"));
  const [premium] = await db3.select({ count: sql4`count(*)` }).from(agencies3).where(eq3(agencies3.subscriptionPlan, "premium"));
  const [enterprise] = await db3.select({ count: sql4`count(*)` }).from(agencies3).where(eq3(agencies3.subscriptionPlan, "enterprise"));
  const [total] = await db3.select({ count: sql4`count(*)` }).from(agencies3);
  return {
    free: Number(free?.count || 0),
    basic: Number(basic?.count || 0),
    premium: Number(premium?.count || 0),
    enterprise: Number(enterprise?.count || 0),
    total: Number(total?.count || 0)
  };
}
async function createListing(listingData) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  try {
    const listingId = await db3.transaction(async (tx) => {
      const { agents: agents2 } = (init_schema(), __toCommonJS(schema_exports));
      const [agent] = await tx.select().from(agents2).where(eq3(agents2.userId, listingData.userId)).limit(1);
      const agentId = agent ? agent.id : null;
      console.log("[db.createListing] Inserting listing:", {
        ownerId: listingData.userId,
        agentId,
        slug: listingData.slug,
        coords: { lat: listingData.latitude, lng: listingData.longitude }
      });
      const insertValues = {
        ownerId: listingData.userId,
        agentId,
        action: listingData.action,
        propertyType: listingData.propertyType,
        title: listingData.title,
        description: listingData.description,
        // Map pricing fields
        askingPrice: listingData.pricing.askingPrice ? String(listingData.pricing.askingPrice) : null,
        negotiable: listingData.pricing.negotiable ? 1 : 0,
        transferCostEstimate: listingData.pricing.transferCostEstimate ? String(listingData.pricing.transferCostEstimate) : null,
        monthlyRent: listingData.pricing.monthlyRent ? String(listingData.pricing.monthlyRent) : null,
        deposit: listingData.pricing.deposit ? String(listingData.pricing.deposit) : null,
        leaseTerms: listingData.pricing.leaseTerms || null,
        availableFrom: listingData.pricing.availableFrom ? new Date(listingData.pricing.availableFrom).toISOString().slice(0, 19).replace("T", " ") : null,
        utilitiesIncluded: listingData.pricing.utilitiesIncluded ? 1 : 0,
        startingBid: listingData.pricing.startingBid ? String(listingData.pricing.startingBid) : null,
        reservePrice: listingData.pricing.reservePrice ? String(listingData.pricing.reservePrice) : null,
        auctionDateTime: listingData.pricing.auctionDateTime ? new Date(listingData.pricing.auctionDateTime).toISOString().slice(0, 19).replace("T", " ") : null,
        auctionTermsDocumentUrl: listingData.pricing.auctionTermsDocumentUrl || null,
        propertyDetails: listingData.propertyDetails,
        // Drizzle handles JSON
        address: listingData.address,
        latitude: Number(listingData.latitude).toFixed(7),
        longitude: Number(listingData.longitude).toFixed(7),
        city: listingData.city,
        province: listingData.province,
        // Failsafe: Ensure slug is unique
        slug: listingData.slug.match(/-ts-[a-z0-9]+$/) ? listingData.slug : `${listingData.slug}-ts-${Date.now().toString(36)}`,
        status: "draft",
        approvalStatus: "pending",
        createdAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
      };
      if (listingData.suburb) insertValues.suburb = listingData.suburb;
      if (listingData.postalCode) insertValues.postalCode = listingData.postalCode;
      if (listingData.placeId) insertValues.placeId = listingData.placeId;
      if (listingData.locationId) insertValues.locationId = listingData.locationId;
      const [listingResult] = await tx.insert(listings).values(insertValues);
      const newListingId = Number(listingResult.insertId);
      await tx.insert(listingAnalytics).values({
        listingId: newListingId,
        totalViews: 0,
        uniqueVisitors: 0,
        totalLeads: 0,
        contactFormLeads: 0,
        whatsappClicks: 0,
        phoneReveals: 0,
        bookingViewingRequests: 0,
        totalFavorites: 0,
        totalShares: 0,
        conversionRate: "0",
        viewsByDay: {},
        trafficSources: {},
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
      });
      if (listingData.media && listingData.media.length > 0) {
        for (const mediaItem of listingData.media) {
          await tx.insert(listingMedia).values({
            listingId: newListingId,
            originalUrl: mediaItem.url,
            thumbnailUrl: mediaItem.thumbnailUrl,
            mediaType: mediaItem.type,
            originalFileName: mediaItem.fileName,
            originalFileSize: mediaItem.fileSize,
            width: mediaItem.width,
            height: mediaItem.height,
            duration: mediaItem.duration,
            orientation: mediaItem.orientation,
            displayOrder: mediaItem.displayOrder,
            isPrimary: mediaItem.isPrimary ? 1 : 0,
            processingStatus: mediaItem.processingStatus,
            createdAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
            uploadedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
          });
        }
      }
      return newListingId;
    });
    return listingId;
  } catch (error) {
    console.error("[Database] Failed to create listing:", error);
    console.error("[Database] Error details:", error.message);
    throw error;
  }
}
async function getListingById(listingId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [listing] = await db3.select().from(listings).where(eq3(listings.id, listingId)).limit(1);
  if (!listing) return null;
  if (!listing) return null;
  const pricing = {
    askingPrice: listing.askingPrice ? Number(listing.askingPrice) : void 0,
    negotiable: listing.negotiable === 1,
    transferCostEstimate: listing.transferCostEstimate ? Number(listing.transferCostEstimate) : void 0,
    monthlyRent: listing.monthlyRent ? Number(listing.monthlyRent) : void 0,
    deposit: listing.deposit ? Number(listing.deposit) : void 0,
    leaseTerms: listing.leaseTerms,
    availableFrom: listing.availableFrom ? new Date(listing.availableFrom) : void 0,
    utilitiesIncluded: listing.utilitiesIncluded === 1,
    startingBid: listing.startingBid ? Number(listing.startingBid) : void 0,
    reservePrice: listing.reservePrice ? Number(listing.reservePrice) : void 0,
    auctionDateTime: listing.auctionDateTime ? new Date(listing.auctionDateTime) : void 0,
    auctionTermsDocumentUrl: listing.auctionTermsDocumentUrl
  };
  const propertyDetails = listing.propertyDetails || {};
  return {
    ...listing,
    userId: listing.ownerId,
    // Map ownerId to userId for compatibility
    pricing,
    propertyDetails
  };
}
async function getUserListings(userId, status, limit = 20, offset = 0) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const { listingMedia: listingMedia2 } = (init_schema(), __toCommonJS(schema_exports));
  let query = db3.select().from(listings).where(eq3(listings.ownerId, userId));
  if (status) {
    query = query.where(eq3(listings.status, status));
  }
  const listingsData = await query.orderBy(desc(listings.createdAt)).limit(limit).offset(offset);
  const listingsWithImages = await Promise.all(
    listingsData.map(async (listing) => {
      const images = await db3.select().from(listingMedia2).where(eq3(listingMedia2.listingId, listing.id)).orderBy(listingMedia2.displayOrder).limit(1);
      const cdnUrl = ENV.cloudFrontUrl || `https://${ENV.s3BucketName}.s3.${ENV.awsRegion}.amazonaws.com`;
      const primaryImage = images.length > 0 ? images[0].originalUrl.startsWith("http") ? images[0].originalUrl : `${cdnUrl}/${images[0].originalUrl}` : null;
      const pricing = {
        askingPrice: listing.askingPrice ? Number(listing.askingPrice) : void 0,
        negotiable: listing.negotiable === 1,
        transferCostEstimate: listing.transferCostEstimate ? Number(listing.transferCostEstimate) : void 0,
        monthlyRent: listing.monthlyRent ? Number(listing.monthlyRent) : void 0,
        deposit: listing.deposit ? Number(listing.deposit) : void 0,
        leaseTerms: listing.leaseTerms,
        availableFrom: listing.availableFrom ? new Date(listing.availableFrom) : void 0,
        utilitiesIncluded: listing.utilitiesIncluded === 1,
        startingBid: listing.startingBid ? Number(listing.startingBid) : void 0,
        reservePrice: listing.reservePrice ? Number(listing.reservePrice) : void 0,
        auctionDateTime: listing.auctionDateTime ? new Date(listing.auctionDateTime) : void 0,
        auctionTermsDocumentUrl: listing.auctionTermsDocumentUrl
      };
      const propertyDetails = listing.propertyDetails || {};
      return {
        ...listing,
        userId: listing.ownerId,
        pricing,
        propertyDetails,
        primaryImage
      };
    })
  );
  return listingsWithImages;
}
async function updateListing(listingId, updateData) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const updateFields = {
    ...updateData,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  };
  if (updateData.pricing) {
    if (updateData.pricing.askingPrice !== void 0) updateFields.askingPrice = updateData.pricing.askingPrice ? String(updateData.pricing.askingPrice) : null;
    if (updateData.pricing.negotiable !== void 0) updateFields.negotiable = updateData.pricing.negotiable ? 1 : 0;
    if (updateData.pricing.transferCostEstimate !== void 0) updateFields.transferCostEstimate = updateData.pricing.transferCostEstimate ? String(updateData.pricing.transferCostEstimate) : null;
    if (updateData.pricing.monthlyRent !== void 0) updateFields.monthlyRent = updateData.pricing.monthlyRent ? String(updateData.pricing.monthlyRent) : null;
    if (updateData.pricing.deposit !== void 0) updateFields.deposit = updateData.pricing.deposit ? String(updateData.pricing.deposit) : null;
    if (updateData.pricing.leaseTerms !== void 0) updateFields.leaseTerms = updateData.pricing.leaseTerms;
    if (updateData.pricing.availableFrom !== void 0) updateFields.availableFrom = updateData.pricing.availableFrom ? new Date(updateData.pricing.availableFrom).toISOString().slice(0, 19).replace("T", " ") : null;
    if (updateData.pricing.utilitiesIncluded !== void 0) updateFields.utilitiesIncluded = updateData.pricing.utilitiesIncluded ? 1 : 0;
    if (updateData.pricing.startingBid !== void 0) updateFields.startingBid = updateData.pricing.startingBid ? String(updateData.pricing.startingBid) : null;
    if (updateData.pricing.reservePrice !== void 0) updateFields.reservePrice = updateData.pricing.reservePrice ? String(updateData.pricing.reservePrice) : null;
    if (updateData.pricing.auctionDateTime !== void 0) updateFields.auctionDateTime = updateData.pricing.auctionDateTime ? new Date(updateData.pricing.auctionDateTime).toISOString().slice(0, 19).replace("T", " ") : null;
    if (updateData.pricing.auctionTermsDocumentUrl !== void 0) updateFields.auctionTermsDocumentUrl = updateData.pricing.auctionTermsDocumentUrl;
    delete updateFields.pricing;
  }
  await db3.update(listings).set(updateFields).where(eq3(listings.id, listingId));
}
async function submitListingForReview(listingId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(listings).set({
    status: "pending_review",
    approvalStatus: "pending",
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  }).where(eq3(listings.id, listingId));
  const listing = await getListingById(listingId);
  if (!listing) throw new Error("Listing not found");
  await db3.insert(listingApprovalQueue).values({
    listingId,
    submittedBy: listing.ownerId,
    submittedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    status: "pending",
    priority: "normal"
  });
}
async function getListingAnalytics(listingId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [analytics] = await db3.select().from(listingAnalytics).where(eq3(listingAnalytics.listingId, listingId)).limit(1);
  if (!analytics) return null;
  return {
    ...analytics,
    viewsByDay: analytics.viewsByDay ? JSON.parse(analytics.viewsByDay) : {},
    trafficSources: analytics.trafficSources ? JSON.parse(analytics.trafficSources) : {}
  };
}
async function getListingMedia(listingId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(listingMedia).where(eq3(listingMedia.listingId, listingId)).orderBy(listingMedia.displayOrder);
}
async function getApprovalQueue(status) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  let query = db3.select({
    id: listingApprovalQueue.id,
    listingId: listingApprovalQueue.listingId,
    submittedBy: listingApprovalQueue.submittedBy,
    submittedAt: listingApprovalQueue.submittedAt,
    status: listingApprovalQueue.status,
    priority: listingApprovalQueue.priority,
    reviewedBy: listingApprovalQueue.reviewedBy,
    reviewedAt: listingApprovalQueue.reviewedAt,
    reviewNotes: listingApprovalQueue.reviewNotes,
    rejectionReason: listingApprovalQueue.rejectionReason,
    // Join with listings table to get listing details
    listingTitle: listings.title,
    listingPropertyType: listings.propertyType,
    listingAction: listings.action,
    listingStatus: listings.status
  }).from(listingApprovalQueue).leftJoin(listings, eq3(listingApprovalQueue.listingId, listings.id));
  if (status) {
    query = query.where(eq3(listingApprovalQueue.status, status));
  }
  return await query.orderBy(desc(listingApprovalQueue.submittedAt));
}
async function approveListing(listingId, reviewedBy, notes) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const listing = await getListingById(listingId);
  if (!listing) throw new Error("Listing not found");
  let pricingData = {};
  if (listing.pricing) {
    try {
      pricingData = typeof listing.pricing === "string" ? JSON.parse(listing.pricing) : listing.pricing;
    } catch (e) {
      console.error("Failed to parse pricing:", e);
    }
  }
  let price = 0;
  price = pricingData.askingPrice || pricingData.monthlyRent || pricingData.startingBid || 0;
  let details = {};
  if (listing.propertyDetails) {
    try {
      details = typeof listing.propertyDetails === "string" ? JSON.parse(listing.propertyDetails) : listing.propertyDetails;
    } catch (e) {
      console.error("Failed to parse propertyDetails:", e);
    }
  }
  const bedrooms = Number(details.bedrooms) || 0;
  const bathrooms = Number(details.bathrooms) || 0;
  const area = Number(details.unitSizeM2) || Number(details.houseAreaM2) || Number(details.floorAreaM2) || 0;
  const amenitiesList = [
    ...details.amenities || [],
    ...details.amenitiesFeatures || [],
    ...details.securityFeatures || [],
    ...details.outdoorFeatures || []
  ];
  const amenitiesString = amenitiesList.length > 0 ? amenitiesList.join(",") : null;
  const [propertyResult] = await db3.insert(properties).values({
    title: listing.title,
    description: listing.description,
    propertyType: listing.propertyType,
    listingType: listing.action === "sell" ? "sale" : listing.action === "rent" ? "rent" : "auction",
    // Map 'sell' to 'sale'
    transactionType: listing.action === "sell" ? "sale" : listing.action === "rent" ? "rent" : "auction",
    price,
    bedrooms,
    bathrooms,
    area,
    address: listing.address,
    city: listing.city,
    province: listing.province,
    zipCode: listing.postalCode,
    latitude: String(listing.latitude),
    longitude: String(listing.longitude),
    // IDs for relations (would need lookup logic for IDs, skipping for now or using defaults)
    locationText: `${listing.city}, ${listing.province}`,
    placeId: listing.placeId,
    amenities: amenitiesString,
    status: "available",
    // Make it live immediately
    featured: listing.featured || 0,
    views: 0,
    enquiries: 0,
    agentId: listing.agentId,
    ownerId: listing.ownerId,
    propertySettings: JSON.stringify(details),
    levies: Number(details.levies) || Number(details.leviesHoaOperatingCosts) || null,
    ratesAndTaxes: Number(details.ratesTaxes) || null,
    createdAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  });
  const newPropertyId = Number(propertyResult.insertId);
  const mediaItems = await getListingMedia(listingId);
  if (mediaItems && mediaItems.length > 0) {
    const mainMedia = mediaItems.find((m) => m.isPrimary && m.mediaType === "image") || mediaItems.find((m) => m.mediaType === "image");
    if (mainMedia) {
      await db3.update(properties).set({ mainImage: mainMedia.processedUrl || mainMedia.originalUrl }).where(eq3(properties.id, newPropertyId));
    }
    for (const item of mediaItems) {
      if (item.mediaType === "image") {
        await db3.insert(propertyImages).values({
          propertyId: newPropertyId,
          imageUrl: item.processedUrl || item.originalUrl,
          isPrimary: item.isPrimary ? 1 : 0,
          displayOrder: item.displayOrder,
          createdAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
        });
      }
    }
  }
  await db3.update(listings).set({
    status: "published",
    approvalStatus: "approved",
    publishedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  }).where(eq3(listings.id, listingId));
  await db3.update(listingApprovalQueue).set({
    status: "approved",
    reviewedBy,
    reviewedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    reviewNotes: notes
  }).where(eq3(listingApprovalQueue.listingId, listingId));
}
async function rejectListing(listingId, reviewedBy, reason, reasons, note) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(listings).set({
    status: "rejected",
    approvalStatus: "rejected",
    reviewedBy,
    reviewedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    rejectionReason: reason,
    // Legacy support
    rejectionReasons: reasons ? JSON.stringify(reasons) : null,
    rejectionNote: note
  }).where(eq3(listings.id, listingId));
  await db3.update(listingApprovalQueue).set({
    status: "rejected",
    reviewedBy,
    reviewedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    reviewNotes: note || reason,
    rejectionReason: reason
  }).where(and3(eq3(listingApprovalQueue.listingId, listingId), eq3(listingApprovalQueue.status, "pending")));
}
async function archiveProperty(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(properties).set({ status: "archived", updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ") }).where(eq3(properties.id, id));
}
async function deleteListing(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.delete(listingMedia).where(eq3(listingMedia.listingId, id));
  await db3.delete(listingApprovalQueue).where(eq3(listingApprovalQueue.listingId, id));
  await db3.delete(listingAnalytics).where(eq3(listingAnalytics.listingId, id));
  await db3.delete(listingLeads).where(eq3(listingLeads.listingId, id));
  await db3.delete(listingViewings).where(eq3(listingViewings.listingId, id));
  await db3.delete(listings).where(eq3(listings.id, id));
}
async function archiveListing(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(listings).set({ status: "archived", updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ") }).where(eq3(listings.id, id));
}
async function createAgentProfile(data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.insert(agents).values({
    userId: data.userId,
    displayName: data.displayName,
    phone: data.phone,
    bio: data.bio || null,
    profileImage: data.profilePhoto || null,
    licenseNumber: data.licenseNumber || null,
    specialization: data.specializations ? data.specializations.join(",") : null,
    firstName: data.displayName.split(" ")[0] || data.displayName,
    lastName: data.displayName.split(" ").slice(1).join(" ") || "",
    isVerified: 0,
    isFeatured: 0,
    status: "pending",
    // Pending until ID/FFC verification complete
    createdAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  });
  return Number(result[0].insertId);
}
async function getAgentByUserId(userId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [agent] = await db3.select().from(agents).where(eq3(agents.userId, userId)).limit(1);
  return agent || null;
}
function transformListingToProperty(listing, media = []) {
  const propertyDetails = listing.propertyDetails || {};
  return {
    id: listing.id,
    title: listing.title,
    description: listing.description,
    // Map price based on action type
    price: listing.askingPrice || listing.monthlyRent || listing.startingBid || 0,
    listingType: listing.action,
    // 'sell', 'rent', 'auction'
    propertyType: listing.propertyType,
    // Extract from propertyDetails JSON
    bedrooms: propertyDetails.bedrooms || 0,
    bathrooms: propertyDetails.bathrooms || 0,
    area: propertyDetails.unitSizeM2 || propertyDetails.houseAreaM2 || propertyDetails.floorAreaM2 || 0,
    yardSize: propertyDetails.erfSizeM2 || propertyDetails.landSizeM2OrHa || 0,
    amenities: [
      ...Array.isArray(propertyDetails.amenities) ? propertyDetails.amenities : [],
      ...Array.isArray(propertyDetails.amenitiesFeatures) ? propertyDetails.amenitiesFeatures : [],
      ...Array.isArray(propertyDetails.securityFeatures) ? propertyDetails.securityFeatures : [],
      ...Array.isArray(propertyDetails.kitchenFeatures) ? propertyDetails.kitchenFeatures : [],
      ...Array.isArray(propertyDetails.outdoorFeatures) ? propertyDetails.outdoorFeatures : [],
      ...Array.isArray(propertyDetails.energyFeatures) ? propertyDetails.energyFeatures : [],
      propertyDetails.waterHeating,
      propertyDetails.waterSupply
    ].filter(Boolean).flat(),
    features: [
      ...Array.isArray(propertyDetails.amenities) ? propertyDetails.amenities : [],
      ...Array.isArray(propertyDetails.amenitiesFeatures) ? propertyDetails.amenitiesFeatures : [],
      ...Array.isArray(propertyDetails.securityFeatures) ? propertyDetails.securityFeatures : [],
      ...Array.isArray(propertyDetails.kitchenFeatures) ? propertyDetails.kitchenFeatures : [],
      ...Array.isArray(propertyDetails.outdoorFeatures) ? propertyDetails.outdoorFeatures : [],
      ...Array.isArray(propertyDetails.energyFeatures) ? propertyDetails.energyFeatures : [],
      propertyDetails.waterHeating,
      propertyDetails.waterSupply
    ].filter(Boolean).flat(),
    // Location fields
    city: listing.city,
    province: listing.province,
    address: listing.streetAddress,
    zipCode: listing.postalCode,
    latitude: listing.latitude,
    longitude: listing.longitude,
    // Media
    // Media - prepend CDN URL if stored as path
    images: media.map((m) => {
      const url = m.processedUrl || m.originalUrl || m.mediaUrl;
      if (!url) return null;
      if (url.startsWith("http")) return url;
      let cdn = process.env.CLOUDFRONT_URL;
      const bucket = process.env.S3_BUCKET_NAME;
      const region = process.env.AWS_REGION || "us-east-1";
      if (cdn) {
        cdn = cdn.replace(/^https?:\/\//, "");
        cdn = cdn.replace(/\/$/, "");
        return `https://${cdn}/${url}`;
      } else if (bucket) {
        return `https://${bucket}.s3.${region}.amazonaws.com/${url}`;
      }
      return url;
    }).filter(Boolean),
    // Metadata
    status: listing.status,
    createdAt: listing.createdAt,
    updatedAt: listing.updatedAt,
    userId: listing.userId,
    ownerId: listing.userId,
    // Linked Agent/User details from join
    agent: listing.agentId ? {
      name: listing.agentName,
      image: listing.agentImage,
      email: listing.agentEmail,
      phone: listing.agentPhone
    } : null,
    user: {
      id: listing.ownerId,
      name: listing.ownerName,
      image: listing.ownerImage,
      email: listing.ownerEmail
    }
  };
}
async function searchListings(params) {
  const db3 = await getDb();
  if (!db3) return [];
  const conditions = [];
  conditions.push(sql4`${listings.status} = 'published'`);
  if (params.city) conditions.push(sql4`LOWER(${listings.city}) LIKE ${`%${params.city.toLowerCase()}%`}`);
  if (params.province) conditions.push(sql4`LOWER(${listings.province}) LIKE ${`%${params.province.toLowerCase()}%`}`);
  if (params.propertyType) conditions.push(eq3(listings.propertyType, params.propertyType));
  if (params.listingType) {
    const actionMap = {
      "sale": "sell",
      "rent": "rent",
      "auction": "auction",
      "rent_to_buy": "rent",
      "shared_living": "rent"
    };
    const action = actionMap[params.listingType] || params.listingType;
    conditions.push(eq3(listings.action, action));
  }
  if (params.minPrice || params.maxPrice) {
    const priceConditions = [];
    if (params.minPrice) {
      priceConditions.push(
        or(
          gte(listings.askingPrice, params.minPrice.toString()),
          gte(listings.monthlyRent, params.minPrice.toString()),
          gte(listings.startingBid, params.minPrice.toString())
        )
      );
    }
    if (params.maxPrice) {
      priceConditions.push(
        or(
          lte(listings.askingPrice, params.maxPrice.toString()),
          lte(listings.monthlyRent, params.maxPrice.toString()),
          lte(listings.startingBid, params.maxPrice.toString())
        )
      );
    }
    if (priceConditions.length > 0) {
      conditions.push(and3(...priceConditions));
    }
  }
  if (params.minLat !== void 0 && params.maxLat !== void 0) {
    conditions.push(
      sql4`CAST(${listings.latitude} AS DECIMAL(10, 6)) >= ${params.minLat} AND CAST(${listings.latitude} AS DECIMAL(10, 6)) <= ${params.maxLat}`
    );
  }
  if (params.minLng !== void 0 && params.maxLng !== void 0) {
    conditions.push(
      sql4`CAST(${listings.longitude} AS DECIMAL(10, 6)) >= ${params.minLng} AND CAST(${listings.longitude} AS DECIMAL(10, 6)) <= ${params.maxLng}`
    );
  }
  let query = db3.select({
    ...getTableColumns(listings),
    ownerName: users.name,
    ownerEmail: users.email,
    agentName: agents.displayName,
    agentImage: agents.profileImage,
    agentEmail: agents.email,
    agentPhone: agents.phone
  }).from(listings).leftJoin(users, eq3(listings.ownerId, users.id)).leftJoin(agents, eq3(listings.agentId, agents.id));
  if (conditions.length > 0) {
    query = query.where(and3(...conditions));
  }
  query = query.orderBy(desc(listings.createdAt));
  if (params.limit) {
    query = query.limit(params.limit);
  }
  if (params.offset) {
    query = query.offset(params.offset);
  }
  const results = await query;
  const listingsWithMedia = await Promise.all(
    results.map(async (listing) => {
      const media = await db3.select().from(listingMedia).where(eq3(listingMedia.listingId, listing.id)).orderBy(listingMedia.displayOrder);
      return transformListingToProperty(listing, media);
    })
  );
  let filtered = listingsWithMedia;
  if (params.minBedrooms) {
    filtered = filtered.filter((p) => p.bedrooms >= params.minBedrooms);
  }
  if (params.maxBedrooms) {
    filtered = filtered.filter((p) => p.bedrooms <= params.maxBedrooms);
  }
  if (params.minArea) {
    filtered = filtered.filter((p) => p.area >= params.minArea);
  }
  if (params.maxArea) {
    filtered = filtered.filter((p) => p.area <= params.maxArea);
  }
  if (params.amenities && params.amenities.length > 0) {
    filtered = filtered.filter(
      (p) => params.amenities.every(
        (amenity) => p.amenities.some((a) => a.toLowerCase().includes(amenity.toLowerCase()))
      )
    );
  }
  return filtered;
}
async function getFeaturedListings(limit = 6) {
  const db3 = await getDb();
  if (!db3) return [];
  const results = await db3.select().from(listings).where(and3(
    eq3(listings.featured, 1),
    eq3(listings.status, "approved")
  )).orderBy(desc(listings.createdAt)).limit(limit);
  const listingsWithMedia = await Promise.all(
    results.map(async (listing) => {
      const media = await db3.select().from(listingMedia).where(eq3(listingMedia.listingId, listing.id)).orderBy(listingMedia.displayOrder);
      return transformListingToProperty(listing, media);
    })
  );
  return listingsWithMedia;
}
async function createDeveloper(data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const validCategories = ["residential", "commercial", "mixed_use", "industrial"];
  const category = data.category || data.specializations?.find((s) => validCategories.includes(s)) || "residential";
  const [result] = await db3.insert(developers).values({
    name: data.name,
    description: data.description || null,
    logo: data.logo && data.logo.trim() !== "" ? data.logo : null,
    website: data.website && data.website.trim() !== "" ? data.website : null,
    email: data.email || null,
    phone: data.phone && data.phone.trim() !== "" ? data.phone : null,
    address: data.address && data.address.trim() !== "" ? data.address : null,
    city: data.city || null,
    province: data.province || null,
    establishedYear: data.establishedYear || null,
    trackRecord: null,
    // Will be added later after profile creation
    pastProjects: null,
    // Will be added later after profile creation
    userId: data.userId,
    // Convert specializations array to JSON string, or use category as fallback
    specializations: data.specializations ? JSON.stringify(data.specializations) : null,
    category,
    // Keep for backward compatibility
    isVerified: data.isVerified ?? 0,
    status: data.status ?? "pending",
    rejectionReason: null,
    // No rejection reason for new developers
    approvedBy: null,
    // Not approved yet
    approvedAt: null,
    // Not approved yet
    rejectedBy: null,
    // Not rejected yet
    rejectedAt: null,
    // Not rejected yet
    totalProjects: data.totalProjects ?? 0,
    completedProjects: data.completedProjects ?? 0,
    currentProjects: data.currentProjects ?? 0,
    upcomingProjects: data.upcomingProjects ?? 0,
    rating: 0,
    reviewCount: 0,
    kpiCache: null,
    // No KPI cache initially
    lastKpiCalculation: null
    // No KPI calculation initially
  });
  return result.insertId;
}
async function getDeveloperByUserId(userId) {
  try {
    const db3 = await getDb();
    if (!db3) {
      console.error("[Database] getDeveloperByUserId: Database not available");
      return null;
    }
    const [developer] = await db3.select().from(developers).where(eq3(developers.userId, userId)).limit(1);
    return developer || null;
  } catch (error) {
    console.error("[Database] Error in getDeveloperByUserId for userId:", userId, error);
    console.error("[Database] Error details:", {
      message: error.message,
      code: error.code,
      sqlMessage: error.sqlMessage
    });
    throw error;
  }
}
async function getDeveloperById(id) {
  const db3 = await getDb();
  if (!db3) return null;
  const [developer] = await db3.select().from(developers).where(eq3(developers.id, id)).limit(1);
  return developer || null;
}
async function updateDeveloper(id, data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const updateData = { ...data };
  if (data.specializations) {
    updateData.specializations = JSON.stringify(data.specializations);
    updateData.category = data.specializations[0] || "residential";
  }
  await db3.update(developers).set({
    ...updateData,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  }).where(eq3(developers.id, id));
  return true;
}
async function listDevelopers(filters) {
  const db3 = await getDb();
  if (!db3) return [];
  const conditions = [eq3(developers.status, "approved")];
  if (filters.category) {
    conditions.push(eq3(developers.category, filters.category));
  }
  if (filters.city) {
    conditions.push(like(developers.city, `%${filters.city}%`));
  }
  if (filters.province) {
    conditions.push(like(developers.province, `%${filters.province}%`));
  }
  if (typeof filters.isVerified !== "undefined") {
    conditions.push(eq3(developers.isVerified, filters.isVerified));
  }
  let query = db3.select().from(developers).where(and3(...conditions)).orderBy(desc(developers.createdAt));
  if (filters.limit) {
    query = query.limit(filters.limit);
  }
  if (filters.offset) {
    query = query.offset(filters.offset);
  }
  return await query;
}
async function listPendingDevelopers() {
  const db3 = await getDb();
  if (!db3) return [];
  return await db3.select().from(developers).where(eq3(developers.status, "pending")).orderBy(desc(developers.createdAt));
}
async function approveDeveloper(id, approvedBy) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developers).set({
    isVerified: 1,
    status: "approved",
    approvedBy,
    approvedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  }).where(eq3(developers.id, id));
  return true;
}
async function rejectDeveloper(id, rejectedBy, reason) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developers).set({
    status: "rejected",
    rejectionReason: reason,
    rejectedBy,
    rejectedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  }).where(eq3(developers.id, id));
  return true;
}
async function setDeveloperTrust(id, isTrusted) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developers).set({
    isTrusted,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
  }).where(eq3(developers.id, id));
  return true;
}
async function listPartners({
  page = 1,
  limit = 50,
  category,
  search
}) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const conditions = [];
  if (category) {
    conditions.push(eq3(partners.category, category));
  }
  if (search) {
    conditions.push(or(like(partners.name, `%${search}%`), like(partners.email, `%${search}%`)));
  }
  const offset = (page - 1) * limit;
  const [partnersList, countResult] = await Promise.all([
    db3.select().from(partners).where(and3(...conditions)).limit(limit).offset(offset).orderBy(desc(partners.createdAt)),
    db3.select({ count: count() }).from(partners).where(and3(...conditions))
  ]);
  const total = countResult[0]?.count ?? 0;
  const totalPages = Math.ceil(total / limit);
  return {
    partners: partnersList,
    pagination: {
      page,
      limit,
      total,
      totalPages
    }
  };
}
async function createPartner(data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.insert(partners).values(data);
  return result[0].insertId;
}
async function updatePartner(id, data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(partners).set(data).where(eq3(partners.id, id));
  return { success: true };
}
async function deletePartner(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.delete(partners).where(eq3(partners.id, id));
  return { success: true };
}
async function countPendingAgents() {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.select({ count: count() }).from(agents).where(eq3(agents.status, "pending"));
  return result[0]?.count ?? 0;
}
async function countPendingListings() {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.select({ count: count() }).from(listings).where(eq3(listings.status, "pending_review"));
  return result[0]?.count ?? 0;
}
async function countPendingDevelopments() {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.select({ count: count() }).from(developments).where(eq3(developments.approvalStatus, "pending"));
  return result[0]?.count ?? 0;
}
async function getEcosystemStats() {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const thirtyDaysAgo = /* @__PURE__ */ new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const dateStr = thirtyDaysAgo.toISOString();
  const [
    totalAgencies,
    activeAgencies,
    newAgencies
  ] = await Promise.all([
    db3.select({ count: count() }).from(agencies),
    db3.select({ count: count() }).from(agencies).where(eq3(agencies.isVerified, 1)),
    db3.select({ count: count() }).from(agencies).where(sql4`${agencies.createdAt} > ${dateStr}`)
  ]);
  const [
    totalAgents,
    activeAgents,
    newAgents
  ] = await Promise.all([
    db3.select({ count: count() }).from(agents),
    db3.select({ count: count() }).from(agents).where(eq3(agents.status, "approved")),
    db3.select({ count: count() }).from(agents).where(sql4`${agents.createdAt} > ${dateStr}`)
  ]);
  const [
    totalDevelopers,
    activeDevelopers,
    newDevelopers
  ] = await Promise.all([
    db3.select({ count: count() }).from(developers),
    db3.select({ count: count() }).from(developers).where(eq3(developers.status, "approved")),
    db3.select({ count: count() }).from(developers).where(sql4`${developers.createdAt} > ${dateStr}`)
  ]);
  const [
    totalUsers,
    newUsers
  ] = await Promise.all([
    db3.select({ count: count() }).from(users).where(eq3(users.role, "visitor")),
    // Assuming 'visitor' is end user
    db3.select({ count: count() }).from(users).where(and3(eq3(users.role, "visitor"), sql4`${users.createdAt} > ${dateStr}`))
  ]);
  return {
    agencies: {
      total: totalAgencies[0]?.count ?? 0,
      active: activeAgencies[0]?.count ?? 0,
      growth: newAgencies[0]?.count ?? 0
    },
    agents: {
      total: totalAgents[0]?.count ?? 0,
      active: activeAgents[0]?.count ?? 0,
      growth: newAgents[0]?.count ?? 0
    },
    developers: {
      total: totalDevelopers[0]?.count ?? 0,
      active: activeDevelopers[0]?.count ?? 0,
      growth: newDevelopers[0]?.count ?? 0
    },
    users: {
      total: totalUsers[0]?.count ?? 0,
      active: totalUsers[0]?.count ?? 0,
      // Users generally considered active if they exist for now
      growth: newUsers[0]?.count ?? 0
    }
  };
}
var db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    init_env();
    init_locationUtils();
    init_locationResolverService();
    init_db_connection();
    init_db_connection();
    db = new Proxy({}, {
      get(_target, prop) {
        if (!_db) {
          throw new Error("Database not initialized. Call getDb() first or use await getDb() in async functions.");
        }
        return _db[prop];
      }
    });
  }
});

// server/_core/email.ts
import { Resend } from "resend";
async function sendVerificationEmail({
  to,
  verificationToken,
  name
}) {
  const verificationUrl = `${process.env.APP_URL || "http://localhost:3000"}/verify-email?token=${verificationToken}`;
  try {
    const { data, error } = await resend.emails.send({
      from: process.env.EMAIL_FROM || "Property Listify <onboarding@resend.dev>",
      to: [to],
      subject: "Verify your email - Property Listify",
      html: `
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Verify Your Email</title>
          </head>
          <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f5f5f5; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 40px auto; background-color: #ffffff; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
              <!-- Header -->
              <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px 20px; text-align: center;">
                <h1 style="color: #ffffff; margin: 0; font-size: 28px; font-weight: 600;">Property Listify</h1>
              </div>
              
              <!-- Content -->
              <div style="padding: 40px 20px;">
                <h2 style="color: #1a1a1a; margin: 0 0 20px 0; font-size: 24px;">Welcome${name ? `, ${name}` : ""}! \u{1F44B}</h2>
                
                <p style="color: #4a4a4a; line-height: 1.6; margin: 0 0 20px 0; font-size: 16px;">
                  Thank you for registering with Property Listify. To complete your registration and access all features, please verify your email address.
                </p>
                
                <div style="text-align: center; margin: 30px 0;">
                  <a href="${verificationUrl}" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #ffffff; text-decoration: none; padding: 14px 32px; border-radius: 8px; font-weight: 600; font-size: 16px;">
                    Verify Email Address
                  </a>
                </div>
                
                <p style="color: #6b7280; line-height: 1.6; margin: 20px 0 0 0; font-size: 14px;">
                  Or copy and paste this link into your browser:<br>
                  <a href="${verificationUrl}" style="color: #667eea; word-break: break-all;">${verificationUrl}</a>
                </p>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                  <p style="color: #9ca3af; font-size: 13px; line-height: 1.6; margin: 0;">
                    If you didn't create an account with Property Listify, you can safely ignore this email.
                  </p>
                </div>
              </div>
              
              <!-- Footer -->
              <div style="background-color: #f9fafb; padding: 20px; text-align: center; border-top: 1px solid #e5e7eb;">
                <p style="color: #9ca3af; font-size: 12px; margin: 0;">
                  \xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Property Listify. All rights reserved.
                </p>
              </div>
            </div>
          </body>
        </html>
      `
    });
    if (error) {
      console.error("[Email] Failed to send verification email:", error);
      throw new Error(`Email send failed: ${error.message}`);
    }
    console.log("[Email] Verification email sent successfully:", data?.id);
    return { success: true, messageId: data?.id };
  } catch (error) {
    console.error("[Email] Error sending verification email:", error);
    throw error;
  }
}
var resend;
var init_email = __esm({
  "server/_core/email.ts"() {
    "use strict";
    resend = new Resend(process.env.RESEND_API_KEY);
  }
});

// server/_core/auth.ts
import { SignJWT, jwtVerify } from "jose";
import { parse as parseCookieHeader } from "cookie";
import bcrypt from "bcryptjs";
import crypto from "crypto";
import { sql as sql5 } from "drizzle-orm";
var isNonEmptyString, AuthService, authService, requireAuth;
var init_auth = __esm({
  "server/_core/auth.ts"() {
    "use strict";
    init_const();
    init_errors();
    init_db();
    init_db();
    init_env();
    init_email();
    isNonEmptyString = (value) => typeof value === "string" && value.length > 0;
    AuthService = class {
      getSessionSecret() {
        const secret = ENV.cookieSecret;
        if (!secret) {
          throw new Error("JWT_SECRET is required. Set it in your .env file.");
        }
        return new TextEncoder().encode(secret);
      }
      /**
       * Hash a password using bcrypt
       */
      async hashPassword(password) {
        const saltRounds = 10;
        return await bcrypt.hash(password, saltRounds);
      }
      /**
       * Verify a password against a hash
       */
      async verifyPassword(password, hash) {
        return await bcrypt.compare(password, hash);
      }
      /**
       * Create a session token (JWT) for a user
       */
      async createSessionToken(userId, email, name, options = {}) {
        const issuedAt = Date.now();
        const expiresInMs = options.expiresInMs ?? ONE_YEAR_MS;
        const expirationSeconds = Math.floor((issuedAt + expiresInMs) / 1e3);
        const secretKey = this.getSessionSecret();
        return new SignJWT({
          userId,
          email,
          name
        }).setProtectedHeader({ alg: "HS256", typ: "JWT" }).setIssuedAt(Math.floor(issuedAt / 1e3)).setExpirationTime(expirationSeconds).sign(secretKey);
      }
      /**
       * Verify a session token from a cookie
       */
      async verifySession(cookieValue) {
        if (!cookieValue) {
          return null;
        }
        try {
          const secretKey = this.getSessionSecret();
          const { payload } = await jwtVerify(cookieValue, secretKey, {
            algorithms: ["HS256"]
          });
          const { userId, email, name } = payload;
          if (typeof userId !== "number" || !isNonEmptyString(email)) {
            console.warn("[Auth] Session payload missing required fields");
            return null;
          }
          return {
            userId,
            email,
            name: isNonEmptyString(name) ? name : email
            // Use email as fallback if name is missing
          };
        } catch (error) {
          if (error?.code === "ERR_JWS_SIGNATURE_VERIFICATION_FAILED") {
            console.error("[Auth] \u274C INVALID SIGNATURE: Token was signed with a different secret key.");
            console.error("[Auth] This usually means:");
            console.error("[Auth]   1. JWT_SECRET in .env was changed after token was created");
            console.error("[Auth]   2. Token was created by old OAuth system (Manus)");
            console.error("[Auth]   3. Token is corrupted");
            console.error("[Auth] \u{1F4A1} Solution: Clear browser cookies and login again");
          } else if (error?.code === "ERR_JWT_EXPIRED") {
            console.warn("[Auth] Token expired");
          } else {
            console.warn("[Auth] Session verification failed:", error?.message || String(error));
          }
          return null;
        }
      }
      /**
       * Parse cookies from request header
       */
      parseCookies(cookieHeader) {
        if (!cookieHeader) {
          return /* @__PURE__ */ new Map();
        }
        const parsed = parseCookieHeader(cookieHeader);
        return new Map(Object.entries(parsed));
      }
      /**
       * Authenticate a request and return the user
       * This is the main authentication method used in tRPC context
       */
      async authenticateRequest(req) {
        console.log("[Auth] authenticateRequest called");
        console.log("[Auth] Cookie header:", req.headers.cookie);
        const cookies = this.parseCookies(req.headers.cookie);
        console.log("[Auth] Parsed cookies:", Array.from(cookies.entries()));
        const sessionCookie = cookies.get(COOKIE_NAME);
        console.log("[Auth] COOKIE_NAME:", COOKIE_NAME);
        console.log("[Auth] sessionCookie value:", sessionCookie ? "(exists)" : "(missing)");
        console.log("[Auth] Session cookie value:", sessionCookie ? "(exists)" : "(missing)");
        const session = await this.verifySession(sessionCookie);
        console.log("[Auth] Session verification result:", session ? "valid" : "invalid");
        if (!session) {
          throw ForbiddenError("Invalid or missing session cookie");
        }
        const user = await getUserById(session.userId);
        console.log("[Auth] User from DB:", user ? `${user.email} (role: ${user.role})` : "not found");
        if (!user) {
          throw ForbiddenError("User not found");
        }
        await updateUserLastSignIn(user.id);
        return user;
      }
      /**
       * Register a new user with email and password
       */
      async register(email, password, name, role = "visitor", agentProfile) {
        const existingUser = await getUserByEmail(email);
        if (existingUser) {
          throw new Error("User with this email already exists");
        }
        const passwordHash = await this.hashPassword(password);
        const emailVerificationToken = crypto.randomBytes(32).toString("hex");
        const userId = await createUser({
          email,
          passwordHash,
          name: name || email.split("@")[0],
          emailVerified: 0,
          loginMethod: "email",
          role,
          // Use requested role
          isSubaccount: 0,
          emailVerificationToken
        });
        if (role === "agent" && agentProfile) {
          const database = await getDb();
          if (database) {
            await database.execute(sql5`
          INSERT INTO pending_agent_profiles 
          (userId, displayName, phone, bio, licenseNumber, specializations)
          VALUES (
            ${userId}, 
            ${agentProfile.displayName}, 
            ${agentProfile.phone}, 
            ${agentProfile.bio || null}, 
            ${agentProfile.licenseNumber || null}, 
            ${agentProfile.specializations ? agentProfile.specializations.join(",") : null}
          )
        `);
          }
        }
        const user = await getUserById(userId);
        if (!user) {
          throw new Error("Failed to create user");
        }
        try {
          await sendVerificationEmail({
            to: user.email,
            verificationToken: emailVerificationToken,
            name: user.name || void 0
          });
          console.log("[Auth] Verification email sent successfully");
        } catch (emailError) {
          console.error("[Auth] Failed to send verification email:", emailError);
        }
        return userId;
      }
      /**
       * Login with email and password
       */
      async login(email, password, rememberMe) {
        const user = await getUserByEmail(email);
        if (!user) {
          throw ForbiddenError("Invalid email or password");
        }
        if (!user.passwordHash) {
          throw ForbiddenError("This account uses OAuth login. Please use your original login method.");
        }
        const isValid = await this.verifyPassword(password, user.passwordHash);
        if (!isValid) {
          throw ForbiddenError("Invalid email or password");
        }
        if (!user.emailVerified) {
          throw ForbiddenError("Please verify your email address before logging in.");
        }
        if (user.role === "agent") {
          const agentProfile = await getAgentByUserId(user.id);
          if (agentProfile) {
            if (agentProfile.status === "pending") {
              throw new Error("Your agent application is pending review. You will be notified once approved.");
            }
            if (agentProfile.status === "rejected") {
              const reason = agentProfile.rejectionReason || "No reason provided";
              throw new Error(`Your agent application was rejected. Reason: ${reason}`);
            }
            if (agentProfile.status === "suspended") {
              throw new Error("Your agent account has been suspended. Please contact support.");
            }
          }
        }
        await updateUserLastSignIn(user.id);
        const expiresInMs = rememberMe ? 30 * 24 * 60 * 60 * 1e3 : 24 * 60 * 60 * 1e3;
        const sessionToken = await this.createSessionToken(
          user.id,
          user.email,
          user.name || user.email,
          { expiresInMs }
        );
        return { user, sessionToken };
      }
      /**
       * Forgot password - generate and send reset token
       */
      async forgotPassword(email) {
        const user = await getUserByEmail(email);
        if (!user) {
          return;
        }
        const token = crypto.randomBytes(32).toString("hex");
        const hashedToken = crypto.createHash("sha256").update(token).digest("hex");
        const expiresAt = new Date(Date.now() + 36e5);
        await updateUserPasswordResetToken(user.id, hashedToken, expiresAt);
        const resetLink = `${ENV.appUrl}/reset-password?token=${token}`;
        await EmailService.sendEmail({
          to: user.email,
          subject: "Password Reset Request",
          html: `<p>You requested a password reset. Click the link below to reset your password:</p><a href="${resetLink}">${resetLink}</a><p>This link will expire in 1 hour.</p>`,
          text: `You requested a password reset. Copy and paste this link into your browser to reset your password: ${resetLink}`
        });
      }
      /**
       * Reset password using a token
       */
      async resetPassword(token, newPassword) {
        const hashedToken = crypto.createHash("sha256").update(token).digest("hex");
        const user = await getUserByPasswordResetToken(hashedToken);
        if (!user || !user.passwordResetTokenExpiresAt) {
          throw new Error("Invalid or expired password reset token.");
        }
        if (/* @__PURE__ */ new Date() > new Date(user.passwordResetTokenExpiresAt)) {
          throw new Error("Invalid or expired password reset token.");
        }
        const passwordHash = await this.hashPassword(newPassword);
        await updateUserPassword(user.id, passwordHash);
      }
      /**
       * Verify email address using a token
       */
      async verifyEmail(token) {
        const user = await getUserByEmailVerificationToken(token);
        if (!user) {
          throw new Error("Invalid or expired email verification token.");
        }
        await verifyUserEmail(user.id);
        if (user.role === "agent") {
          const database = await getDb();
          if (database) {
            const [pendingProfile] = await database.execute(sql5`
          SELECT * FROM pending_agent_profiles WHERE userId = ${user.id}
        `);
            if (pendingProfile && pendingProfile.rows && pendingProfile.rows.length > 0) {
              const profileData = pendingProfile.rows[0];
              await createAgentProfile({
                userId: user.id,
                displayName: profileData.displayName,
                phone: profileData.phone,
                bio: profileData.bio,
                licenseNumber: profileData.licenseNumber,
                specializations: profileData.specializations ? profileData.specializations.split(",") : void 0
              });
              await database.execute(sql5`
            DELETE FROM pending_agent_profiles WHERE userId = ${user.id}
          `);
            }
          }
        }
      }
    };
    authService = new AuthService();
    requireAuth = async (req, res, next) => {
      try {
        const user = await authService.authenticateRequest(req);
        req.user = user;
        next();
      } catch (error) {
        console.warn("[AuthMiddleware] Unauthorized access attempt:", error);
        res.status(401).json({ error: "Unauthorized" });
      }
    };
  }
});

// server/lib/redis.ts
import { createClient } from "redis";
var CacheTTL, RedisCache, redisCache;
var init_redis = __esm({
  "server/lib/redis.ts"() {
    "use strict";
    CacheTTL = {
      USER_PREFERENCES: 3600,
      // 1 hour
      FEED_RESULTS: 300,
      // 5 minutes
      NEIGHBOURHOOD_DATA: 86400,
      // 1 day
      VIDEO_METADATA: 3600,
      // 1 hour
      PERFORMANCE_SCORE: 900,
      // 15 minutes
      CATEGORIES: 86400,
      // 1 day
      SIMILAR_PROPERTIES: 1800,
      // 30 minutes
      BOOST_CAMPAIGNS: 300,
      // 5 minutes
      ANALYTICS: 600
      // 10 minutes
    };
    RedisCache = class {
      client = null;
      isConnected = false;
      connectionPromise = null;
      fallbackCache = /* @__PURE__ */ new Map();
      constructor() {
        this.initializeConnection();
      }
      async initializeConnection() {
        const redisUrl = process.env.REDIS_URL;
        if (!redisUrl) {
          console.log("[Redis] No REDIS_URL configured, using in-memory fallback");
          return;
        }
        try {
          this.client = createClient({ url: redisUrl });
          this.client.on("error", (err) => {
            console.error("[Redis] Connection error:", err.message);
            this.isConnected = false;
          });
          this.client.on("connect", () => {
            console.log("[Redis] Connected successfully");
            this.isConnected = true;
          });
          this.client.on("reconnecting", () => {
            console.log("[Redis] Reconnecting...");
          });
          this.connectionPromise = this.client.connect();
          await this.connectionPromise;
        } catch (error) {
          console.error("[Redis] Failed to connect:", error);
          this.client = null;
          this.isConnected = false;
        }
      }
      async ensureConnected() {
        if (this.connectionPromise) {
          try {
            await this.connectionPromise;
          } catch {
          }
        }
        return this.isConnected && this.client !== null;
      }
      /**
       * Get value from cache
       */
      async get(key) {
        try {
          if (await this.ensureConnected() && this.client) {
            const value = await this.client.get(key);
            if (value) {
              return JSON.parse(value);
            }
            return null;
          }
          return this.getFallback(key);
        } catch (error) {
          console.error("[Redis] Get error:", error);
          return this.getFallback(key);
        }
      }
      /**
       * Set value in cache with TTL
       */
      async set(key, value, ttlSeconds = CacheTTL.FEED_RESULTS) {
        try {
          const serialized = JSON.stringify(value);
          if (await this.ensureConnected() && this.client) {
            await this.client.setEx(key, ttlSeconds, serialized);
            return;
          }
          this.setFallback(key, serialized, ttlSeconds);
        } catch (error) {
          console.error("[Redis] Set error:", error);
          this.setFallback(key, JSON.stringify(value), ttlSeconds);
        }
      }
      /**
       * Delete value from cache
       */
      async del(key) {
        try {
          if (await this.ensureConnected() && this.client) {
            await this.client.del(key);
          }
          this.fallbackCache.delete(key);
        } catch (error) {
          console.error("[Redis] Delete error:", error);
          this.fallbackCache.delete(key);
        }
      }
      /**
       * Delete multiple keys by pattern
       */
      async delByPattern(pattern) {
        try {
          if (await this.ensureConnected() && this.client) {
            const keys = await this.client.keys(pattern);
            if (keys.length > 0) {
              await this.client.del(keys);
            }
          }
          const regex = new RegExp(pattern.replace(/\*/g, ".*"));
          for (const key of this.fallbackCache.keys()) {
            if (regex.test(key)) {
              this.fallbackCache.delete(key);
            }
          }
        } catch (error) {
          console.error("[Redis] Delete by pattern error:", error);
        }
      }
      /**
       * Check if key exists
       */
      async exists(key) {
        try {
          if (await this.ensureConnected() && this.client) {
            return await this.client.exists(key) === 1;
          }
          return this.fallbackCache.has(key);
        } catch (error) {
          return this.fallbackCache.has(key);
        }
      }
      /**
       * Get remaining TTL for a key
       */
      async ttl(key) {
        try {
          if (await this.ensureConnected() && this.client) {
            return await this.client.ttl(key);
          }
          const entry = this.fallbackCache.get(key);
          if (entry) {
            return Math.max(0, Math.floor((entry.expiresAt - Date.now()) / 1e3));
          }
          return -2;
        } catch (error) {
          return -1;
        }
      }
      // Fallback methods for when Redis is unavailable
      getFallback(key) {
        const entry = this.fallbackCache.get(key);
        if (!entry) return null;
        if (Date.now() > entry.expiresAt) {
          this.fallbackCache.delete(key);
          return null;
        }
        return JSON.parse(entry.value);
      }
      setFallback(key, value, ttlSeconds) {
        this.fallbackCache.set(key, {
          value,
          expiresAt: Date.now() + ttlSeconds * 1e3
        });
      }
      /**
       * Get cache statistics
       */
      async getStats() {
        try {
          if (await this.ensureConnected() && this.client) {
            const info = await this.client.info("memory");
            const dbSize = await this.client.dbSize();
            const memMatch = info.match(/used_memory_human:(\S+)/);
            return {
              connected: true,
              keys: dbSize,
              memory: memMatch ? memMatch[1] : "unknown"
            };
          }
        } catch (error) {
        }
        return {
          connected: false,
          keys: this.fallbackCache.size
        };
      }
      /**
       * Graceful shutdown
       */
      async disconnect() {
        if (this.client && this.isConnected) {
          await this.client.quit();
          this.isConnected = false;
        }
      }
    };
    redisCache = new RedisCache();
  }
});

// server/services/googlePlacesApiMonitoring.ts
var googlePlacesApiMonitoring_exports = {};
__export(googlePlacesApiMonitoring_exports, {
  GooglePlacesApiMonitoringService: () => GooglePlacesApiMonitoringService,
  googlePlacesApiMonitoring: () => googlePlacesApiMonitoring
});
import { sql as sql12 } from "drizzle-orm";
var GooglePlacesApiMonitoringService, googlePlacesApiMonitoring;
var init_googlePlacesApiMonitoring = __esm({
  "server/services/googlePlacesApiMonitoring.ts"() {
    "use strict";
    init_db();
    GooglePlacesApiMonitoringService = class {
      config = null;
      configLoadedAt = null;
      CONFIG_CACHE_TTL = 5 * 60 * 1e3;
      // 5 minutes
      /**
       * Log an API request
       * Requirements 26.1, 26.2, 26.3: Log all API requests with context
       */
      async logAPIRequest(log) {
        try {
          const db3 = await getDb();
          if (!db3) return;
          await db3.execute(sql12`
        INSERT INTO google_places_api_logs (
          timestamp,
          request_type,
          session_token,
          success,
          response_time_ms,
          error_message,
          user_id,
          ip_address
        ) VALUES (
          ${log.timestamp},
          ${log.requestType},
          ${log.sessionToken || null},
          ${log.success},
          ${log.responseTime},
          ${log.error || null},
          ${log.userId || null},
          ${log.ipAddress || null}
        )
      `);
          await this.updateDailySummary(log);
          await this.checkThresholds();
        } catch (error) {
          console.error("Failed to log API request:", error);
        }
      }
      /**
       * Update daily summary statistics
       */
      async updateDailySummary(log) {
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        try {
          const db3 = await getDb();
          if (!db3) return;
          const result = await db3.execute(sql12`
        SELECT * FROM google_places_api_daily_summary
        WHERE date = ${today}
      `);
          const summary = result.rows[0];
          if (summary) {
            const totalRequests = summary.total_requests + 1;
            const successfulRequests = summary.successful_requests + (log.success ? 1 : 0);
            const failedRequests = summary.failed_requests + (log.success ? 0 : 1);
            const typeColumn = `${log.requestType}_requests`;
            const typeCount = (summary[typeColumn] || 0) + 1;
            const totalResponseTime = (summary.average_response_time_ms || 0) * summary.total_requests;
            const newAverageResponseTime = (totalResponseTime + log.responseTime) / totalRequests;
            const config = await this.getConfig();
            const requestCost = this.calculateRequestCost(log.requestType, config);
            const totalCost = (summary.total_cost_usd || 0) + requestCost;
            await db3.execute(sql12`
          UPDATE google_places_api_daily_summary
          SET
            total_requests = ${totalRequests},
            successful_requests = ${successfulRequests},
            failed_requests = ${failedRequests},
            ${sql12.raw(typeColumn)} = ${typeCount},
            average_response_time_ms = ${newAverageResponseTime},
            total_cost_usd = ${totalCost}
          WHERE date = ${today}
        `);
          } else {
            const config = await this.getConfig();
            const requestCost = this.calculateRequestCost(log.requestType, config);
            await db3.execute(sql12`
          INSERT INTO google_places_api_daily_summary (
            date,
            total_requests,
            successful_requests,
            failed_requests,
            autocomplete_requests,
            place_details_requests,
            geocode_requests,
            reverse_geocode_requests,
            average_response_time_ms,
            total_cost_usd
          ) VALUES (
            ${today},
            1,
            ${log.success ? 1 : 0},
            ${log.success ? 0 : 1},
            ${log.requestType === "autocomplete" ? 1 : 0},
            ${log.requestType === "place_details" ? 1 : 0},
            ${log.requestType === "geocode" ? 1 : 0},
            ${log.requestType === "reverse_geocode" ? 1 : 0},
            ${log.responseTime},
            ${requestCost}
          )
        `);
          }
        } catch (error) {
          console.error("Failed to update daily summary:", error);
        }
      }
      /**
       * Calculate cost for a single request
       */
      calculateRequestCost(requestType, config) {
        switch (requestType) {
          case "autocomplete":
            return config.autocompleteCostPer1000 / 1e3;
          case "place_details":
            return config.placeDetailsCostPer1000 / 1e3;
          case "geocode":
          case "reverse_geocode":
            return config.geocodeCostPer1000 / 1e3;
          default:
            return 0;
        }
      }
      /**
       * Check thresholds and create alerts if needed
       * Requirements 26.5: Alert when usage exceeds 80% of limit
       */
      async checkThresholds() {
        try {
          const config = await this.getConfig();
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          const db3 = await getDb();
          if (!db3) return;
          const result = await db3.execute(sql12`
        SELECT * FROM google_places_api_daily_summary
        WHERE date = ${today}
      `);
          const summary = result.rows[0];
          if (!summary) return;
          const usagePercentage = summary.total_requests / config.dailyRequestLimit;
          if (usagePercentage >= config.usageAlertThreshold) {
            await this.createAlert({
              alertType: "usage_threshold",
              thresholdValue: config.usageAlertThreshold * 100,
              currentValue: usagePercentage * 100,
              severity: usagePercentage >= 0.95 ? "critical" : "warning",
              message: `API usage at ${(usagePercentage * 100).toFixed(1)}% of daily limit (${summary.total_requests}/${config.dailyRequestLimit} requests)`
            });
          }
          const errorRate = summary.failed_requests / summary.total_requests;
          if (errorRate >= config.errorRateThreshold) {
            await this.createAlert({
              alertType: "error_rate",
              thresholdValue: config.errorRateThreshold * 100,
              currentValue: errorRate * 100,
              severity: errorRate >= 0.1 ? "critical" : "warning",
              message: `API error rate at ${(errorRate * 100).toFixed(1)}% (${summary.failed_requests}/${summary.total_requests} requests failed)`
            });
          }
          if (summary.average_response_time_ms >= config.responseTimeThreshold) {
            await this.createAlert({
              alertType: "response_time",
              thresholdValue: config.responseTimeThreshold,
              currentValue: summary.average_response_time_ms,
              severity: summary.average_response_time_ms >= config.responseTimeThreshold * 2 ? "critical" : "warning",
              message: `Average API response time at ${summary.average_response_time_ms}ms (threshold: ${config.responseTimeThreshold}ms)`
            });
          }
          if (summary.total_cost_usd >= config.costAlertThreshold) {
            await this.createAlert({
              alertType: "cost_threshold",
              thresholdValue: config.costAlertThreshold,
              currentValue: summary.total_cost_usd,
              severity: "warning",
              message: `Daily API cost at $${summary.total_cost_usd.toFixed(2)} (threshold: $${config.costAlertThreshold})`
            });
          }
        } catch (error) {
          console.error("Failed to check thresholds:", error);
        }
      }
      /**
       * Create an alert if one doesn't already exist for today
       */
      async createAlert(alert) {
        try {
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          const db3 = await getDb();
          if (!db3) return;
          const existing = await db3.execute(sql12`
        SELECT id FROM google_places_api_alerts
        WHERE alert_type = ${alert.alertType}
          AND DATE(triggered_at) = ${today}
          AND resolved_at IS NULL
      `);
          if (existing.rows.length === 0) {
            await db3.execute(sql12`
          INSERT INTO google_places_api_alerts (
            alert_type,
            threshold_value,
            current_value,
            severity,
            message
          ) VALUES (
            ${alert.alertType},
            ${alert.thresholdValue},
            ${alert.currentValue},
            ${alert.severity},
            ${alert.message}
          )
        `);
            const emoji = alert.severity === "critical" ? "\u{1F6A8}" : "\u26A0\uFE0F";
            console.log(`${emoji} Google Places API Alert [${alert.severity}]: ${alert.message}`);
          }
        } catch (error) {
          console.error("Failed to create alert:", error);
        }
      }
      /**
       * Get usage statistics for dashboard
       * Requirements 26.4: Provide dashboard showing API call counts
       */
      async getUsageStatistics() {
        try {
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0];
          const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0];
          const db3 = await getDb();
          if (!db3) throw new Error("Database not available");
          const todayResult = await db3.execute(sql12`
        SELECT * FROM google_places_api_daily_summary
        WHERE date = ${today}
      `);
          const todaySummary = this.formatDailySummary(todayResult.rows[0]);
          const last7DaysResult = await db3.execute(sql12`
        SELECT
          SUM(total_requests) as total_requests,
          SUM(successful_requests) as successful_requests,
          SUM(failed_requests) as failed_requests,
          SUM(autocomplete_requests) as autocomplete_requests,
          SUM(place_details_requests) as place_details_requests,
          SUM(geocode_requests) as geocode_requests,
          SUM(reverse_geocode_requests) as reverse_geocode_requests,
          AVG(average_response_time_ms) as average_response_time_ms,
          SUM(total_cost_usd) as total_cost_usd
        FROM google_places_api_daily_summary
        WHERE date >= ${sevenDaysAgo}
      `);
          const last7DaysSummary = this.formatDailySummary(last7DaysResult.rows[0]);
          const last30DaysResult = await db3.execute(sql12`
        SELECT
          SUM(total_requests) as total_requests,
          SUM(successful_requests) as successful_requests,
          SUM(failed_requests) as failed_requests,
          SUM(autocomplete_requests) as autocomplete_requests,
          SUM(place_details_requests) as place_details_requests,
          SUM(geocode_requests) as geocode_requests,
          SUM(reverse_geocode_requests) as reverse_geocode_requests,
          AVG(average_response_time_ms) as average_response_time_ms,
          SUM(total_cost_usd) as total_cost_usd
        FROM google_places_api_daily_summary
        WHERE date >= ${thirtyDaysAgo}
      `);
          const last30DaysSummary = this.formatDailySummary(last30DaysResult.rows[0]);
          const oneHourAgo = new Date(Date.now() - 60 * 60 * 1e3);
          const currentHourResult = await db3.execute(sql12`
        SELECT
          COUNT(*) as total_requests,
          SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_requests,
          AVG(response_time_ms) as average_response_time_ms
        FROM google_places_api_logs
        WHERE timestamp >= ${oneHourAgo}
      `);
          const currentHourData = currentHourResult.rows[0];
          const topErrorsResult = await db3.execute(sql12`
        SELECT
          error_message as error,
          COUNT(*) as count,
          MAX(timestamp) as last_occurrence
        FROM google_places_api_logs
        WHERE success = 0
          AND error_message IS NOT NULL
          AND timestamp >= ${sevenDaysAgo}
        GROUP BY error_message
        ORDER BY count DESC
        LIMIT 10
      `);
          const config = await this.getConfig();
          const hoursElapsed = (/* @__PURE__ */ new Date()).getHours() + 1;
          const dailyProjected = todaySummary.totalCost * (24 / hoursElapsed);
          const monthlyProjected = last30DaysSummary.totalCost * (30 / 30);
          return {
            today: todaySummary,
            last7Days: last7DaysSummary,
            last30Days: last30DaysSummary,
            currentHour: {
              totalRequests: Number(currentHourData?.total_requests || 0),
              successRate: currentHourData?.total_requests > 0 ? Number(currentHourData.successful_requests) / Number(currentHourData.total_requests) * 100 : 100,
              averageResponseTime: Number(currentHourData?.average_response_time_ms || 0)
            },
            topErrors: topErrorsResult.rows.map((row) => ({
              error: row.error,
              count: Number(row.count),
              lastOccurrence: new Date(row.last_occurrence)
            })),
            costProjection: {
              dailyProjected,
              monthlyProjected
            }
          };
        } catch (error) {
          console.error("Failed to get usage statistics:", error);
          throw error;
        }
      }
      /**
       * Format daily summary data
       */
      formatDailySummary(data) {
        if (!data) {
          return {
            date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            autocompleteRequests: 0,
            placeDetailsRequests: 0,
            geocodeRequests: 0,
            reverseGeocodeRequests: 0,
            averageResponseTime: 0,
            totalCost: 0,
            errorRate: 0
          };
        }
        const totalRequests = Number(data.total_requests || 0);
        const failedRequests = Number(data.failed_requests || 0);
        return {
          date: data.date || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
          totalRequests,
          successfulRequests: Number(data.successful_requests || 0),
          failedRequests,
          autocompleteRequests: Number(data.autocomplete_requests || 0),
          placeDetailsRequests: Number(data.place_details_requests || 0),
          geocodeRequests: Number(data.geocode_requests || 0),
          reverseGeocodeRequests: Number(data.reverse_geocode_requests || 0),
          averageResponseTime: Number(data.average_response_time_ms || 0),
          totalCost: Number(data.total_cost_usd || 0),
          errorRate: totalRequests > 0 ? failedRequests / totalRequests * 100 : 0
        };
      }
      /**
       * Get active alerts
       */
      async getActiveAlerts() {
        try {
          const db3 = await getDb();
          if (!db3) return [];
          const result = await db3.execute(sql12`
        SELECT * FROM google_places_api_alerts
        WHERE resolved_at IS NULL
        ORDER BY triggered_at DESC
        LIMIT 50
      `);
          return result.rows.map((row) => ({
            id: row.id,
            alertType: row.alert_type,
            thresholdValue: Number(row.threshold_value),
            currentValue: Number(row.current_value),
            triggeredAt: new Date(row.triggered_at),
            resolvedAt: row.resolved_at ? new Date(row.resolved_at) : null,
            severity: row.severity,
            message: row.message,
            notified: Boolean(row.notified)
          }));
        } catch (error) {
          console.error("Failed to get active alerts:", error);
          return [];
        }
      }
      /**
       * Resolve an alert
       */
      async resolveAlert(alertId) {
        try {
          const db3 = await getDb();
          if (!db3) return;
          await db3.execute(sql12`
        UPDATE google_places_api_alerts
        SET resolved_at = NOW()
        WHERE id = ${alertId}
      `);
        } catch (error) {
          console.error("Failed to resolve alert:", error);
          throw error;
        }
      }
      /**
       * Get monitoring configuration
       */
      async getConfig() {
        if (this.config && this.configLoadedAt && Date.now() - this.configLoadedAt.getTime() < this.CONFIG_CACHE_TTL) {
          return this.config;
        }
        try {
          const db3 = await getDb();
          if (!db3) throw new Error("Database not available");
          const result = await db3.execute(sql12`
        SELECT config_key, config_value
        FROM google_places_api_config
      `);
          const configMap = /* @__PURE__ */ new Map();
          for (const row of result.rows) {
            configMap.set(row.config_key, row.config_value);
          }
          this.config = {
            dailyRequestLimit: Number(configMap.get("daily_request_limit") || 1e4),
            usageAlertThreshold: Number(configMap.get("usage_alert_threshold") || 0.8),
            errorRateThreshold: Number(configMap.get("error_rate_threshold") || 0.05),
            responseTimeThreshold: Number(configMap.get("response_time_threshold") || 3e3),
            costAlertThreshold: Number(configMap.get("cost_alert_threshold") || 100),
            autocompleteCostPer1000: Number(configMap.get("autocomplete_cost_per_1000") || 2.83),
            placeDetailsCostPer1000: Number(configMap.get("place_details_cost_per_1000") || 17),
            geocodeCostPer1000: Number(configMap.get("geocode_cost_per_1000") || 5)
          };
          this.configLoadedAt = /* @__PURE__ */ new Date();
          return this.config;
        } catch (error) {
          console.error("Failed to load monitoring config:", error);
          return {
            dailyRequestLimit: 1e4,
            usageAlertThreshold: 0.8,
            errorRateThreshold: 0.05,
            responseTimeThreshold: 3e3,
            costAlertThreshold: 100,
            autocompleteCostPer1000: 2.83,
            placeDetailsCostPer1000: 17,
            geocodeCostPer1000: 5
          };
        }
      }
      /**
       * Update monitoring configuration
       */
      async updateConfig(updates) {
        try {
          const configMap = {
            dailyRequestLimit: updates.dailyRequestLimit,
            usageAlertThreshold: updates.usageAlertThreshold,
            errorRateThreshold: updates.errorRateThreshold,
            responseTimeThreshold: updates.responseTimeThreshold,
            costAlertThreshold: updates.costAlertThreshold,
            autocompleteCostPer1000: updates.autocompleteCostPer1000,
            placeDetailsCostPer1000: updates.placeDetailsCostPer1000,
            geocodeCostPer1000: updates.geocodeCostPer1000
          };
          const db3 = await getDb();
          if (!db3) throw new Error("Database not available");
          for (const [key, value] of Object.entries(configMap)) {
            if (value !== void 0) {
              const dbKey = key.replace(/([A-Z])/g, "_$1").toLowerCase();
              await db3.execute(sql12`
            UPDATE google_places_api_config
            SET config_value = ${value.toString()}
            WHERE config_key = ${dbKey}
          `);
            }
          }
          this.config = null;
          this.configLoadedAt = null;
        } catch (error) {
          console.error("Failed to update monitoring config:", error);
          throw error;
        }
      }
      /**
       * Get historical data for charts
       */
      async getHistoricalData(days = 30) {
        try {
          const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1e3).toISOString().split("T")[0];
          const db3 = await getDb();
          if (!db3) return [];
          const result = await db3.execute(sql12`
        SELECT * FROM google_places_api_daily_summary
        WHERE date >= ${startDate}
        ORDER BY date ASC
      `);
          return result.rows.map((row) => this.formatDailySummary(row));
        } catch (error) {
          console.error("Failed to get historical data:", error);
          return [];
        }
      }
    };
    googlePlacesApiMonitoring = new GooglePlacesApiMonitoringService();
  }
});

// server/services/googlePlacesService.ts
var googlePlacesService_exports = {};
__export(googlePlacesService_exports, {
  GooglePlacesService: () => GooglePlacesService,
  extractHierarchy: () => extractHierarchy,
  googlePlacesService: () => googlePlacesService,
  validateCoordinatePrecision: () => validateCoordinatePrecision,
  validateSouthAfricaBoundaries: () => validateSouthAfricaBoundaries
});
import axios from "axios";
import { nanoid } from "nanoid";
function extractHierarchy(placeDetails) {
  const components = placeDetails.addressComponents;
  const provinceComponent = components.find(
    (comp) => comp.types.includes("administrative_area_level_1")
  );
  const province2 = provinceComponent?.longName || null;
  const localityComponent = components.find(
    (comp) => comp.types.includes("locality")
  );
  const adminLevel2Component = components.find(
    (comp) => comp.types.includes("administrative_area_level_2")
  );
  const city = localityComponent?.longName || adminLevel2Component?.longName || null;
  const sublocalityComponent = components.find(
    (comp) => comp.types.includes("sublocality_level_1") || comp.types.includes("sublocality")
  );
  const neighborhoodComponent = components.find(
    (comp) => comp.types.includes("neighborhood")
  );
  const suburb = sublocalityComponent?.longName || neighborhoodComponent?.longName || null;
  const streetNumberComponent = components.find(
    (comp) => comp.types.includes("street_number")
  );
  const routeComponent = components.find(
    (comp) => comp.types.includes("route")
  );
  let streetAddress = null;
  if (streetNumberComponent && routeComponent) {
    streetAddress = `${streetNumberComponent.longName} ${routeComponent.longName}`;
  } else if (routeComponent) {
    streetAddress = routeComponent.longName;
  }
  const { lat, lng } = placeDetails.geometry.location;
  const latStr = lat.toString();
  const lngStr = lng.toString();
  const latPrecision = latStr.includes(".") ? latStr.split(".")[1].length : 0;
  const lngPrecision = lngStr.includes(".") ? lngStr.split(".")[1].length : 0;
  const precision = Math.min(latPrecision, lngPrecision);
  const isWithinSouthAfrica = lat >= -35 && lat <= -22 && lng >= 16 && lng <= 33;
  return {
    province: province2,
    city,
    suburb,
    streetAddress,
    coordinates: {
      lat,
      lng,
      precision
    },
    viewport: placeDetails.geometry.viewport,
    isWithinSouthAfrica
  };
}
function validateCoordinatePrecision(lat, lng) {
  const latStr = lat.toString();
  const lngStr = lng.toString();
  const latPrecision = latStr.includes(".") ? latStr.split(".")[1].length : 0;
  const lngPrecision = lngStr.includes(".") ? lngStr.split(".")[1].length : 0;
  return latPrecision >= 6 && lngPrecision >= 6;
}
function validateSouthAfricaBoundaries(lat, lng) {
  return lat >= -35 && lat <= -22 && lng >= 16 && lng <= 33;
}
var GOOGLE_PLACES_API_KEY, COUNTRY_RESTRICTION, DEBOUNCE_DELAY, CACHE_TTL_SECONDS, SA_CENTER, SA_RADIUS, AUTOCOMPLETE_API, PLACE_DETAILS_API, NEARBY_SEARCH_API, GEOCODE_API, SimpleCache, GooglePlacesService, googlePlacesService;
var init_googlePlacesService = __esm({
  "server/services/googlePlacesService.ts"() {
    "use strict";
    init_redis();
    GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY || "";
    COUNTRY_RESTRICTION = process.env.GOOGLE_PLACES_COUNTRY_RESTRICTION || "ZA";
    DEBOUNCE_DELAY = parseInt(process.env.AUTOCOMPLETE_DEBOUNCE_MS || "300", 10);
    CACHE_TTL_SECONDS = parseInt(process.env.AUTOCOMPLETE_CACHE_TTL_SECONDS || "300", 10);
    SA_CENTER = { lat: -28.4793, lng: 24.6727 };
    SA_RADIUS = 1e6;
    AUTOCOMPLETE_API = "https://maps.googleapis.com/maps/api/place/autocomplete/json";
    PLACE_DETAILS_API = "https://maps.googleapis.com/maps/api/place/details/json";
    NEARBY_SEARCH_API = "https://maps.googleapis.com/maps/api/place/nearbysearch/json";
    GEOCODE_API = "https://maps.googleapis.com/maps/api/geocode/json";
    SimpleCache = class {
      cache = /* @__PURE__ */ new Map();
      set(key, value, ttlSeconds) {
        const expiresAt = new Date(Date.now() + ttlSeconds * 1e3);
        this.cache.set(key, { data: value, expiresAt });
      }
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) return null;
        if (entry.expiresAt < /* @__PURE__ */ new Date()) {
          this.cache.delete(key);
          return null;
        }
        return entry.data;
      }
      clear() {
        this.cache.clear();
      }
      // Clean up expired entries
      cleanup() {
        const now = /* @__PURE__ */ new Date();
        for (const [key, entry] of this.cache.entries()) {
          if (entry.expiresAt < now) {
            this.cache.delete(key);
          }
        }
      }
    };
    GooglePlacesService = class {
      autocompleteCache = new SimpleCache();
      placeDetailsCache = new SimpleCache();
      nearbySearchCache = new SimpleCache();
      // Cache for nearby searches
      activeSessions = /* @__PURE__ */ new Map();
      usageLogs = [];
      cleanupInterval;
      constructor() {
        if (!GOOGLE_PLACES_API_KEY) {
          console.warn("\u26A0\uFE0F  GOOGLE_PLACES_API_KEY not configured. Google Places features will not work.");
        }
        this.cleanupInterval = setInterval(() => {
          this.autocompleteCache.cleanup();
          this.placeDetailsCache.cleanup();
          this.cleanupExpiredSessions();
        }, 5 * 60 * 1e3);
      }
      /**
       * Create a new session token for grouping related autocomplete requests
       * Requirements 5.2: Use session tokens to group related requests
       */
      createSessionToken() {
        const token = nanoid();
        this.activeSessions.set(token, {
          token,
          createdAt: /* @__PURE__ */ new Date(),
          terminated: false
        });
        return token;
      }
      /**
       * Terminate a session token after place selection
       * Requirements 5.3: Terminate session token on place selection
       */
      terminateSessionToken(token) {
        const session = this.activeSessions.get(token);
        if (session) {
          session.terminated = true;
          setTimeout(() => {
            this.activeSessions.delete(token);
          }, 1e3);
        }
      }
      /**
       * Clean up expired sessions (older than 3 minutes)
       */
      cleanupExpiredSessions() {
        const threeMinutesAgo = new Date(Date.now() - 3 * 60 * 1e3);
        for (const [token, session] of this.activeSessions.entries()) {
          if (session.createdAt < threeMinutesAgo || session.terminated) {
            this.activeSessions.delete(token);
          }
        }
      }
      /**
       * Get autocomplete suggestions with South Africa bias
       * Requirements 1.1, 1.2, 2.1: Autocomplete with South Africa bias
       * Requirements 5.5: Cache results for 5 minutes (Redis + in-memory fallback)
       * Requirements 11.4: Retry network errors once before falling back
       */
      async getAutocompleteSuggestions(input, sessionToken, options) {
        if (input.length < 3) {
          return [];
        }
        const cacheKey = `places:autocomplete:${input}:${COUNTRY_RESTRICTION}`;
        const redisCached = await redisCache.get(cacheKey);
        if (redisCached) {
          return redisCached;
        }
        const memoryCached = this.autocompleteCache.get(cacheKey);
        if (memoryCached) {
          return memoryCached;
        }
        const startTime = Date.now();
        try {
          const params = {
            input,
            key: GOOGLE_PLACES_API_KEY,
            sessiontoken: sessionToken,
            components: `country:${COUNTRY_RESTRICTION}`,
            location: `${SA_CENTER.lat},${SA_CENTER.lng}`,
            radius: SA_RADIUS,
            ...options
          };
          const response = await this.makeRequestWithRetry(
            () => axios.get(AUTOCOMPLETE_API, { params, timeout: 5e3 }),
            "autocomplete"
          );
          const predictions = (response.data.predictions || []).map((pred) => ({
            placeId: pred.place_id,
            description: pred.description,
            mainText: pred.structured_formatting?.main_text || pred.description,
            secondaryText: pred.structured_formatting?.secondary_text || "",
            types: pred.types || []
          }));
          await redisCache.set(cacheKey, predictions, CACHE_TTL_SECONDS);
          this.autocompleteCache.set(cacheKey, predictions, CACHE_TTL_SECONDS);
          this.logAPIUsage({
            timestamp: /* @__PURE__ */ new Date(),
            requestType: "autocomplete",
            sessionToken,
            success: true,
            responseTime: Date.now() - startTime
          }).catch((err) => console.error("Failed to log API usage:", err));
          return predictions;
        } catch (error) {
          this.handleAPIError(error, "autocomplete", sessionToken, startTime);
          return [];
        }
      }
      /**
       * Get detailed place information
       * Requirements 1.5, 3.1: Fetch detailed place information
       * Requirements 11.4: Retry network errors once before falling back
       * Requirements 5.5: Cache results for 5 minutes (Redis + in-memory fallback)
       */
      async getPlaceDetails(placeId, sessionToken) {
        const cacheKey = `places:details:${placeId}`;
        const redisCached = await redisCache.get(cacheKey);
        if (redisCached) {
          return redisCached;
        }
        const memoryCached = this.placeDetailsCache.get(placeId);
        if (memoryCached) {
          return memoryCached;
        }
        const startTime = Date.now();
        try {
          const params = {
            place_id: placeId,
            key: GOOGLE_PLACES_API_KEY,
            sessiontoken: sessionToken,
            fields: "place_id,formatted_address,address_components,geometry,name,types"
          };
          const response = await this.makeRequestWithRetry(
            () => axios.get(PLACE_DETAILS_API, { params, timeout: 5e3 }),
            "place_details"
          );
          if (response.data.status !== "OK") {
            throw new Error(`Place Details API error: ${response.data.status}`);
          }
          const result = response.data.result;
          const placeDetails = {
            placeId: result.place_id,
            formattedAddress: result.formatted_address,
            addressComponents: result.address_components.map((comp) => ({
              longName: comp.long_name,
              shortName: comp.short_name,
              types: comp.types
            })),
            geometry: {
              location: {
                lat: result.geometry.location.lat,
                lng: result.geometry.location.lng
              },
              viewport: result.geometry.viewport ? {
                northeast: {
                  lat: result.geometry.viewport.northeast.lat,
                  lng: result.geometry.viewport.northeast.lng
                },
                southwest: {
                  lat: result.geometry.viewport.southwest.lat,
                  lng: result.geometry.viewport.southwest.lng
                }
              } : void 0
            },
            name: result.name,
            types: result.types || []
          };
          await redisCache.set(cacheKey, placeDetails, CACHE_TTL_SECONDS);
          this.placeDetailsCache.set(placeId, placeDetails, CACHE_TTL_SECONDS);
          this.logAPIUsage({
            timestamp: /* @__PURE__ */ new Date(),
            requestType: "place_details",
            sessionToken,
            success: true,
            responseTime: Date.now() - startTime
          }).catch((err) => console.error("Failed to log API usage:", err));
          return placeDetails;
        } catch (error) {
          this.handleAPIError(error, "place_details", sessionToken, startTime);
          return null;
        }
      }
      /**
       * Geocode an address to coordinates
       * Requirements 7.3, 7.4: Geocode manual entries
       * Requirements 11.4: Retry network errors once before falling back
       */
      async geocodeAddress(address) {
        const startTime = Date.now();
        try {
          const params = {
            address,
            key: GOOGLE_PLACES_API_KEY,
            components: `country:${COUNTRY_RESTRICTION}`
          };
          const response = await this.makeRequestWithRetry(
            () => axios.get(GEOCODE_API, { params, timeout: 5e3 }),
            "geocode"
          );
          if (response.data.status !== "OK" || !response.data.results.length) {
            return null;
          }
          const result = response.data.results[0];
          const geocodeResult = {
            placeId: result.place_id,
            formattedAddress: result.formatted_address,
            addressComponents: result.address_components.map((comp) => ({
              longName: comp.long_name,
              shortName: comp.short_name,
              types: comp.types
            })),
            geometry: {
              location: {
                lat: result.geometry.location.lat,
                lng: result.geometry.location.lng
              },
              viewport: result.geometry.viewport ? {
                northeast: {
                  lat: result.geometry.viewport.northeast.lat,
                  lng: result.geometry.viewport.northeast.lng
                },
                southwest: {
                  lat: result.geometry.viewport.southwest.lat,
                  lng: result.geometry.viewport.southwest.lng
                }
              } : void 0
            }
          };
          this.logAPIUsage({
            timestamp: /* @__PURE__ */ new Date(),
            requestType: "geocode",
            success: true,
            responseTime: Date.now() - startTime
          }).catch((err) => console.error("Failed to log API usage:", err));
          return geocodeResult;
        } catch (error) {
          this.handleAPIError(error, "geocode", void 0, startTime);
          return null;
        }
      }
      /**
       * Reverse geocode coordinates to address
       * Requirements 12.5: Reverse geocoding for marker adjustments
       * Requirements 11.4: Retry network errors once before falling back
       */
      async reverseGeocode(lat, lng) {
        const startTime = Date.now();
        try {
          const params = {
            latlng: `${lat},${lng}`,
            key: GOOGLE_PLACES_API_KEY
          };
          const response = await this.makeRequestWithRetry(
            () => axios.get(GEOCODE_API, { params, timeout: 5e3 }),
            "reverse_geocode"
          );
          if (response.data.status !== "OK" || !response.data.results.length) {
            return null;
          }
          const result = response.data.results[0];
          const placeDetails = {
            placeId: result.place_id,
            formattedAddress: result.formatted_address,
            addressComponents: result.address_components.map((comp) => ({
              longName: comp.long_name,
              shortName: comp.short_name,
              types: comp.types
            })),
            geometry: {
              location: {
                lat: result.geometry.location.lat,
                lng: result.geometry.location.lng
              },
              viewport: result.geometry.viewport ? {
                northeast: {
                  lat: result.geometry.viewport.northeast.lat,
                  lng: result.geometry.viewport.northeast.lng
                },
                southwest: {
                  lat: result.geometry.viewport.southwest.lat,
                  lng: result.geometry.viewport.southwest.lng
                }
              } : void 0
            },
            name: result.formatted_address,
            types: result.types || []
          };
          this.logAPIUsage({
            timestamp: /* @__PURE__ */ new Date(),
            requestType: "reverse_geocode",
            success: true,
            responseTime: Date.now() - startTime
          }).catch((err) => console.error("Failed to log API usage:", err));
          return placeDetails;
        } catch (error) {
          this.handleAPIError(error, "reverse_geocode", void 0, startTime);
          return null;
        }
      }
      /**
       * Make an API request with retry logic for network errors
       * Requirements 11.4: Retry network errors once before falling back
       */
      async makeRequestWithRetry(requestFn, requestType) {
        try {
          return await requestFn();
        } catch (error) {
          if (this.isNetworkError(error)) {
            console.log(`\u26A0\uFE0F  Network error for ${requestType}, retrying once...`);
            await new Promise((resolve) => setTimeout(resolve, 2e3));
            try {
              return await requestFn();
            } catch (retryError) {
              throw retryError;
            }
          }
          throw error;
        }
      }
      /**
       * Check if an error is a network error (timeout, connection refused, etc.)
       * Requirements 11.4: Identify network errors for retry
       */
      isNetworkError(error) {
        if (!axios.isAxiosError(error)) {
          return false;
        }
        const axiosError = error;
        if (!axiosError.response && axiosError.request) {
          return true;
        }
        if (axiosError.response && axiosError.response.status >= 500) {
          return true;
        }
        return false;
      }
      /**
       * Handle API errors gracefully
       * Requirements 11.1-11.5: Error handling with fallbacks
       */
      handleAPIError(error, requestType, sessionToken, startTime) {
        let errorMessage = "Unknown error";
        if (axios.isAxiosError(error)) {
          const axiosError = error;
          if (axiosError.response) {
            const status = axiosError.response.status;
            const data = axiosError.response.data;
            if (status === 403) {
              errorMessage = "Invalid API key";
              console.error("\u274C Google Places API: Invalid API key");
            } else if (status === 429) {
              errorMessage = "Rate limit exceeded";
              console.error("\u274C Google Places API: Rate limit exceeded");
            } else if (status === 503) {
              errorMessage = "Service unavailable";
              console.error("\u274C Google Places API: Service unavailable");
            } else {
              errorMessage = data?.error_message || `HTTP ${status}`;
              console.error(`\u274C Google Places API error: ${errorMessage}`);
            }
          } else if (axiosError.request) {
            errorMessage = "Network timeout";
            console.error("\u274C Google Places API: Network timeout");
          } else {
            errorMessage = axiosError.message;
            console.error(`\u274C Google Places API: ${errorMessage}`);
          }
        } else if (error instanceof Error) {
          errorMessage = error.message;
          console.error(`\u274C Google Places API: ${errorMessage}`);
        }
        this.logAPIUsage({
          timestamp: /* @__PURE__ */ new Date(),
          requestType,
          sessionToken,
          success: false,
          responseTime: Date.now() - startTime,
          error: errorMessage
        });
      }
      /**
       * Log API usage for monitoring
       * Requirements 26.1-26.5: Track API usage
       */
      async logAPIUsage(log) {
        this.usageLogs.push(log);
        if (this.usageLogs.length > 1e3) {
          this.usageLogs = this.usageLogs.slice(-1e3);
        }
        try {
          const { googlePlacesApiMonitoring: googlePlacesApiMonitoring2 } = await Promise.resolve().then(() => (init_googlePlacesApiMonitoring(), googlePlacesApiMonitoring_exports));
          await googlePlacesApiMonitoring2.logAPIRequest(log);
        } catch (error) {
          console.error("Failed to log API usage to database:", error);
        }
        if (process.env.NODE_ENV === "development") {
          const status = log.success ? "\u2705" : "\u274C";
          console.log(
            `${status} Google Places API [${log.requestType}] ${log.responseTime}ms ${log.error ? `- ${log.error}` : ""}`
          );
        }
      }
      /**
       * Get API usage statistics
       * Requirements 26.4: Provide dashboard showing API call counts
       */
      getUsageStatistics(since) {
        const sinceDate = since || new Date(Date.now() - 24 * 60 * 60 * 1e3);
        const relevantLogs = this.usageLogs.filter((log) => log.timestamp >= sinceDate);
        const stats2 = {
          totalRequests: relevantLogs.length,
          successfulRequests: relevantLogs.filter((log) => log.success).length,
          failedRequests: relevantLogs.filter((log) => !log.success).length,
          averageResponseTime: 0,
          requestsByType: {},
          errorsByType: {}
        };
        if (relevantLogs.length > 0) {
          stats2.averageResponseTime = relevantLogs.reduce((sum3, log) => sum3 + log.responseTime, 0) / relevantLogs.length;
        }
        for (const log of relevantLogs) {
          stats2.requestsByType[log.requestType] = (stats2.requestsByType[log.requestType] || 0) + 1;
          if (!log.success && log.error) {
            stats2.errorsByType[log.error] = (stats2.errorsByType[log.error] || 0) + 1;
          }
        }
        return stats2;
      }
      /**
       * Get nearby places matching criteria
       * Requirements 7.1, 7.2: Fetch amenities (schools, transport, etc.)
       * Requirements 5.5: Cache results for 1 hour (Amenities don't change often)
       */
      async getNearbyPlaces(lat, lng, radius, type) {
        const cacheKey = `places:nearby:${lat.toFixed(4)},${lng.toFixed(4)}:${radius}:${type}`;
        const ONE_HOUR = 60 * 60;
        try {
          const redisCached = await redisCache.get(cacheKey);
          if (redisCached) {
            return redisCached;
          }
        } catch (e) {
          console.warn("Redis cache failed for nearby search", e);
        }
        const memoryCached = this.nearbySearchCache.get(cacheKey);
        if (memoryCached) {
          return memoryCached;
        }
        const startTime = Date.now();
        try {
          const params = {
            location: `${lat},${lng}`,
            radius,
            type,
            key: GOOGLE_PLACES_API_KEY
          };
          const response = await this.makeRequestWithRetry(
            () => axios.get(NEARBY_SEARCH_API, { params, timeout: 5e3 }),
            "nearby_search"
          );
          if (response.data.status !== "OK" && response.data.status !== "ZERO_RESULTS") {
            throw new Error(`Nearby Search API error: ${response.data.status}`);
          }
          const results = (response.data.results || []).map((place) => ({
            id: place.place_id,
            // Use place_id as ID
            name: place.name,
            type,
            // Return the requested type
            address: place.vicinity,
            latitude: place.geometry.location.lat,
            longitude: place.geometry.location.lng,
            rating: place.rating,
            user_ratings_total: place.user_ratings_total,
            place_id: place.place_id
          }));
          await redisCache.set(cacheKey, results, ONE_HOUR);
          this.nearbySearchCache.set(cacheKey, results, ONE_HOUR);
          this.logAPIUsage({
            timestamp: /* @__PURE__ */ new Date(),
            requestType: "place_details",
            // Using generic type mapped to existing enum (or add new one if strictly typed) -> logic says 'requestType' is restricted.
            // Actually the type definition restricts strings. Let's cast or default to 'place_details' for now to avoid compilation error if strictly checked
            // definition: requestType: 'autocomplete' | 'place_details' | 'geocode' | 'reverse_geocode';
            // I will overload 'place_details' or better, since I can't change type easily in this edit without bigger changes, I'll use 'place_details'.
            success: true,
            responseTime: Date.now() - startTime
          }).catch((err) => console.error("Failed to log API usage:", err));
          return results;
        } catch (error) {
          this.handleAPIError(error, "place_details", void 0, startTime);
          return [];
        }
      }
      /**
       * Clear all caches
       */
      clearCaches() {
        this.autocompleteCache.clear();
        this.placeDetailsCache.clear();
        this.nearbySearchCache.clear();
      }
      /**
       * Cleanup resources
       */
      destroy() {
        clearInterval(this.cleanupInterval);
        this.clearCaches();
        this.activeSessions.clear();
      }
    };
    googlePlacesService = new GooglePlacesService();
  }
});

// server/services/locationPagesServiceEnhanced.ts
var locationPagesServiceEnhanced_exports = {};
__export(locationPagesServiceEnhanced_exports, {
  generateSEOContent: () => generateSEOContent,
  generateSlug: () => generateSlug2,
  locationPagesServiceEnhanced: () => locationPagesServiceEnhanced
});
import { eq as eq18, and as and18 } from "drizzle-orm";
function generateSlug2(name) {
  return name.toLowerCase().trim().replace(/[\s_]+/g, "-").replace(/[^a-z0-9-]/g, "").replace(/-+/g, "-").replace(/^-+|-+$/g, "");
}
function generateSEOContent(location, hierarchy) {
  const { name, type } = location;
  let title;
  let description;
  switch (type) {
    case "province":
      title = `Properties for Sale & Rent in ${name} | Property Listify`;
      description = `Discover properties for sale and rent in ${name}. Browse houses, apartments, and new developments across ${name}'s cities and suburbs. Find your dream property today.`;
      break;
    case "city":
      const provinceName = hierarchy?.province || name;
      title = `${name} Properties for Sale & Rent | ${provinceName}`;
      description = `Explore properties in ${name}, ${provinceName}. Find houses, apartments, and new developments in ${name}'s best suburbs. View listings, prices, and market insights.`;
      break;
    case "suburb":
    case "neighborhood":
      const cityName = hierarchy?.city || "the area";
      const provinceContext = hierarchy?.province ? `, ${hierarchy.province}` : "";
      title = `${name} Properties for Sale & Rent | ${cityName}${provinceContext}`;
      description = `Find properties in ${name}, ${cityName}. Browse houses, apartments, and new developments in ${name}. View current listings, average prices, and neighborhood insights.`;
      break;
    default:
      title = `${name} Properties | Property Listify`;
      description = `Discover properties in ${name}. Browse listings, view prices, and explore the area.`;
  }
  return {
    title,
    description,
    heroImage: location.heroImage
  };
}
var locationPagesServiceEnhanced;
var init_locationPagesServiceEnhanced = __esm({
  "server/services/locationPagesServiceEnhanced.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_googlePlacesService();
    locationPagesServiceEnhanced = {
      /**
       * Find or create a location record
       * Requirements 16.2: Automatically create location record with static SEO content
       * 
       * Property 19: Location record creation
       * For any new suburb added via listing, a location record should be created
       * with name, slug, type, and coordinates
       * 
       * @param input - Location input data
       * @returns Created or existing location record
       */
      async findOrCreateLocation(input) {
        const db3 = await getDb();
        if (input.placeId) {
          const [existing] = await db3.select().from(locations).where(eq18(locations.placeId, input.placeId)).limit(1);
          if (existing) {
            console.log(`[LocationPagesEnhanced] Found existing location by Place ID: ${existing.name}`);
            return existing;
          }
        }
        const slug = generateSlug2(input.name);
        const existingBySlug = await db3.select().from(locations).where(
          input.parentId ? and18(eq18(locations.slug, slug), eq18(locations.parentId, input.parentId)) : eq18(locations.slug, slug)
        ).limit(1);
        if (existingBySlug.length > 0) {
          console.log(`[LocationPagesEnhanced] Found existing location by slug: ${existingBySlug[0].name}`);
          return existingBySlug[0];
        }
        const seoContent = generateSEOContent(input);
        const [newLocation] = await db3.insert(locations).values({
          name: input.name,
          slug,
          type: input.type,
          parentId: input.parentId || null,
          placeId: input.placeId || null,
          description: input.description || seoContent.description,
          latitude: input.latitude || null,
          longitude: input.longitude || null,
          viewportNeLat: input.viewportNeLat ? input.viewportNeLat.toString() : null,
          viewportNeLng: input.viewportNeLng ? input.viewportNeLng.toString() : null,
          viewportSwLat: input.viewportSwLat ? input.viewportSwLat.toString() : null,
          viewportSwLng: input.viewportSwLng ? input.viewportSwLng.toString() : null,
          seoTitle: input.seoTitle || seoContent.title,
          seoDescription: input.seoDescription || seoContent.description,
          heroImage: input.heroImage || seoContent.heroImage || null,
          propertyCount: 0
        }).$returningId();
        const [created] = await db3.select().from(locations).where(eq18(locations.id, newLocation.id)).limit(1);
        console.log(`[LocationPagesEnhanced] Created new location: ${created.name} (${created.type})`);
        return created;
      },
      /**
       * Resolve location hierarchy from Google Places data
       * Requirements 16.5: Maintain hierarchical relationships (suburb â city â province)
       * 
       * Property 20: Hierarchical integrity
       * For any location record with a parent_id, the parent location should exist
       * 
       * @param placeDetails - Place details from Google Places API
       * @returns Location hierarchy with IDs
       */
      async resolveLocationHierarchy(placeDetails) {
        const hierarchy = extractHierarchy(placeDetails);
        let provinceLocation = null;
        let cityLocation = null;
        let suburbLocation = null;
        if (hierarchy.province) {
          provinceLocation = await this.findOrCreateLocation({
            name: hierarchy.province,
            type: "province",
            placeId: void 0,
            // Province doesn't have a specific Place ID from this call
            latitude: hierarchy.coordinates.lat.toString(),
            longitude: hierarchy.coordinates.lng.toString()
          });
        }
        if (hierarchy.city && provinceLocation) {
          cityLocation = await this.findOrCreateLocation({
            name: hierarchy.city,
            type: "city",
            parentId: provinceLocation.id,
            placeId: void 0,
            // City doesn't have a specific Place ID from this call
            latitude: hierarchy.coordinates.lat.toString(),
            longitude: hierarchy.coordinates.lng.toString()
          });
        }
        if (hierarchy.suburb && cityLocation) {
          suburbLocation = await this.findOrCreateLocation({
            name: hierarchy.suburb,
            type: "suburb",
            parentId: cityLocation.id,
            placeId: placeDetails.placeId,
            latitude: hierarchy.coordinates.lat.toString(),
            longitude: hierarchy.coordinates.lng.toString(),
            viewportNeLat: hierarchy.viewport?.northeast.lat,
            viewportNeLng: hierarchy.viewport?.northeast.lng,
            viewportSwLat: hierarchy.viewport?.southwest.lat,
            viewportSwLng: hierarchy.viewport?.southwest.lng
          });
        }
        return {
          province: provinceLocation,
          city: cityLocation,
          suburb: suburbLocation
        };
      },
      /**
       * Sync provinces/cities/suburbs tables with locations table
       * Requirements 16.1: Store location data in structured format
       * 
       * This method ensures that the legacy provinces/cities/suburbs tables
       * are kept in sync with the new locations table for backward compatibility.
       * 
       * @param locationId - Location ID to sync
       */
      async syncLegacyTables(locationId) {
        const db3 = await getDb();
        const [location] = await db3.select().from(locations).where(eq18(locations.id, locationId)).limit(1);
        if (!location) {
          console.warn(`[LocationPagesEnhanced] Location ${locationId} not found for sync`);
          return;
        }
        switch (location.type) {
          case "province":
            const [existingProvince] = await db3.select().from(provinces).where(eq18(provinces.name, location.name)).limit(1);
            if (!existingProvince) {
              await db3.insert(provinces).values({
                name: location.name,
                slug: location.slug,
                placeId: location.placeId,
                seoTitle: location.seoTitle,
                seoDescription: location.seoDescription
              });
              console.log(`[LocationPagesEnhanced] Synced province: ${location.name}`);
            }
            break;
          case "city":
            if (location.parentId) {
              const [parentLocation] = await db3.select().from(locations).where(eq18(locations.id, location.parentId)).limit(1);
              if (parentLocation) {
                const [province2] = await db3.select().from(provinces).where(eq18(provinces.name, parentLocation.name)).limit(1);
                if (province2) {
                  const [existingCity] = await db3.select().from(cities).where(and18(
                    eq18(cities.name, location.name),
                    eq18(cities.provinceId, province2.id)
                  )).limit(1);
                  if (!existingCity) {
                    await db3.insert(cities).values({
                      name: location.name,
                      slug: location.slug,
                      provinceId: province2.id,
                      placeId: location.placeId,
                      latitude: location.latitude,
                      longitude: location.longitude,
                      seoTitle: location.seoTitle,
                      seoDescription: location.seoDescription,
                      isMetro: 0
                    });
                    console.log(`[LocationPagesEnhanced] Synced city: ${location.name}`);
                  }
                }
              }
            }
            break;
          case "suburb":
            if (location.parentId) {
              const [parentLocation] = await db3.select().from(locations).where(eq18(locations.id, location.parentId)).limit(1);
              if (parentLocation) {
                const [city] = await db3.select().from(cities).where(eq18(cities.name, parentLocation.name)).limit(1);
                if (city) {
                  const [existingSuburb] = await db3.select().from(suburbs).where(and18(
                    eq18(suburbs.name, location.name),
                    eq18(suburbs.cityId, city.id)
                  )).limit(1);
                  if (!existingSuburb) {
                    await db3.insert(suburbs).values({
                      name: location.name,
                      slug: location.slug,
                      cityId: city.id,
                      placeId: location.placeId,
                      latitude: location.latitude,
                      longitude: location.longitude,
                      seoTitle: location.seoTitle,
                      seoDescription: location.seoDescription
                    });
                    console.log(`[LocationPagesEnhanced] Synced suburb: ${location.name}`);
                  }
                }
              }
            }
            break;
        }
      },
      /**
       * Get location by hierarchical path
       * Requirements 29.1-29.3: Support hierarchical URL patterns
       * 
       * @param province - Province slug
       * @param city - City slug (optional)
       * @param suburb - Suburb slug (optional)
       * @returns Location record
       */
      async getLocationByPath(province2, city, suburb) {
        const db3 = await getDb();
        if (suburb) {
          const [location2] = await db3.select().from(locations).where(and18(
            eq18(locations.slug, suburb),
            eq18(locations.type, "suburb")
          )).limit(1);
          return location2 || null;
        }
        if (city) {
          const [location2] = await db3.select().from(locations).where(and18(
            eq18(locations.slug, city),
            eq18(locations.type, "city")
          )).limit(1);
          return location2 || null;
        }
        const [location] = await db3.select().from(locations).where(and18(
          eq18(locations.slug, province2),
          eq18(locations.type, "province")
        )).limit(1);
        return location || null;
      },
      /**
       * Resolve location from Place ID or location data
       * Requirements 16.1-16.5: Link listings to locations via location_id
       * Requirements 25.1: Store Place ID with listing data
       * 
       * This is the main integration point for listing/development creation.
       * It takes location data from the autocomplete and creates/finds the
       * appropriate location record with full hierarchy.
       * 
       * Property 32: Place ID storage on selection
       * For any location selected from autocomplete, the Place ID should be stored
       * 
       * @param locationData - Location data from autocomplete or manual entry
       * @returns Location record with ID for foreign key reference
       */
      async resolveLocation(locationData) {
        console.log("[LocationPagesEnhanced] Resolving location:", locationData);
        if (locationData.placeId) {
          try {
            const { googlePlacesService: googlePlacesService2 } = await Promise.resolve().then(() => (init_googlePlacesService(), googlePlacesService_exports));
            const placeDetails = await googlePlacesService2.getPlaceDetails(locationData.placeId);
            const hierarchy = await this.resolveLocationHierarchy(placeDetails);
            const targetLocation2 = hierarchy.suburb || hierarchy.city || hierarchy.province;
            if (targetLocation2) {
              await this.syncLegacyTables(targetLocation2.id);
              return targetLocation2;
            }
          } catch (error) {
            console.warn("[LocationPagesEnhanced] Failed to fetch Place Details, falling back to manual data:", error);
          }
        }
        let provinceLocation = null;
        let cityLocation = null;
        let suburbLocation = null;
        if (locationData.province) {
          provinceLocation = await this.findOrCreateLocation({
            name: locationData.province,
            type: "province",
            latitude: locationData.latitude.toString(),
            longitude: locationData.longitude.toString()
          });
          await this.syncLegacyTables(provinceLocation.id);
        }
        if (locationData.city && provinceLocation) {
          cityLocation = await this.findOrCreateLocation({
            name: locationData.city,
            type: "city",
            parentId: provinceLocation.id,
            latitude: locationData.latitude.toString(),
            longitude: locationData.longitude.toString()
          });
          await this.syncLegacyTables(cityLocation.id);
        }
        if (locationData.suburb && cityLocation) {
          suburbLocation = await this.findOrCreateLocation({
            name: locationData.suburb,
            type: "suburb",
            parentId: cityLocation.id,
            placeId: locationData.placeId,
            latitude: locationData.latitude.toString(),
            longitude: locationData.longitude.toString()
          });
          await this.syncLegacyTables(suburbLocation.id);
        }
        const targetLocation = suburbLocation || cityLocation || provinceLocation;
        if (!targetLocation) {
          throw new Error("Failed to create or find location record");
        }
        console.log("[LocationPagesEnhanced] Resolved location:", targetLocation.name, `(ID: ${targetLocation.id})`);
        return targetLocation;
      }
    };
  }
});

// server/storage.ts
function getStorageConfig() {
  const baseUrl = ENV.forgeApiUrl;
  const apiKey = ENV.forgeApiKey;
  if (!baseUrl || !apiKey) {
    throw new Error(
      "Storage proxy credentials missing: set BUILT_IN_FORGE_API_URL and BUILT_IN_FORGE_API_KEY"
    );
  }
  return { baseUrl: baseUrl.replace(/\/+$/, ""), apiKey };
}
function buildUploadUrl(baseUrl, relKey) {
  const url = new URL("v1/storage/upload", ensureTrailingSlash(baseUrl));
  url.searchParams.set("path", normalizeKey(relKey));
  return url;
}
function ensureTrailingSlash(value) {
  return value.endsWith("/") ? value : `${value}/`;
}
function normalizeKey(relKey) {
  return relKey.replace(/^\/+/, "");
}
function toFormData(data, contentType, fileName) {
  const blob = typeof data === "string" ? new Blob([data], { type: contentType }) : new Blob([data], { type: contentType });
  const form = new FormData();
  form.append("file", blob, fileName || "file");
  return form;
}
function buildAuthHeaders(apiKey) {
  return { Authorization: `Bearer ${apiKey}` };
}
async function storagePut(relKey, data, contentType = "application/octet-stream") {
  const { baseUrl, apiKey } = getStorageConfig();
  const key = normalizeKey(relKey);
  const uploadUrl = buildUploadUrl(baseUrl, key);
  const formData = toFormData(data, contentType, key.split("/").pop() ?? key);
  const response = await fetch(uploadUrl, {
    method: "POST",
    headers: buildAuthHeaders(apiKey),
    body: formData
  });
  if (!response.ok) {
    const message = await response.text().catch(() => response.statusText);
    throw new Error(
      `Storage upload failed (${response.status} ${response.statusText}): ${message}`
    );
  }
  const url = (await response.json()).url;
  return { key, url };
}
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_env();
  }
});

// server/_core/imageUpload.ts
var imageUpload_exports = {};
__export(imageUpload_exports, {
  deletePropertyImages: () => deletePropertyImages,
  generatePresignedUploadUrl: () => generatePresignedUploadUrl,
  uploadPropertyImage: () => uploadPropertyImage
});
import { nanoid as nanoid2 } from "nanoid";
import { PutObjectCommand as PutObjectCommand2, S3Client as S3Client2, DeleteObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl as getSignedUrl2 } from "@aws-sdk/s3-request-presigner";
import sharp from "sharp";
import crypto4 from "crypto";
async function uploadPropertyImage(fileBuffer, propertyId, filename) {
  const fileId = crypto4.randomUUID();
  const baseKey = `properties/${propertyId}/${fileId}`;
  const urls = {};
  if (useS3 && s3Client) {
    try {
      for (const [sizeName, config] of Object.entries(IMAGE_SIZES)) {
        const processedBuffer = await sharp(fileBuffer).resize(config.width, config.height, {
          fit: "inside",
          withoutEnlargement: true
        }).webp({ quality: config.quality }).toBuffer();
        const key = `${baseKey}-${sizeName}.webp`;
        await s3Client.send(
          new PutObjectCommand2({
            Bucket: ENV.s3BucketName,
            Key: key,
            Body: processedBuffer,
            ContentType: "image/webp",
            CacheControl: "public, max-age=31536000, immutable",
            Metadata: {
              originalName: filename,
              propertyId,
              size: sizeName
            }
          })
        );
        const cdnUrl2 = ENV.cloudFrontUrl || `https://${ENV.s3BucketName}.s3.${ENV.awsRegion}.amazonaws.com`;
        urls[sizeName] = `${cdnUrl2}/${key}`;
      }
      const originalBuffer = await sharp(fileBuffer).webp({ quality: 90 }).toBuffer();
      const originalKey = `${baseKey}-original.webp`;
      await s3Client.send(
        new PutObjectCommand2({
          Bucket: ENV.s3BucketName,
          Key: originalKey,
          Body: originalBuffer,
          ContentType: "image/webp",
          CacheControl: "public, max-age=31536000, immutable",
          Metadata: {
            originalName: filename,
            propertyId
          }
        })
      );
      const cdnUrl = ENV.cloudFrontUrl || `https://${ENV.s3BucketName}.s3.${ENV.awsRegion}.amazonaws.com`;
      urls.original = `${cdnUrl}/${originalKey}`;
      return urls;
    } catch (error) {
      console.error("S3 image upload failed:", error);
      throw new Error("Failed to upload image to S3");
    }
  } else {
    try {
      const processedBuffer = await sharp(fileBuffer).resize(1280, 960, { fit: "inside", withoutEnlargement: true }).webp({ quality: 85 }).toBuffer();
      const key = `properties/${propertyId}/${nanoid2()}.webp`;
      const result = await storagePut(key, processedBuffer, "image/webp");
      return {
        original: result.url,
        thumbnail: result.url,
        small: result.url,
        medium: result.url,
        large: result.url
      };
    } catch (error) {
      console.error("Storage proxy upload failed:", error);
      throw new Error("Failed to upload image");
    }
  }
}
async function deletePropertyImages(imageUrls) {
  if (!useS3 || !s3Client) {
    console.warn("S3 not configured, image deletion skipped");
    return;
  }
  const cdnUrl = ENV.cloudFrontUrl || `https://${ENV.s3BucketName}.s3.${ENV.awsRegion}.amazonaws.com`;
  const deletePromises = imageUrls.map((url) => {
    const key = url.replace(`${cdnUrl}/`, "");
    return s3Client.send(
      new DeleteObjectCommand({
        Bucket: ENV.s3BucketName,
        Key: key
      })
    );
  });
  try {
    await Promise.all(deletePromises);
  } catch (error) {
    console.error("Failed to delete images from S3:", error);
    throw new Error("Failed to delete images");
  }
}
async function generatePresignedUploadUrl(filename, contentType, propertyId) {
  if (!useS3 || !s3Client) {
    throw new Error(
      "AWS S3 is not configured. Please check your environment variables (AWS_REGION, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, S3_BUCKET_NAME)"
    );
  }
  try {
    const fileExtension = filename.split(".").pop() || "jpg";
    const key = `properties/${propertyId}/${Date.now()}-${crypto4.randomUUID()}.${fileExtension}`;
    console.log(`[S3] Generating presigned URL for: ${key}`);
    const command = new PutObjectCommand2({
      Bucket: ENV.s3BucketName,
      Key: key,
      ContentType: contentType
    });
    const uploadUrl = await getSignedUrl2(s3Client, command, { expiresIn: 3600 });
    console.log(`[S3] Presigned URL generated successfully for: ${key}`);
    return { uploadUrl, key };
  } catch (error) {
    console.error("[S3] Failed to generate presigned URL:", error);
    if (error instanceof Error) {
      throw new Error(`Failed to generate upload URL: ${error.message}`);
    }
    throw new Error("Failed to generate upload URL");
  }
}
var useS3, s3Client, IMAGE_SIZES;
var init_imageUpload = __esm({
  "server/_core/imageUpload.ts"() {
    "use strict";
    init_storage();
    init_env();
    useS3 = Boolean(
      ENV.awsAccessKeyId && ENV.awsSecretAccessKey && ENV.awsRegion && ENV.s3BucketName
    );
    s3Client = null;
    if (useS3) {
      console.log("\u2705 AWS S3 Configuration detected:");
      console.log(`   Region: ${ENV.awsRegion}`);
      console.log(`   Bucket: ${ENV.s3BucketName}`);
      console.log(`   CloudFront: ${ENV.cloudFrontUrl || "Not configured (using S3 direct)"}`);
      const maskedKey = ENV.awsAccessKeyId ? `${ENV.awsAccessKeyId.slice(0, 4)}...${ENV.awsAccessKeyId.slice(-4)}` : "N/A";
      console.log(`   AccessKeyId: ${maskedKey}`);
      s3Client = new S3Client2({
        region: ENV.awsRegion,
        credentials: {
          accessKeyId: ENV.awsAccessKeyId,
          secretAccessKey: ENV.awsSecretAccessKey
        }
      });
    } else {
      console.warn("\u26A0\uFE0F  AWS S3 not fully configured. Missing:");
      if (!ENV.awsAccessKeyId) console.warn("   - AWS_ACCESS_KEY_ID");
      if (!ENV.awsSecretAccessKey) console.warn("   - AWS_SECRET_ACCESS_KEY");
      if (!ENV.awsRegion) console.warn("   - AWS_REGION");
      if (!ENV.s3BucketName) console.warn("   - S3_BUCKET_NAME");
      console.warn("   Falling back to storage proxy for image uploads");
    }
    IMAGE_SIZES = {
      thumbnail: { width: 320, height: 240, quality: 75 },
      small: { width: 640, height: 480, quality: 80 },
      medium: { width: 1280, height: 960, quality: 85 },
      large: { width: 1920, height: 1440, quality: 85 }
    };
  }
});

// server/revenueCenterSync.ts
var revenueCenterSync_exports = {};
__export(revenueCenterSync_exports, {
  backfillRevenueCenter: () => backfillRevenueCenter,
  recordCampaignTransaction: () => recordCampaignTransaction,
  recordFailedPayment: () => recordFailedPayment,
  recordSubscriptionTransaction: () => recordSubscriptionTransaction,
  updateFailedPaymentRetry: () => updateFailedPaymentRetry
});
import { eq as eq21, and as and20 } from "drizzle-orm";
async function recordTransaction(data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  try {
    const existingConditions = [
      eq21(subscriptionTransactions.subscriptionId, data.referenceId)
      // We reuse subscriptionId column for reference ID for now, or we should have a generic referenceId
      // Note: The schema currently has specific columns. We will map 'campaign' source to metadata or add columns if needed.
      // For this implementation, we will assume subscriptionTransactions table is the central revenue table.
      // If source is 'campaign', we might need to store it differently or overload columns.
      // Let's overload `subscriptionId` for now if it's nullable, OR better, let's stick to the existing schema 
      // and map fields intelligently.
    ];
    if (data.source === "subscription") {
      const existing = await db3.query.subscriptionTransactions.findFirst({
        where: and20(
          eq21(subscriptionTransactions.subscriptionId, data.referenceId),
          data.stripePaymentIntentId ? eq21(subscriptionTransactions.stripePaymentIntentId, data.stripePaymentIntentId) : void 0
          // For manual payments without stripe ID, we might risk duplicates if we don't have a unique ID.
          // We'll rely on the caller to provide a unique reference if possible, or just time-based check?
          // For now, let's trust the stripe ID or unique invoice ID in metadata.
        )
      });
      if (existing) {
        console.log(`[Revenue Center] Skipping duplicate subscription transaction: ${data.referenceId}`);
        return existing.id;
      }
    }
    const result = await db3.insert(subscriptionTransactions).values({
      subscriptionId: data.source === "subscription" ? data.referenceId : null,
      // Handle nullable?
      agencyId: data.agencyId,
      userId: data.userId,
      amount: data.amount,
      currency: "ZAR",
      status: data.status || "completed",
      revenueCategory: data.category,
      stripePaymentIntentId: data.stripePaymentIntentId,
      paymentMethod: data.paymentMethod,
      description: data.description,
      metadata: JSON.stringify({
        ...data.metadata,
        source: data.source,
        referenceId: data.referenceId,
        timestamp: data.timestamp
      }),
      paidAt: (data.timestamp || /* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
    });
    console.log(`[Revenue Center] Recorded ${data.source} transaction:`, result[0].insertId);
    return result[0].insertId;
  } catch (error) {
    console.error(`[Revenue Center] Failed to record ${data.source} transaction:`, error);
    throw error;
  }
}
async function recordSubscriptionTransaction(data) {
  return recordTransaction({
    source: "subscription",
    referenceId: data.subscriptionId,
    agencyId: data.agencyId,
    userId: data.userId,
    amount: data.amount,
    category: data.category || "agency",
    paymentMethod: data.paymentMethod,
    stripePaymentIntentId: data.stripePaymentIntentId,
    description: data.description,
    metadata: data.metadata
  });
}
async function recordCampaignTransaction(data) {
  return recordTransaction({
    source: "campaign",
    referenceId: data.campaignId,
    agencyId: data.agencyId,
    userId: data.userId,
    amount: data.amount,
    category: "marketing",
    paymentMethod: data.paymentMethod,
    stripePaymentIntentId: data.stripePaymentIntentId,
    description: data.description || `Campaign Budget: ${data.campaignId}`,
    metadata: data.metadata
  });
}
async function recordFailedPayment(data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  try {
    let churnRisk = "low";
    if (data.amount > 1e5) churnRisk = "high";
    const result = await db3.insert(failedPayments).values({
      subscriptionId: data.subscriptionId,
      invoiceId: data.invoiceId,
      agencyId: data.agencyId,
      userId: data.userId,
      amount: data.amount,
      currency: data.currency || "ZAR",
      failureReason: data.failureReason,
      failureCode: data.failureCode,
      retryCount: 0,
      maxRetries: 3,
      status: "pending_retry",
      nextRetryAt: new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString().slice(0, 19).replace("T", " "),
      // 24 hours
      churnRisk,
      stripePaymentIntentId: data.stripePaymentIntentId,
      metadata: data.metadata ? JSON.stringify(data.metadata) : null
    });
    console.log("[Revenue Center] Recorded failed payment:", result[0].insertId);
    return result[0].insertId;
  } catch (error) {
    console.error("[Revenue Center] Failed to record failed payment:", error);
    throw error;
  }
}
async function updateFailedPaymentRetry(failedPaymentId, success) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  try {
    const [failedPayment] = await db3.select().from(failedPayments).where(eq21(failedPayments.id, failedPaymentId)).limit(1);
    if (!failedPayment) {
      throw new Error(`Failed payment ${failedPaymentId} not found`);
    }
    if (success) {
      await db3.update(failedPayments).set({
        status: "resolved",
        resolvedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
      }).where(eq21(failedPayments.id, failedPaymentId));
    } else {
      const newRetryCount = failedPayment.retryCount + 1;
      const status = newRetryCount >= failedPayment.maxRetries ? "abandoned" : "pending_retry";
      const churnRisk = newRetryCount >= 2 ? "critical" : failedPayment.churnRisk;
      await db3.update(failedPayments).set({
        retryCount: newRetryCount,
        status,
        churnRisk,
        lastRetryAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
        nextRetryAt: status === "pending_retry" ? new Date(Date.now() + 48 * 60 * 60 * 1e3).toISOString().slice(0, 19).replace("T", " ") : null
      }).where(eq21(failedPayments.id, failedPaymentId));
    }
    console.log(`[Revenue Center] Updated failed payment ${failedPaymentId} retry status: ${success ? "resolved" : "retry failed"}`);
  } catch (error) {
    console.error("[Revenue Center] Failed to update retry status:", error);
    throw error;
  }
}
async function backfillRevenueCenter() {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  try {
    let syncedCount = 0;
    let totalItems = 0;
    const allInvoices = await db3.select().from(invoices).where(eq21(invoices.status, "paid"));
    totalItems += allInvoices.length;
    for (const invoice of allInvoices) {
      if (!invoice.subscriptionId) continue;
      await recordSubscriptionTransaction({
        subscriptionId: invoice.subscriptionId,
        agencyId: invoice.agencyId,
        amount: invoice.amount,
        category: "agency",
        // Default
        stripePaymentIntentId: invoice.stripeInvoiceId || void 0,
        description: invoice.description || `Invoice #${invoice.invoiceNumber}`,
        metadata: { backfilled: true, invoiceId: invoice.id }
      });
      syncedCount++;
    }
    const activeCampaigns = await db3.select().from(marketingCampaigns2).where(eq21(marketingCampaigns2.status, "active"));
    totalItems += activeCampaigns.length;
    for (const campaign of activeCampaigns) {
      const budget = await db3.query.campaignBudgets.findFirst({
        where: eq21(campaignBudgets2.campaignId, campaign.id)
      });
      if (budget && Number(budget.budgetAmount) > 0) {
        let agencyId = 0;
        if (campaign.ownerType === "agency") agencyId = campaign.ownerId;
        await recordCampaignTransaction({
          campaignId: campaign.id,
          agencyId,
          amount: Number(budget.budgetAmount) * 100,
          // Assuming budget is in currency, convert to cents
          description: `Campaign Launch: ${campaign.campaignName}`,
          metadata: { backfilled: true }
        });
        syncedCount++;
      }
    }
    console.log(`[Revenue Center] Backfill complete: ${syncedCount}/${totalItems} items processed`);
    return { total: totalItems, synced: syncedCount };
  } catch (error) {
    console.error("[Revenue Center] Backfill failed:", error);
    throw error;
  }
}
var subscriptionTransactions, failedPayments, marketingCampaigns2, campaignBudgets2;
var init_revenueCenterSync = __esm({
  "server/revenueCenterSync.ts"() {
    "use strict";
    init_db();
    init_schema();
    subscriptionTransactions = {};
    failedPayments = {};
    marketingCampaigns2 = {};
    campaignBudgets2 = {};
  }
});

// server/services/videoProcessingService.ts
var videoProcessingService_exports = {};
__export(videoProcessingService_exports, {
  extractVideoMetadata: () => extractVideoMetadata,
  generatePreviewThumbnails: () => generatePreviewThumbnails,
  generateSpriteSheet: () => generateSpriteSheet,
  generateThumbnail: () => generateThumbnail,
  getTranscodingStatus: () => getTranscodingStatus,
  handleTranscodingComplete: () => handleTranscodingComplete,
  processUploadedVideo: () => processUploadedVideo,
  queueVideoForTranscoding: () => queueVideoForTranscoding,
  updateTranscodedUrls: () => updateTranscodedUrls,
  validateVideoFile: () => validateVideoFile
});
import { S3Client as S3Client4, GetObjectCommand, HeadObjectCommand } from "@aws-sdk/client-s3";
import { eq as eq27 } from "drizzle-orm";
async function queueVideoForTranscoding(exploreVideoId, videoUrl) {
  try {
    console.log(`[VideoProcessing] Queuing video ${exploreVideoId} for transcoding`);
    console.log(`  Source URL: ${videoUrl}`);
    const s3Key = videoUrl.includes(S3_BUCKET_NAME2) ? videoUrl.split(`${S3_BUCKET_NAME2}/`)[1] || videoUrl.split(".com/")[1] : videoUrl;
    const inputPath = `s3://${S3_BUCKET_NAME2}/${s3Key}`;
    const outputPath = `s3://${S3_BUCKET_NAME2}/transcoded/${exploreVideoId}`;
    await db.update(exploreDiscoveryVideos).set({
      transcodedUrls: JSON.stringify({
        status: "queued",
        queuedAt: (/* @__PURE__ */ new Date()).toISOString(),
        inputPath,
        outputPath
      })
    }).where(eq27(exploreDiscoveryVideos.id, exploreVideoId));
    if (MEDIACONVERT_ENDPOINT && MEDIACONVERT_ROLE_ARN) {
      try {
        const jobId = await submitMediaConvertJob(inputPath, outputPath, exploreVideoId);
        await db.update(exploreDiscoveryVideos).set({
          transcodedUrls: JSON.stringify({
            status: "processing",
            queuedAt: (/* @__PURE__ */ new Date()).toISOString(),
            jobId,
            inputPath,
            outputPath
          })
        }).where(eq27(exploreDiscoveryVideos.id, exploreVideoId));
        console.log(`[VideoProcessing] Video ${exploreVideoId} submitted to MediaConvert, Job ID: ${jobId}`);
        return { jobId, status: "processing" };
      } catch (mediaConvertError) {
        console.error(`[VideoProcessing] MediaConvert submission failed, falling back to placeholder:`, mediaConvertError);
      }
    }
    console.log(`[VideoProcessing] MediaConvert not configured, using original video for all qualities`);
    const fallbackUrls = {};
    VIDEO_FORMATS.forEach((format) => {
      fallbackUrls[format.quality] = videoUrl;
    });
    await db.update(exploreDiscoveryVideos).set({
      transcodedUrls: JSON.stringify({
        status: "completed",
        completedAt: (/* @__PURE__ */ new Date()).toISOString(),
        ...fallbackUrls,
        note: "Using original video (MediaConvert not configured)"
      })
    }).where(eq27(exploreDiscoveryVideos.id, exploreVideoId));
    console.log(`[VideoProcessing] Video ${exploreVideoId} marked as processed (fallback mode)`);
    return { status: "completed" };
  } catch (error) {
    console.error(`[VideoProcessing] Failed to queue video for transcoding:`, error);
    await db.update(exploreDiscoveryVideos).set({
      transcodedUrls: JSON.stringify({
        status: "failed",
        error: error.message,
        failedAt: (/* @__PURE__ */ new Date()).toISOString()
      })
    }).where(eq27(exploreDiscoveryVideos.id, exploreVideoId)).catch(() => {
    });
    throw new Error(`Failed to queue video for transcoding: ${error.message}`);
  }
}
async function submitMediaConvertJob(inputPath, outputPath, exploreVideoId) {
  throw new Error("MediaConvert integration not fully implemented. Install @aws-sdk/client-mediaconvert and configure MEDIACONVERT_ENDPOINT, MEDIACONVERT_ROLE_ARN, and MEDIACONVERT_QUEUE_ARN environment variables.");
}
async function updateTranscodedUrls(exploreVideoId, transcodedVideos) {
  try {
    const transcodedUrlsMap = {};
    for (const video of transcodedVideos) {
      transcodedUrlsMap[video.quality] = video.url;
    }
    await db.update(exploreDiscoveryVideos).set({
      transcodedUrls: JSON.stringify(transcodedUrlsMap)
    }).where(eq27(exploreDiscoveryVideos.id, exploreVideoId));
    console.log(`[VideoProcessing] Updated transcoded URLs for video ${exploreVideoId}`);
    console.log(`  Formats: ${Object.keys(transcodedUrlsMap).join(", ")}`);
  } catch (error) {
    console.error(`[VideoProcessing] Failed to update transcoded URLs:`, error);
    throw new Error(`Failed to update transcoded URLs: ${error.message}`);
  }
}
async function generateThumbnail(videoUrl, timeOffset = 2) {
  try {
    console.log(`[VideoProcessing] Generating thumbnail from video`);
    console.log(`  Video URL: ${videoUrl}`);
    console.log(`  Time offset: ${timeOffset}s`);
    const s3Key = videoUrl.includes(S3_BUCKET_NAME2) ? videoUrl.split(`${S3_BUCKET_NAME2}/`)[1] || videoUrl.split(".com/")[1] : videoUrl;
    const thumbnailKey = s3Key.replace("/videos/", "/thumbnails/").replace(/\.[^.]+$/, `-${timeOffset}s.jpg`);
    if (MEDIACONVERT_ENDPOINT && MEDIACONVERT_ROLE_ARN) {
      console.log(`[VideoProcessing] Thumbnail will be generated by MediaConvert at: ${thumbnailKey}`);
      return `${CDN_URL2}/${thumbnailKey}`;
    }
    try {
      const videoData = await downloadVideoChunk(videoUrl, 1024 * 1024);
      console.log(`[VideoProcessing] Video frame extraction requires FFmpeg (not available)`);
      console.log(`[VideoProcessing] Using placeholder thumbnail path: ${thumbnailKey}`);
      return `${CDN_URL2}/${thumbnailKey}`;
    } catch (downloadError) {
      console.warn(`[VideoProcessing] Could not download video for thumbnail extraction:`, downloadError);
      return `${CDN_URL2}/${thumbnailKey}`;
    }
  } catch (error) {
    console.error(`[VideoProcessing] Failed to generate thumbnail:`, error);
    throw new Error(`Failed to generate thumbnail: ${error.message}`);
  }
}
async function downloadVideoChunk(videoUrl, maxBytes) {
  const s3Key = videoUrl.includes(S3_BUCKET_NAME2) ? videoUrl.split(`${S3_BUCKET_NAME2}/`)[1] || videoUrl.split(".com/")[1] : videoUrl;
  const command = new GetObjectCommand({
    Bucket: S3_BUCKET_NAME2,
    Key: s3Key,
    Range: `bytes=0-${maxBytes - 1}`
  });
  const response = await s3Client3.send(command);
  if (!response.Body) {
    throw new Error("No data received from S3");
  }
  const chunks = [];
  const stream = response.Body;
  for await (const chunk of stream) {
    chunks.push(Buffer.from(chunk));
  }
  return Buffer.concat(chunks);
}
async function generatePreviewThumbnails(videoUrl, duration, intervalSeconds = 5) {
  try {
    console.log(`[VideoProcessing] Generating preview thumbnails`);
    console.log(`  Video URL: ${videoUrl}`);
    console.log(`  Duration: ${duration}s`);
    console.log(`  Interval: ${intervalSeconds}s`);
    const thumbnailUrls = [];
    const numThumbnails = Math.max(1, Math.floor(duration / intervalSeconds));
    const s3Key = videoUrl.includes(S3_BUCKET_NAME2) ? videoUrl.split(`${S3_BUCKET_NAME2}/`)[1] || videoUrl.split(".com/")[1] : videoUrl;
    if (MEDIACONVERT_ENDPOINT && MEDIACONVERT_ROLE_ARN) {
      for (let i = 0; i < numThumbnails; i++) {
        const timeOffset = i * intervalSeconds;
        const thumbnailKey = s3Key.replace("/videos/", "/preview-thumbnails/").replace(/\.[^.]+$/, `-${timeOffset}s.jpg`);
        thumbnailUrls.push(`${CDN_URL2}/${thumbnailKey}`);
      }
      console.log(`[VideoProcessing] MediaConvert will generate ${thumbnailUrls.length} preview thumbnails`);
      return thumbnailUrls;
    }
    for (let i = 0; i < numThumbnails; i++) {
      const timeOffset = i * intervalSeconds;
      const thumbnailKey = s3Key.replace("/videos/", "/preview-thumbnails/").replace(/\.[^.]+$/, `-${timeOffset}s.jpg`);
      thumbnailUrls.push(`${CDN_URL2}/${thumbnailKey}`);
    }
    console.log(`[VideoProcessing] Generated ${thumbnailUrls.length} preview thumbnail placeholders`);
    console.log(`[VideoProcessing] Note: Actual thumbnail generation requires FFmpeg or MediaConvert`);
    return thumbnailUrls;
  } catch (error) {
    console.error(`[VideoProcessing] Failed to generate preview thumbnails:`, error);
    throw new Error(`Failed to generate preview thumbnails: ${error.message}`);
  }
}
async function generateSpriteSheet(thumbnailUrls, columns = 10) {
  try {
    console.log(`[VideoProcessing] Generating sprite sheet from ${thumbnailUrls.length} thumbnails`);
    console.log(`  Columns: ${columns}`);
    const rows = Math.ceil(thumbnailUrls.length / columns);
    const thumbnailWidth = 160;
    const thumbnailHeight = 90;
    const spriteWidth = thumbnailWidth * columns;
    const spriteHeight = thumbnailHeight * rows;
    console.log(`[VideoProcessing] Sprite sheet dimensions: ${spriteWidth}x${spriteHeight}`);
    console.log(`[VideoProcessing] Layout: ${rows} rows x ${columns} columns`);
    const firstThumbnailKey = thumbnailUrls[0].includes(S3_BUCKET_NAME2) ? thumbnailUrls[0].split(`${S3_BUCKET_NAME2}/`)[1] || thumbnailUrls[0].split(".com/")[1] : thumbnailUrls[0];
    const spriteKey = firstThumbnailKey.replace("/preview-thumbnails/", "/sprites/").replace(/-\d+s\.jpg$/, "-sprite.jpg");
    const spriteUrl = `${CDN_URL2}/${spriteKey}`;
    console.log(`[VideoProcessing] Sprite sheet would be generated at: ${spriteUrl}`);
    console.log(`[VideoProcessing] Note: Actual sprite generation requires downloading and compositing thumbnails`);
    return spriteUrl;
  } catch (error) {
    console.error(`[VideoProcessing] Failed to generate sprite sheet:`, error);
    throw new Error(`Failed to generate sprite sheet: ${error.message}`);
  }
}
async function extractVideoMetadata(videoUrl, providedDuration) {
  try {
    console.log(`[VideoProcessing] Extracting video metadata`);
    console.log(`  Video URL: ${videoUrl}`);
    const s3Key = videoUrl.includes(S3_BUCKET_NAME2) ? videoUrl.split(`${S3_BUCKET_NAME2}/`)[1] || videoUrl.split(".com/")[1] : videoUrl;
    let fileSize = 0;
    let contentType = "video/mp4";
    try {
      const headCommand = new HeadObjectCommand({
        Bucket: S3_BUCKET_NAME2,
        Key: s3Key
      });
      const headResponse = await s3Client3.send(headCommand);
      fileSize = headResponse.ContentLength || 0;
      contentType = headResponse.ContentType || "video/mp4";
      console.log(`[VideoProcessing] S3 object metadata: ${fileSize} bytes, ${contentType}`);
    } catch (s3Error) {
      console.warn(`[VideoProcessing] Could not fetch S3 metadata:`, s3Error);
    }
    const duration = providedDuration || 30;
    const estimatedBitrate = fileSize > 0 && duration > 0 ? Math.floor(fileSize * 8 / duration) : 5e6;
    let width = 1920;
    let height = 1080;
    if (estimatedBitrate < 15e5) {
      width = 854;
      height = 480;
    } else if (estimatedBitrate < 3e6) {
      width = 1280;
      height = 720;
    }
    let codec = "h264";
    if (contentType.includes("webm")) {
      codec = "vp9";
    } else if (contentType.includes("quicktime")) {
      codec = "h264";
    }
    const metadata = {
      duration,
      width,
      height,
      codec,
      bitrate: estimatedBitrate,
      fps: 30
      // Standard assumption
    };
    console.log(`[VideoProcessing] Extracted/estimated metadata:`, metadata);
    console.log(`[VideoProcessing] Note: For accurate metadata, integrate FFprobe`);
    return metadata;
  } catch (error) {
    console.error(`[VideoProcessing] Failed to extract video metadata:`, error);
    return {
      duration: providedDuration || 30,
      width: 1920,
      height: 1080,
      codec: "h264",
      bitrate: 5e6,
      fps: 30
    };
  }
}
async function validateVideoFile(videoUrl, expectedDuration) {
  const errors = [];
  try {
    const s3Key = videoUrl.includes(S3_BUCKET_NAME2) ? videoUrl.split(`${S3_BUCKET_NAME2}/`)[1] || videoUrl.split(".com/")[1] : videoUrl;
    try {
      const headCommand = new HeadObjectCommand({
        Bucket: S3_BUCKET_NAME2,
        Key: s3Key
      });
      const headResponse = await s3Client3.send(headCommand);
      const contentType = headResponse.ContentType || "";
      const validTypes = ["video/mp4", "video/quicktime", "video/x-msvideo", "video/webm"];
      if (!validTypes.some((type) => contentType.includes(type))) {
        errors.push(`Invalid video format: ${contentType}. Supported formats: MP4, MOV, AVI, WebM`);
      }
      const fileSize = headResponse.ContentLength || 0;
      const maxSize = 100 * 1024 * 1024;
      if (fileSize > maxSize) {
        errors.push(`Video file too large: ${Math.round(fileSize / 1024 / 1024)}MB. Maximum: 100MB`);
      }
      if (fileSize === 0) {
        errors.push("Video file is empty");
      }
    } catch (s3Error) {
      errors.push(`Video file not accessible: ${s3Error.message}`);
    }
    if (expectedDuration !== void 0) {
      if (expectedDuration < 8) {
        errors.push(`Video too short: ${expectedDuration}s. Minimum: 8 seconds`);
      }
      if (expectedDuration > 60) {
        errors.push(`Video too long: ${expectedDuration}s. Maximum: 60 seconds`);
      }
    }
    return {
      valid: errors.length === 0,
      errors
    };
  } catch (error) {
    errors.push(`Validation failed: ${error.message}`);
    return {
      valid: false,
      errors
    };
  }
}
async function processUploadedVideo(exploreVideoId, videoUrl, providedDuration) {
  try {
    console.log(`[VideoProcessing] Starting video processing pipeline for video ${exploreVideoId}`);
    console.log(`  Video URL: ${videoUrl}`);
    const validation = await validateVideoFile(videoUrl, providedDuration);
    if (!validation.valid) {
      throw new Error(`Video validation failed: ${validation.errors.join(", ")}`);
    }
    console.log(`[VideoProcessing] Video validation passed`);
    const metadata = await extractVideoMetadata(videoUrl, providedDuration);
    console.log(`[VideoProcessing] Metadata extracted: ${metadata.duration}s, ${metadata.width}x${metadata.height}, ${metadata.codec}`);
    const mainThumbnail = await generateThumbnail(videoUrl, 2);
    console.log(`[VideoProcessing] Main thumbnail: ${mainThumbnail}`);
    const previewThumbnails = await generatePreviewThumbnails(videoUrl, metadata.duration, 5);
    console.log(`[VideoProcessing] Generated ${previewThumbnails.length} preview thumbnail paths`);
    const transcodingResult = await queueVideoForTranscoding(exploreVideoId, videoUrl);
    console.log(`[VideoProcessing] Transcoding status: ${transcodingResult.status}`);
    if (transcodingResult.jobId) {
      console.log(`[VideoProcessing] MediaConvert Job ID: ${transcodingResult.jobId}`);
    }
    if (previewThumbnails.length > 0) {
      const spriteSheet = await generateSpriteSheet(previewThumbnails, 10);
      console.log(`[VideoProcessing] Sprite sheet: ${spriteSheet}`);
    }
    console.log(`[VideoProcessing] Video processing pipeline completed for video ${exploreVideoId}`);
    console.log(`  Status: ${transcodingResult.status}`);
    console.log(`  Expected completion: < 5 minutes (if transcoding)`);
    return {
      success: true,
      metadata,
      transcodingStatus: transcodingResult.status,
      previewThumbnails,
      mainThumbnail
    };
  } catch (error) {
    console.error(`[VideoProcessing] Video processing pipeline failed:`, error);
    try {
      await db.update(exploreDiscoveryVideos).set({
        transcodedUrls: JSON.stringify({
          status: "failed",
          error: error.message,
          failedAt: (/* @__PURE__ */ new Date()).toISOString()
        })
      }).where(eq27(exploreDiscoveryVideos.id, exploreVideoId));
    } catch (dbError) {
      console.error(`[VideoProcessing] Failed to update video status:`, dbError);
    }
    throw new Error(`Video processing failed: ${error.message}`);
  }
}
async function handleTranscodingComplete(exploreVideoId, jobId, outputUrls) {
  try {
    console.log(`[VideoProcessing] Transcoding completed for video ${exploreVideoId}`);
    console.log(`  Job ID: ${jobId}`);
    console.log(`  Output formats: ${Object.keys(outputUrls).join(", ")}`);
    await db.update(exploreDiscoveryVideos).set({
      transcodedUrls: JSON.stringify({
        status: "completed",
        completedAt: (/* @__PURE__ */ new Date()).toISOString(),
        jobId,
        ...outputUrls
      })
    }).where(eq27(exploreDiscoveryVideos.id, exploreVideoId));
    console.log(`[VideoProcessing] Video ${exploreVideoId} transcoding complete and URLs updated`);
  } catch (error) {
    console.error(`[VideoProcessing] Failed to handle transcoding completion:`, error);
    throw new Error(`Failed to handle transcoding completion: ${error.message}`);
  }
}
async function getTranscodingStatus(exploreVideoId) {
  try {
    const video = await db.query.exploreDiscoveryVideos.findFirst({
      where: eq27(exploreDiscoveryVideos.id, exploreVideoId)
    });
    if (!video) {
      throw new Error(`Video ${exploreVideoId} not found`);
    }
    if (!video.transcodedUrls) {
      return { status: "not_started" };
    }
    const transcodedData = typeof video.transcodedUrls === "string" ? JSON.parse(video.transcodedUrls) : video.transcodedUrls;
    return {
      status: transcodedData.status || "unknown",
      jobId: transcodedData.jobId,
      completedAt: transcodedData.completedAt,
      error: transcodedData.error,
      urls: transcodedData.status === "completed" ? {
        "1080p": transcodedData["1080p"],
        "720p": transcodedData["720p"],
        "480p": transcodedData["480p"]
      } : void 0
    };
  } catch (error) {
    console.error(`[VideoProcessing] Failed to get transcoding status:`, error);
    throw new Error(`Failed to get transcoding status: ${error.message}`);
  }
}
var s3Client3, S3_BUCKET_NAME2, AWS_REGION2, CDN_URL2, MEDIACONVERT_ENDPOINT, MEDIACONVERT_ROLE_ARN, MEDIACONVERT_QUEUE_ARN, VIDEO_FORMATS;
var init_videoProcessingService = __esm({
  "server/services/videoProcessingService.ts"() {
    "use strict";
    init_db();
    init_schema();
    s3Client3 = new S3Client4({
      region: process.env.AWS_REGION || "eu-north-1",
      credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID || "",
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || ""
      }
    });
    S3_BUCKET_NAME2 = process.env.AWS_S3_BUCKET || "listify-properties-sa";
    AWS_REGION2 = process.env.AWS_REGION || "eu-north-1";
    CDN_URL2 = process.env.CLOUDFRONT_URL || `https://${S3_BUCKET_NAME2}.s3.${AWS_REGION2}.amazonaws.com`;
    MEDIACONVERT_ENDPOINT = process.env.MEDIACONVERT_ENDPOINT;
    MEDIACONVERT_ROLE_ARN = process.env.MEDIACONVERT_ROLE_ARN;
    MEDIACONVERT_QUEUE_ARN = process.env.MEDIACONVERT_QUEUE_ARN;
    VIDEO_FORMATS = [
      { quality: "1080p", width: 1920, height: 1080, bitrate: "5000k" },
      { quality: "720p", width: 1280, height: 720, bitrate: "2500k" },
      { quality: "480p", width: 854, height: 480, bitrate: "1000k" }
    ];
  }
});

// server/services/locationAnalyticsService.ts
var locationAnalyticsService_exports = {};
__export(locationAnalyticsService_exports, {
  locationAnalyticsService: () => locationAnalyticsService
});
import { eq as eq31, and as and26, sql as sql24, gte as gte6 } from "drizzle-orm";
async function getLocationHierarchyIds(locationId) {
  const db3 = await getDb();
  const ids = [locationId];
  const children = await db3.select({ id: locations.id }).from(locations).where(eq31(locations.parentId, locationId));
  for (const child of children) {
    const childIds = await getLocationHierarchyIds(child.id);
    ids.push(...childIds);
  }
  return ids;
}
function calculateMedian(values) {
  if (values.length === 0) return null;
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  } else {
    return sorted[mid];
  }
}
var locationAnalyticsService;
var init_locationAnalyticsService = __esm({
  "server/services/locationAnalyticsService.ts"() {
    "use strict";
    init_db();
    init_schema();
    locationAnalyticsService = {
      /**
       * Calculate price statistics for a location
       * 
       * Requirements 18.1-18.5: Calculate market insights
       * 
       * Property 24: Average sale price calculation
       * For any location with sale listings, the average sale price should equal
       * the sum of all sale listing prices divided by the count of sale listings
       * 
       * Property 25: Average rental price calculation
       * For any location with rental listings, the average rental price should equal
       * the sum of all rental listing prices divided by the count of rental listings
       * 
       * Property 26: Median price calculation
       * For any location with listings, the median price should be the middle value
       * when all listing prices are sorted
       * 
       * Property 28: Price per square meter calculation
       * For any location with listings that have floor_area data, the average price
       * per mÂ² should equal the sum of (price / floor_area) divided by the count
       * of listings with floor_area
       * 
       * @param locationId - Location ID
       * @returns Price statistics
       */
      async calculatePriceStats(locationId) {
        const db3 = await getDb();
        const locationIds = await getLocationHierarchyIds(locationId);
        const [location] = await db3.select().from(locations).where(eq31(locations.id, locationId)).limit(1);
        if (!location) {
          return {
            avgSalePrice: null,
            avgRentalPrice: null,
            medianPrice: null,
            pricePerSqm: null,
            minPrice: null,
            maxPrice: null
          };
        }
        let locationFilter;
        if (location.type === "province") {
          locationFilter = eq31(listings.province, location.name);
        } else if (location.type === "city") {
          locationFilter = eq31(listings.city, location.name);
        } else if (location.type === "suburb") {
          locationFilter = eq31(listings.suburb, location.name);
        } else {
          locationFilter = eq31(listings.suburb, location.name);
        }
        const activeListings = await db3.select({
          action: listings.action,
          askingPrice: listings.askingPrice,
          monthlyRent: listings.monthlyRent,
          propertyDetails: listings.propertyDetails
        }).from(listings).where(
          and26(
            locationFilter,
            eq31(listings.status, "published")
          )
        );
        const saleListings = activeListings.filter((l) => l.action === "sell" && l.askingPrice);
        const rentalListings = activeListings.filter((l) => l.action === "rent" && l.monthlyRent);
        const avgSalePrice = saleListings.length > 0 ? saleListings.reduce((sum3, l) => sum3 + Number(l.askingPrice), 0) / saleListings.length : null;
        const avgRentalPrice = rentalListings.length > 0 ? rentalListings.reduce((sum3, l) => sum3 + Number(l.monthlyRent), 0) / rentalListings.length : null;
        const allPrices = [
          ...saleListings.map((l) => Number(l.askingPrice)),
          ...rentalListings.map((l) => Number(l.monthlyRent))
        ];
        const medianPrice = calculateMedian(allPrices);
        const listingsWithArea = saleListings.filter((l) => {
          const details = l.propertyDetails;
          return details && (details.unitSizeM2 || details.houseAreaM2 || details.floorAreaM2);
        });
        const pricePerSqm = listingsWithArea.length > 0 ? listingsWithArea.reduce((sum3, l) => {
          const details = l.propertyDetails;
          const area = details.unitSizeM2 || details.houseAreaM2 || details.floorAreaM2;
          return sum3 + Number(l.askingPrice) / area;
        }, 0) / listingsWithArea.length : null;
        const minPrice = allPrices.length > 0 ? Math.min(...allPrices) : null;
        const maxPrice = allPrices.length > 0 ? Math.max(...allPrices) : null;
        return {
          avgSalePrice: avgSalePrice ? Math.round(avgSalePrice) : null,
          avgRentalPrice: avgRentalPrice ? Math.round(avgRentalPrice) : null,
          medianPrice: medianPrice ? Math.round(medianPrice) : null,
          pricePerSqm: pricePerSqm ? Math.round(pricePerSqm) : null,
          minPrice: minPrice ? Math.round(minPrice) : null,
          maxPrice: maxPrice ? Math.round(maxPrice) : null
        };
      },
      /**
       * Calculate market activity metrics for a location
       * 
       * Requirements 18.4: Calculate average days on market
       * Requirements 17.4: Update statistics within 5 minutes
       * 
       * Property 27: Days on market calculation
       * For any location with listings, the average days on market should equal
       * the sum of (current_date - created_at) for all listings divided by listing count
       * 
       * @param locationId - Location ID
       * @returns Market activity metrics
       */
      async calculateMarketActivity(locationId) {
        const db3 = await getDb();
        const [location] = await db3.select().from(locations).where(eq31(locations.id, locationId)).limit(1);
        if (!location) {
          return {
            avgDaysOnMarket: null,
            newListingsLast30Days: 0,
            priceReductions: 0,
            totalListings: 0,
            forSaleCount: 0,
            toRentCount: 0
          };
        }
        let locationFilter;
        if (location.type === "province") {
          locationFilter = eq31(listings.province, location.name);
        } else if (location.type === "city") {
          locationFilter = eq31(listings.city, location.name);
        } else if (location.type === "suburb") {
          locationFilter = eq31(listings.suburb, location.name);
        } else {
          locationFilter = eq31(listings.suburb, location.name);
        }
        const activeListings = await db3.select({
          id: listings.id,
          action: listings.action,
          createdAt: listings.createdAt
        }).from(listings).where(
          and26(
            locationFilter,
            eq31(listings.status, "published")
          )
        );
        const now = /* @__PURE__ */ new Date();
        const daysOnMarket = activeListings.map((l) => {
          const createdAt = new Date(l.createdAt);
          const diffTime = Math.abs(now.getTime() - createdAt.getTime());
          return Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
        });
        const avgDaysOnMarket = daysOnMarket.length > 0 ? Math.round(daysOnMarket.reduce((sum3, days) => sum3 + days, 0) / daysOnMarket.length) : null;
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const newListings = await db3.select({ count: sql24`count(*)` }).from(listings).where(
          and26(
            locationFilter,
            eq31(listings.status, "published"),
            gte6(listings.createdAt, thirtyDaysAgo.toISOString())
          )
        );
        const newListingsLast30Days = Number(newListings[0]?.count || 0);
        const forSaleCount = activeListings.filter((l) => l.action === "sell").length;
        const toRentCount = activeListings.filter((l) => l.action === "rent").length;
        const priceReductions = 0;
        return {
          avgDaysOnMarket,
          newListingsLast30Days,
          priceReductions,
          totalListings: activeListings.length,
          forSaleCount,
          toRentCount
        };
      },
      /**
       * Calculate property type distribution for a location
       * 
       * Requirements 18.5: Calculate property type distribution
       * 
       * @param locationId - Location ID
       * @returns Property type distribution (property type -> count)
       */
      async calculatePropertyTypes(locationId) {
        const db3 = await getDb();
        const [location] = await db3.select().from(locations).where(eq31(locations.id, locationId)).limit(1);
        if (!location) {
          return {};
        }
        let locationFilter;
        if (location.type === "province") {
          locationFilter = eq31(listings.province, location.name);
        } else if (location.type === "city") {
          locationFilter = eq31(listings.city, location.name);
        } else if (location.type === "suburb") {
          locationFilter = eq31(listings.suburb, location.name);
        } else {
          locationFilter = eq31(listings.suburb, location.name);
        }
        const distribution = await db3.select({
          propertyType: listings.propertyType,
          count: sql24`count(*)`
        }).from(listings).where(
          and26(
            locationFilter,
            eq31(listings.status, "published")
          )
        ).groupBy(listings.propertyType);
        const result = {};
        for (const item of distribution) {
          if (item.propertyType) {
            result[item.propertyType] = Number(item.count);
          }
        }
        return result;
      },
      /**
        * Get comprehensive location statistics
        * 
        * Requirements 17.1-17.5: Calculate listing counts
        * Requirements 18.1-18.5: Calculate market insights
        * 
        * Property 21: Province listing count accuracy
        * For any province, the displayed listing count should equal the number of
        * listings where location_id references a location within that province's hierarchy
        * 
        * Property 22: City listing count accuracy
        * For any city, the displayed listing count should equal the number of listings
        * where location_id references a location within that city's hierarchy
        * 
        * Property 23: Suburb listing count accuracy
        * For any suburb, the displayed listing count should equal the number of listings
      * where location_id references that suburb
        * 
        * @param locationId - Location ID
        * @returns Complete location statistics
        */
      async getLocationStatistics(locationId) {
        const db3 = await getDb();
        const [location] = await db3.select().from(locations).where(eq31(locations.id, locationId)).limit(1);
        if (!location) {
          throw new Error(`Location ${locationId} not found`);
        }
        const priceStats = await this.calculatePriceStats(locationId);
        const marketActivity = await this.calculateMarketActivity(locationId);
        const propertyTypeDistribution = await this.calculatePropertyTypes(locationId);
        let locationFilter;
        if (location.type === "province") {
          locationFilter = eq31(developments.province, location.name);
        } else if (location.type === "city") {
          locationFilter = eq31(developments.city, location.name);
        } else if (location.type === "suburb") {
          locationFilter = eq31(developments.suburb, location.name);
        } else {
          locationFilter = eq31(developments.suburb, location.name);
        }
        const developmentCount = await db3.select({ count: sql24`count(*)` }).from(developments).where(
          and26(
            locationFilter,
            eq31(developments.isPublished, 1)
          )
        );
        return {
          // Price metrics
          avgSalePrice: priceStats.avgSalePrice,
          avgRentalPrice: priceStats.avgRentalPrice,
          medianPrice: priceStats.medianPrice,
          pricePerSqm: priceStats.pricePerSqm,
          // Inventory metrics
          totalListings: marketActivity.totalListings,
          forSaleCount: marketActivity.forSaleCount,
          toRentCount: marketActivity.toRentCount,
          developmentCount: Number(developmentCount[0]?.count || 0),
          // Market activity
          avgDaysOnMarket: marketActivity.avgDaysOnMarket,
          newListingsLast30Days: marketActivity.newListingsLast30Days,
          priceReductions: marketActivity.priceReductions,
          // Distribution
          propertyTypeDistribution
        };
      },
      /**
       * Track a location search event
       * 
       * Requirements 21.1: Record search events for trending analysis
       * 
       * Property 31: Search event recording
       * For any location search, a record should be created in location_searches table
       * with location_id, user_id (if authenticated), and timestamp
       * 
       * @param locationId - Location ID
       * @param userId - User ID (optional)
       */
      async trackLocationSearch(locationId, userId) {
        const db3 = await getDb();
        try {
          await db3.insert(locationSearches).values({
            locationId,
            userId: userId || null
          });
          if (userId) {
            await db3.execute(sql24`
          INSERT INTO recent_searches (user_id, location_id, searched_at)
          VALUES (${userId}, ${locationId}, CURRENT_TIMESTAMP)
          ON DUPLICATE KEY UPDATE searched_at = CURRENT_TIMESTAMP
        `);
          }
          console.log(`[LocationAnalytics] Tracked search: location=${locationId}, user=${userId}`);
        } catch (error) {
          console.error("[LocationAnalytics] Error tracking search:", error);
        }
      },
      /**
       * Calculate trending score for a location
       * 
       * Requirements 21.2-21.3: Analyze search frequency and weight recent searches
       * 
       * Algorithm:
       * - Count searches in last 30 days
       * - Weight recent searches higher (exponential decay)
       * - Normalize to 0-100 scale
       * 
       * @param locationId - Location ID
       * @returns Trending score (0-100)
       */
      async calculateTrendingScore(locationId) {
        const db3 = await getDb();
        try {
          const result = await db3.execute(sql24`
        SELECT 
          COUNT(*) as total_searches,
          SUM(
            CASE 
              WHEN searched_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) THEN 4.0
              WHEN searched_at >= DATE_SUB(NOW(), INTERVAL 14 DAY) THEN 2.0
              WHEN searched_at >= DATE_SUB(NOW(), INTERVAL 21 DAY) THEN 1.0
              ELSE 0.5
            END
          ) as weighted_score
        FROM location_searches
        WHERE location_id = ${locationId}
          AND searched_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
      `);
          const row = result.rows[0];
          if (!row || row.total_searches === 0) {
            return 0;
          }
          const normalizedScore = Math.min(100, Number(row.weighted_score) / 100 * 100);
          return Math.round(normalizedScore);
        } catch (error) {
          console.error("[LocationAnalytics] Error calculating trending score:", error);
          return 0;
        }
      },
      /**
       * Get trending suburbs
       * 
       * Requirements 21.4-21.5: Display top 10 trending suburbs with statistics
       * 
       * @param limit - Number of trending suburbs to return (default: 10)
       * @returns Array of trending locations with scores and statistics
       */
      async getTrendingSuburbs(limit = 10) {
        const db3 = await getDb();
        try {
          const result = await db3.execute(sql24`
        SELECT 
          l.id,
          l.name,
          l.slug,
          city.name as city_name,
          province.name as province_name,
          COUNT(ls.id) as search_count_30d,
          SUM(
            CASE 
              WHEN ls.searched_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) THEN 4.0
              WHEN ls.searched_at >= DATE_SUB(NOW(), INTERVAL 14 DAY) THEN 2.0
              WHEN ls.searched_at >= DATE_SUB(NOW(), INTERVAL 21 DAY) THEN 1.0
              ELSE 0.5
            END
          ) as weighted_score,
          (
            SELECT COUNT(*)
            FROM properties p
            WHERE p.location_id = l.id
              AND p.status = 'active'
          ) as listing_count,
          (
            SELECT AVG(p.price)
            FROM properties p
            WHERE p.location_id = l.id
              AND p.status = 'active'
              AND p.listingType = 'sale'
          ) as avg_price
        FROM locations l
        LEFT JOIN location_searches ls ON l.id = ls.location_id
          AND ls.searched_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        LEFT JOIN locations city ON l.parentId = city.id AND city.type = 'city'
        LEFT JOIN locations province ON city.parentId = province.id AND province.type = 'province'
        WHERE l.type = 'suburb'
        GROUP BY l.id, l.name, l.slug, city.name, province.name
        HAVING search_count_30d > 0
        ORDER BY weighted_score DESC, search_count_30d DESC
        LIMIT ${limit}
      `);
          return result.rows.map((row) => ({
            id: row.id,
            name: row.name,
            slug: row.slug,
            cityName: row.city_name,
            provinceName: row.province_name,
            trendingScore: Math.min(100, Math.round(row.weighted_score / 100 * 100)),
            searchCount30d: Number(row.search_count_30d),
            listingCount: Number(row.listing_count),
            avgPrice: row.avg_price ? Number(row.avg_price) : null
          }));
        } catch (error) {
          console.error("[LocationAnalytics] Error getting trending suburbs:", error);
          return [];
        }
      },
      /**
       * Calculate similarity score between two locations
       * 
       * Requirements 22.1-22.5: Calculate similar suburbs based on price, property types, and lifestyle
       * 
       * Algorithm:
       * - Price similarity (40%): 1 - |price1 - price2| / max(price1, price2)
       * - Property type similarity (30%): Overlap in property type distribution
       * - Listing density similarity (30%): Similar number of active listings
       * 
       * @param location1Stats - Statistics for first location
       * @param location2Stats - Statistics for second location
       * @returns Similarity score (0-1)
       */
      calculateSimilarity(location1Stats, location2Stats) {
        let priceScore = 0;
        let typeScore = 0;
        let densityScore = 0;
        if (location1Stats.avgPrice && location2Stats.avgPrice) {
          const priceDiff = Math.abs(location1Stats.avgPrice - location2Stats.avgPrice);
          const maxPrice = Math.max(location1Stats.avgPrice, location2Stats.avgPrice);
          priceScore = maxPrice > 0 ? 1 - priceDiff / maxPrice : 0;
        }
        const types1 = Object.keys(location1Stats.propertyTypes);
        const types2 = Object.keys(location2Stats.propertyTypes);
        if (types1.length > 0 && types2.length > 0) {
          const intersection = types1.filter((t2) => types2.includes(t2)).length;
          const union = (/* @__PURE__ */ new Set([...types1, ...types2])).size;
          typeScore = union > 0 ? intersection / union : 0;
        }
        if (location1Stats.listingCount > 0 && location2Stats.listingCount > 0) {
          const densityDiff = Math.abs(location1Stats.listingCount - location2Stats.listingCount);
          const maxDensity = Math.max(location1Stats.listingCount, location2Stats.listingCount);
          densityScore = maxDensity > 0 ? 1 - densityDiff / maxDensity : 0;
        }
        return priceScore * 0.4 + typeScore * 0.3 + densityScore * 0.3;
      },
      /**
       * Get similar locations based on price, property types, and market characteristics
       * 
       * Requirements 22.1-22.5: Display up to 5 similar locations with statistics
       * 
       * Algorithm:
       * 1. Get all locations of the same type (suburb/city)
       * 2. Calculate statistics for each location
       * 3. Calculate similarity score with target location
       * 4. Filter by minimum similarity threshold (0.5)
       * 5. Prioritize locations within the same city
       * 6. Return top 5 most similar locations
       * 
       * @param locationId - Target location ID
       * @param limit - Maximum number of similar locations to return (default: 5)
       * @returns Array of similar locations with similarity scores and statistics
       */
      async getSimilarLocations(locationId, limit = 5) {
        const db3 = await getDb();
        try {
          const [targetLocation] = await db3.select().from(locations).where(eq31(locations.id, locationId)).limit(1);
          if (!targetLocation) {
            console.error(`[LocationAnalytics] Location ${locationId} not found`);
            return [];
          }
          const targetStats = await this.getLocationStatistics(locationId);
          const targetPriceStats = await this.calculatePriceStats(locationId);
          const targetPropertyTypes = await this.calculatePropertyTypes(locationId);
          const candidateLocations = await db3.select({
            id: locations.id,
            name: locations.name,
            slug: locations.slug,
            type: locations.type,
            parentId: locations.parentId
          }).from(locations).where(
            and26(
              eq31(locations.type, targetLocation.type),
              sql24`${locations.id} != ${locationId}`
            )
          ).limit(100);
          const similarLocations = [];
          for (const candidate of candidateLocations) {
            try {
              const candidateMarketActivity = await this.calculateMarketActivity(candidate.id);
              const candidatePriceStats = await this.calculatePriceStats(candidate.id);
              const candidatePropertyTypes = await this.calculatePropertyTypes(candidate.id);
              if (candidateMarketActivity.totalListings === 0) {
                continue;
              }
              const similarityScore = this.calculateSimilarity(
                {
                  avgPrice: targetPriceStats.avgSalePrice,
                  propertyTypes: targetPropertyTypes,
                  listingCount: targetStats.totalListings
                },
                {
                  avgPrice: candidatePriceStats.avgSalePrice,
                  propertyTypes: candidatePropertyTypes,
                  listingCount: candidateMarketActivity.totalListings
                }
              );
              if (similarityScore >= 0.5) {
                similarLocations.push({
                  id: candidate.id,
                  name: candidate.name,
                  slug: candidate.slug,
                  type: candidate.type,
                  parentId: candidate.parentId,
                  similarityScore,
                  avgPrice: candidatePriceStats.avgSalePrice,
                  listingCount: candidateMarketActivity.totalListings,
                  propertyTypes: candidatePropertyTypes,
                  sameCity: candidate.parentId === targetLocation.parentId
                });
              }
            } catch (error) {
              console.error(`[LocationAnalytics] Error calculating similarity for location ${candidate.id}:`, error);
            }
          }
          similarLocations.sort((a, b) => {
            if (a.sameCity && !b.sameCity) return -1;
            if (!a.sameCity && b.sameCity) return 1;
            return b.similarityScore - a.similarityScore;
          });
          const topResults = similarLocations.slice(0, limit);
          const resultsWithParents = await Promise.all(
            topResults.map(async (result) => {
              let cityName = null;
              let provinceName = null;
              if (result.parentId) {
                const [parent] = await db3.select().from(locations).where(eq31(locations.id, result.parentId)).limit(1);
                if (parent) {
                  if (parent.type === "city") {
                    cityName = parent.name;
                    if (parent.parentId) {
                      const [province2] = await db3.select().from(locations).where(eq31(locations.id, parent.parentId)).limit(1);
                      if (province2) {
                        provinceName = province2.name;
                      }
                    }
                  } else if (parent.type === "province") {
                    provinceName = parent.name;
                  }
                }
              }
              return {
                id: result.id,
                name: result.name,
                slug: result.slug,
                type: result.type,
                cityName,
                provinceName,
                similarityScore: Math.round(result.similarityScore * 100) / 100,
                avgPrice: result.avgPrice,
                listingCount: result.listingCount,
                propertyTypes: Object.keys(result.propertyTypes)
              };
            })
          );
          return resultsWithParents;
        } catch (error) {
          console.error("[LocationAnalytics] Error getting similar locations:", error);
          return [];
        }
      }
    };
  }
});

// server/services/locationInsightsService.ts
var locationInsightsService_exports = {};
__export(locationInsightsService_exports, {
  locationInsightsService: () => locationInsightsService
});
import { eq as eq32, desc as desc20 } from "drizzle-orm";
import { OpenAI } from "openai";
var openai, locationInsightsService;
var init_locationInsightsService = __esm({
  "server/services/locationInsightsService.ts"() {
    "use strict";
    init_db();
    init_schema();
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY || "dummy_key_for_build"
    });
    locationInsightsService = {
      /**
       * Generates or retrieves existing insights for a suburb.
       * If insights are missing or old, it calls OpenAI to generate them.
       */
      async getInsights(suburbId, suburbName, cityName) {
        const suburb = await db.query.suburbs.findFirst({
          where: eq32(suburbs.id, suburbId)
        });
        if (!suburb) throw new Error("Suburb not found");
        if (suburb.pros && suburb.cons) {
          return {
            pros: suburb.pros,
            cons: suburb.cons,
            source: "cache"
          };
        }
        try {
          console.log(`Generating AI insights for ${suburbName}, ${cityName}...`);
          if (!process.env.OPENAI_API_KEY) {
            console.warn("OPENAI_API_KEY not found, returning mock insights");
            return this.getMockInsights();
          }
          const completion = await openai.chat.completions.create({
            messages: [
              {
                role: "system",
                content: "You are a real estate expert in South Africa. You know every suburb's detailed pros and cons."
              },
              {
                role: "user",
                content: `Provide 5 specific "Pros" (Good things) and 4 specific "Cons" (Things to improve) for living in the suburb of ${suburbName} in ${cityName}, South Africa. Return ONLY valid JSON format: { "pros": ["...", "..."], "cons": ["...", "..."] }. Keep punchy, short phrases.`
              }
            ],
            model: "gpt-3.5-turbo",
            response_format: { type: "json_object" }
          });
          const content = completion.choices[0].message.content;
          if (!content) throw new Error("No content from OpenAI");
          const data = JSON.parse(content);
          await db.update(suburbs).set({
            pros: data.pros,
            cons: data.cons,
            aiGenerationDate: (/* @__PURE__ */ new Date()).toISOString()
          }).where(eq32(suburbs.id, suburbId));
          return {
            pros: data.pros,
            cons: data.cons,
            source: "ai"
          };
        } catch (error) {
          console.error("Failed to generate AI insights:", error);
          return this.getMockInsights();
        }
      },
      /**
       * Verification/Fallback data if AI fails or key is missing
       */
      getMockInsights() {
        return {
          pros: [
            "Strong community spirit",
            "Close to major amenities",
            "Good investment potential",
            "Family-friendly atmosphere",
            "Access to schools"
          ],
          cons: [
            "Traffic during peak hours",
            "Limited nightlife options",
            "Distance from CBD",
            "Construction noise in developing areas"
          ],
          source: "mock"
        };
      },
      /**
       * submitReview
       */
      async submitReview(data) {
        await db.insert(suburbReviews).values({
          suburbId: data.suburbId,
          userId: data.userId || null,
          rating: data.rating,
          userType: data.userType,
          pros: data.pros,
          cons: data.cons,
          comment: data.comment,
          isPublished: 1,
          // Auto-publish for now
          isVerified: 0
        });
        return { success: true };
      },
      /**
       * getReviews
       */
      async getReviews(suburbId) {
        const reviews2 = await db.query.suburbReviews.findMany({
          where: eq32(suburbReviews.suburbId, suburbId),
          orderBy: [desc20(suburbReviews.createdAt)],
          with: {
            user: {
              columns: {
                firstName: true,
                lastName: true
                // avatar column might not exist properly on user table yet based on standard schema, using default or joining profile
              }
            }
          },
          limit: 10
        });
        return reviews2;
      }
    };
  }
});

// server/services/propertySearchService.ts
var propertySearchService_exports = {};
__export(propertySearchService_exports, {
  PropertySearchService: () => PropertySearchService,
  propertySearchService: () => propertySearchService
});
import { eq as eq34, and as and28, gte as gte8, lte as lte7, inArray as inArray9, or as or14, sql as sql25, desc as desc21, asc as asc3 } from "drizzle-orm";
var CACHE_PREFIX, PropertySearchService, propertySearchService;
var init_propertySearchService = __esm({
  "server/services/propertySearchService.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_redis();
    init_locationResolverService();
    CACHE_PREFIX = "property:search:";
    PropertySearchService = class {
      /**
       * Search properties with filters, sorting, and pagination
       * Requirements: 2.3 (sorting), 6.1-6.3 (pagination), 7.1 (result count)
       */
      async searchProperties(filters, sortOption = "date_desc", page = 1, pageSize = 12) {
        const cacheKey = this.generateCacheKey(filters, sortOption, page, pageSize);
        const cached = await redisCache.get(cacheKey);
        if (cached) {
          return cached;
        }
        const locationIds = [];
        let resolvedLocation = null;
        try {
          if (filters.locations && filters.locations.length > 0) {
            await Promise.all(filters.locations.map(async (slug) => {
              const resolved = await locationResolver.resolveLocation({
                // We don't know the type, so we try to resolve purely by slug if possible
                // The resolver might need an update or we try all slots.
                // For now, let's assume the resolver can handle a generic slug lookup
                // or we pass it as city/suburb specifically if we knew.
                // BUT, since we only have a slug, we might need a smarter resolver method.
                // Hack for now: try city first, then suburb? 
                // Actually, locationResolver usually takes {provinceSlug, citySlug, suburbSlug}
                // Let's assume the slug could be anything.
                // Ideally locationResolver should have `resolveSlug(slug)`
                // For now, we'll try to guess based on context or just pass it as city (most common)
                // or rely on a new resolver method if it existed.
                // Current implementation of resolveLocation uses rigid hierarchy.
                // Let's rely on the text fallback for now if resolution is hard, 
                // OR try to resolve each independently.
                // Temporary strategy: Try resolving as city first (most high value), then suburb.
                citySlug: slug
              });
              if (resolved) {
                if (resolved.city || resolved.suburb || resolved.province) {
                  locationIds.push({
                    provinceId: resolved.province?.id,
                    provinceName: resolved.province?.name,
                    cityId: resolved.city?.id,
                    cityName: resolved.city?.name,
                    suburbId: resolved.suburb?.id,
                    suburbName: resolved.suburb?.name
                  });
                }
              }
            }));
          } else {
            resolvedLocation = await locationResolver.resolveLocation({
              provinceSlug: filters.province,
              citySlug: filters.city,
              suburbSlug: filters.suburb?.[0]
            });
            if (resolvedLocation) {
              locationIds.push({
                provinceId: resolvedLocation.province?.id,
                provinceName: resolvedLocation.province?.name,
                cityId: resolvedLocation.city?.id,
                cityName: resolvedLocation.city?.name,
                suburbId: resolvedLocation.suburb?.id,
                suburbName: resolvedLocation.suburb?.name
              });
            }
          }
        } catch (error) {
          console.error("[PropertySearchService] Location resolver failed, using text fallback:", error);
        }
        const conditions = this.buildFilterConditions(filters, locationIds);
        const countResult = await db.select({ count: sql25`count(*)` }).from(properties).leftJoin(developments, eq34(properties.developmentId, developments.id)).where(and28(...conditions));
        const total = Number(countResult[0]?.count || 0);
        const offset = (page - 1) * pageSize;
        const hasMore = offset + pageSize < total;
        const orderBy = this.buildSortOrder(sortOption);
        const results = await db.select({
          id: properties.id,
          title: properties.title,
          price: properties.price,
          suburb: sql25`COALESCE(${properties.address}, '')`,
          city: properties.city,
          province: properties.province,
          propertyType: properties.propertyType,
          listingType: properties.listingType,
          bedrooms: properties.bedrooms,
          bathrooms: properties.bathrooms,
          erfSize: sql25`CAST(${properties.area} AS SIGNED)`,
          floorSize: sql25`CAST(${properties.area} AS SIGNED)`,
          titleType: sql25`'freehold'`,
          // Default until migration
          levy: properties.levies,
          rates: properties.ratesAndTaxes,
          securityEstate: sql25`false`,
          // Default until migration
          petFriendly: sql25`false`,
          // Default until migration
          fibreReady: sql25`false`,
          // Default until migration
          loadSheddingSolutions: sql25`JSON_ARRAY('none')`,
          videoCount: sql25`0`,
          // Will be calculated from related tables
          status: properties.status,
          listedDate: properties.createdAt,
          latitude: sql25`CAST(${properties.latitude} AS DECIMAL(10,8))`,
          longitude: sql25`CAST(${properties.longitude} AS DECIMAL(11,8))`,
          highlights: sql25`JSON_ARRAY()`,
          agentId: properties.agentId
        }).from(properties).leftJoin(developments, eq34(properties.developmentId, developments.id)).where(and28(...conditions)).orderBy(orderBy).limit(pageSize).offset(offset);
        const propertyIds = results.map((p) => Number(p.id));
        const images = propertyIds.length > 0 ? await db.select({
          propertyId: propertyImages.propertyId,
          imageUrl: propertyImages.imageUrl,
          isPrimary: propertyImages.isPrimary
        }).from(propertyImages).where(inArray9(propertyImages.propertyId, propertyIds)).orderBy(desc21(propertyImages.isPrimary), asc3(propertyImages.displayOrder)) : [];
        const imagesByProperty = /* @__PURE__ */ new Map();
        images.forEach((img) => {
          const propId = img.propertyId;
          if (!imagesByProperty.has(propId)) {
            imagesByProperty.set(propId, []);
          }
          imagesByProperty.get(propId).push(img);
        });
        const transformedProperties = results.map((prop) => ({
          id: String(prop.id),
          title: prop.title,
          price: prop.price,
          suburb: prop.suburb || prop.city,
          city: prop.city,
          province: prop.province,
          propertyType: prop.propertyType,
          listingType: prop.listingType,
          bedrooms: prop.bedrooms || void 0,
          bathrooms: prop.bathrooms || void 0,
          erfSize: prop.erfSize || void 0,
          floorSize: prop.floorSize || void 0,
          titleType: prop.titleType,
          levy: prop.levy || void 0,
          rates: prop.rates || void 0,
          securityEstate: prop.securityEstate,
          petFriendly: prop.petFriendly,
          fibreReady: prop.fibreReady,
          loadSheddingSolutions: prop.loadSheddingSolutions,
          images: (imagesByProperty.get(Number(prop.id)) || []).map((img) => ({
            url: img.imageUrl,
            thumbnailUrl: img.imageUrl
          })),
          videoCount: prop.videoCount,
          status: this.mapStatus(prop.status),
          listedDate: new Date(prop.listedDate),
          agent: {
            id: String(prop.agentId || 0),
            name: "Agent Name",
            // Will be populated from agents table
            agency: "Agency Name",
            phone: "",
            whatsapp: "",
            email: ""
          },
          latitude: prop.latitude || 0,
          longitude: prop.longitude || 0,
          highlights: prop.highlights
        }));
        let locationContext = void 0;
        if (resolvedLocation) {
          let name = resolvedLocation.province.name;
          let slug = resolvedLocation.province.slug;
          if (resolvedLocation.level === "city" && resolvedLocation.city) {
            name = resolvedLocation.city.name;
            slug = resolvedLocation.city.slug;
          } else if (resolvedLocation.level === "suburb" && resolvedLocation.suburb) {
            name = resolvedLocation.suburb.name;
            slug = resolvedLocation.suburb.slug;
          }
          locationContext = {
            type: resolvedLocation.level,
            name,
            slug,
            confidence: resolvedLocation.confidence,
            fallbackLevel: resolvedLocation.fallbackLevel,
            originalIntent: resolvedLocation.originalIntent,
            hierarchy: {
              province: resolvedLocation.province.name,
              city: resolvedLocation.city?.name,
              suburb: resolvedLocation.suburb?.name
            },
            ids: {
              provinceId: resolvedLocation.province.id,
              cityId: resolvedLocation.city?.id,
              suburbId: resolvedLocation.suburb?.id
            }
          };
        }
        const searchResults = {
          properties: transformedProperties,
          total,
          page,
          pageSize,
          hasMore,
          locationContext
        };
        await redisCache.set(cacheKey, searchResults, CacheTTL.FEED_RESULTS);
        return searchResults;
      }
      /**
       * Build filter conditions from PropertyFilters
       * Supports all filter types: location, price, bedrooms, SA-specific
       * Uses hybrid approach: ID-based queries when available, text fallback otherwise
       */
      buildFilterConditions(filters, locationIds = []) {
        const conditions = [];
        conditions.push(
          or14(
            eq34(properties.status, "available"),
            eq34(properties.status, "published")
          )
        );
        const locationConditions = [];
        if (locationIds.length > 0) {
          for (const loc of locationIds) {
            if (loc.suburbId) {
              locationConditions.push(eq34(properties.suburbId, loc.suburbId));
            } else if (loc.cityId) {
              if (loc.cityName) {
                locationConditions.push(or14(
                  eq34(properties.cityId, loc.cityId),
                  sql25`LOWER(${properties.city}) = LOWER(${loc.cityName})`
                ));
              } else {
                locationConditions.push(eq34(properties.cityId, loc.cityId));
              }
            } else if (loc.provinceId) {
              if (loc.provinceName) {
                locationConditions.push(or14(
                  eq34(properties.provinceId, loc.provinceId),
                  sql25`LOWER(${properties.province}) = LOWER(${loc.provinceName})`
                ));
              } else {
                locationConditions.push(eq34(properties.provinceId, loc.provinceId));
              }
            }
          }
        }
        if (locationIds.length === 0) {
          if (filters.province) {
            locationConditions.push(sql25`LOWER(${properties.province}) = LOWER(${filters.province})`);
          }
          if (filters.city) {
            locationConditions.push(sql25`LOWER(${properties.city}) = LOWER(${filters.city})`);
          }
          if (filters.suburb && filters.suburb.length > 0) {
            const suburbConditions = filters.suburb.map(
              (suburb) => sql25`LOWER(${properties.address}) LIKE LOWER(${`%${suburb}%`})`
            );
            locationConditions.push(or14(...suburbConditions));
          }
        }
        if (filters.locations && filters.locations.length > 0 && locationIds.length === 0) {
          const multiTextConditions = filters.locations.map((slug) => {
            const textParams = slug.replace(/-/g, " ");
            return or14(
              sql25`LOWER(${properties.city}) LIKE LOWER(${`%${textParams}%`})`,
              sql25`LOWER(${properties.address}) LIKE LOWER(${`%${textParams}%`})`
            );
          });
          locationConditions.push(or14(...multiTextConditions));
        }
        if (locationConditions.length > 0) {
          conditions.push(or14(...locationConditions));
        }
        if (filters.propertyType && filters.propertyType.length > 0) {
          conditions.push(inArray9(properties.propertyType, filters.propertyType));
        }
        if (filters.listingType) {
          conditions.push(eq34(properties.listingType, filters.listingType));
        }
        if (filters.minPrice !== void 0) {
          conditions.push(gte8(properties.price, filters.minPrice));
        }
        if (filters.maxPrice !== void 0) {
          conditions.push(lte7(properties.price, filters.maxPrice));
        }
        if (filters.minBedrooms !== void 0) {
          conditions.push(gte8(properties.bedrooms, filters.minBedrooms));
        }
        if (filters.maxBedrooms !== void 0) {
          conditions.push(lte7(properties.bedrooms, filters.maxBedrooms));
        }
        if (filters.minBathrooms !== void 0) {
          conditions.push(gte8(properties.bathrooms, filters.minBathrooms));
        }
        if (filters.minErfSize !== void 0) {
          conditions.push(gte8(properties.area, filters.minErfSize));
        }
        if (filters.maxErfSize !== void 0) {
          conditions.push(lte7(properties.area, filters.maxErfSize));
        }
        if (filters.minFloorSize !== void 0) {
          conditions.push(gte8(properties.area, filters.minFloorSize));
        }
        if (filters.maxFloorSize !== void 0) {
          conditions.push(lte7(properties.area, filters.maxFloorSize));
        }
        if (filters.ownershipType && filters.ownershipType.length > 0) {
          conditions.push(inArray9(developments.ownershipType, filters.ownershipType));
        }
        if (filters.structuralType && filters.structuralType.length > 0) {
          conditions.push(inArray9(developments.structuralType, filters.structuralType));
        }
        if (filters.floors && filters.floors.length > 0) {
          conditions.push(inArray9(developments.floors, filters.floors));
        }
        if (filters.status && filters.status.length > 0) {
          const statusConditions = filters.status.map((status) => {
            switch (status) {
              case "available":
                return or14(eq34(properties.status, "available"), eq34(properties.status, "published"));
              case "sold":
                return eq34(properties.status, "sold");
              case "let":
                return eq34(properties.status, "rented");
              case "under_offer":
                return eq34(properties.status, "pending");
              default:
                return eq34(properties.status, status);
            }
          });
          conditions.push(or14(...statusConditions));
        }
        if (filters.bounds) {
          conditions.push(
            and28(
              sql25`CAST(${properties.latitude} AS DECIMAL(10,8)) >= ${filters.bounds.south}`,
              sql25`CAST(${properties.latitude} AS DECIMAL(10,8)) <= ${filters.bounds.north}`,
              sql25`CAST(${properties.longitude} AS DECIMAL(11,8)) >= ${filters.bounds.west}`,
              sql25`CAST(${properties.longitude} AS DECIMAL(11,8)) <= ${filters.bounds.east}`
            )
          );
        }
        return conditions;
      }
      /**
       * Build sort order based on SortOption
       * Requirement 2.3: Support all sort options
       */
      buildSortOrder(sortOption) {
        switch (sortOption) {
          case "price_asc":
            return asc3(properties.price);
          case "price_desc":
            return desc21(properties.price);
          case "date_desc":
            return desc21(properties.createdAt);
          case "date_asc":
            return asc3(properties.createdAt);
          case "suburb_asc":
            return asc3(properties.address);
          case "suburb_desc":
            return desc21(properties.address);
          default:
            return desc21(properties.createdAt);
        }
      }
      /**
       * Map database status to Property status
       */
      mapStatus(dbStatus) {
        switch (dbStatus) {
          case "sold":
            return "sold";
          case "rented":
            return "let";
          case "pending":
            return "under_offer";
          case "available":
          case "published":
          default:
            return "available";
        }
      }
      /**
       * Generate cache key for search results
       */
      generateCacheKey(filters, sortOption, page, pageSize) {
        const filterStr = JSON.stringify(filters);
        const hash = this.simpleHash(filterStr);
        return `${CACHE_PREFIX}${hash}:${sortOption}:${page}:${pageSize}`;
      }
      /**
       * Simple hash function for cache keys
       */
      simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return Math.abs(hash).toString(36);
      }
      /**
       * Get filter counts for preview
       * Requirement 7.3: Show count before applying filter
       */
      async getFilterCounts(baseFilters) {
        let locationIds = [];
        try {
          if (baseFilters.locations && baseFilters.locations.length > 0) {
            await Promise.all(baseFilters.locations.map(async (slug) => {
              const resolved = await locationResolver.resolveLocation({ citySlug: slug });
              if (resolved && (resolved.city || resolved.suburb || resolved.province)) {
                locationIds.push({
                  provinceId: resolved.province?.id,
                  provinceName: resolved.province?.name,
                  cityId: resolved.city?.id,
                  cityName: resolved.city?.name,
                  suburbId: resolved.suburb?.id,
                  suburbName: resolved.suburb?.name
                });
              }
            }));
          } else {
            const resolvedLocation = await locationResolver.resolveLocation({
              provinceSlug: baseFilters.province,
              citySlug: baseFilters.city,
              suburbSlug: baseFilters.suburb?.[0]
            });
            if (resolvedLocation) {
              locationIds.push({
                provinceId: resolvedLocation.province?.id,
                provinceName: resolvedLocation.province?.name,
                cityId: resolvedLocation.city?.id,
                cityName: resolvedLocation.city?.name,
                suburbId: resolvedLocation.suburb?.id,
                suburbName: resolvedLocation.suburb?.name
              });
            }
          }
        } catch (error) {
          console.error("[PropertySearchService] Location resolver failed in getFilterCounts, using text fallback:", error);
        }
        const conditions = this.buildFilterConditions(baseFilters, locationIds);
        const totalResult = await db.select({ count: sql25`count(*)` }).from(properties).leftJoin(developments, eq34(properties.developmentId, developments.id)).where(and28(...conditions));
        const total = Number(totalResult[0]?.count || 0);
        const typeResults = await db.select({
          propertyType: properties.propertyType,
          count: sql25`count(*)`
        }).from(properties).leftJoin(developments, eq34(properties.developmentId, developments.id)).where(and28(...conditions)).groupBy(properties.propertyType);
        const byPropertyType = {};
        typeResults.forEach((row) => {
          byPropertyType[row.propertyType] = Number(row.count);
        });
        const priceRanges = [
          { range: "Under R1M", min: 0, max: 1e6 },
          { range: "R1M - R2M", min: 1e6, max: 2e6 },
          { range: "R2M - R3M", min: 2e6, max: 3e6 },
          { range: "R3M - R5M", min: 3e6, max: 5e6 },
          { range: "Over R5M", min: 5e6, max: Number.MAX_SAFE_INTEGER }
        ];
        const byPriceRange = await Promise.all(
          priceRanges.map(async ({ range, min: min2, max: max2 }) => {
            const rangeConditions = [
              ...conditions,
              gte8(properties.price, min2),
              lte7(properties.price, max2)
            ];
            const result = await db.select({ count: sql25`count(*)` }).from(properties).leftJoin(developments, eq34(properties.developmentId, developments.id)).where(and28(...rangeConditions));
            return {
              range,
              count: Number(result[0]?.count || 0)
            };
          })
        );
        return {
          total,
          byPropertyType,
          byPriceRange
        };
      }
      /**
       * Invalidate cache for property searches
       * Call this when properties are updated
       */
      async invalidateCache(propertyId) {
        if (propertyId) {
          await redisCache.delByPattern(`${CACHE_PREFIX}*`);
        } else {
          await redisCache.delByPattern(`${CACHE_PREFIX}*`);
        }
      }
    };
    propertySearchService = new PropertySearchService();
  }
});

// server/routes/analytics.ts
var analytics_exports = {};
__export(analytics_exports, {
  default: () => analytics_default
});
import { Router } from "express";
var router3, analytics_default;
var init_analytics = __esm({
  "server/routes/analytics.ts"() {
    "use strict";
    router3 = Router();
    router3.post("/track", async (req, res) => {
      try {
        const event = req.body;
        console.log("[Analytics]", event.eventType, {
          page: event.page,
          deviceType: event.deviceType,
          timestamp: event.timestamp
        });
        res.status(200).json({ success: true });
      } catch (error) {
        console.error("[Analytics] Error:", error);
        res.status(500).json({ success: false, error: "Failed to track event" });
      }
    });
    analytics_default = router3;
  }
});

// server/services/partnerService.ts
var partnerService_exports = {};
__export(partnerService_exports, {
  PartnerService: () => PartnerService,
  partnerService: () => partnerService
});
import { eq as eq42, desc as desc27, sql as sql30 } from "drizzle-orm";
import { randomUUID } from "crypto";
var PartnerService, partnerService;
var init_partnerService = __esm({
  "server/services/partnerService.ts"() {
    "use strict";
    init_db();
    init_schema();
    PartnerService = class {
      /**
       * Register a new partner with tier assignment
       * Requirement 1.1, 1.6
       */
      async registerPartner(data) {
        const tier = await db.query.partnerTiers.findFirst({
          where: eq42(partnerTiers.id, data.tierId)
        });
        if (!tier) {
          throw new Error(`Invalid tier ID: ${data.tierId}`);
        }
        const existingPartner = await db.query.explorePartners.findFirst({
          where: eq42(explorePartners.userId, data.userId)
        });
        if (existingPartner) {
          throw new Error("User already has a partner account");
        }
        const partnerId = randomUUID();
        const [partner] = await db.insert(explorePartners).values({
          id: partnerId,
          userId: data.userId,
          tierId: data.tierId,
          companyName: data.companyName,
          description: data.description || null,
          logoUrl: data.logoUrl || null,
          verificationStatus: "pending",
          trustScore: "50.00",
          // Default starting score
          serviceLocations: data.serviceLocations || [],
          approvedContentCount: 0
        });
        return partner;
      }
      /**
       * Assign or change partner tier with permission validation
       * Requirement 1.1, 1.6
       */
      async assignTier(partnerId, tierId) {
        const tier = await db.query.partnerTiers.findFirst({
          where: eq42(partnerTiers.id, tierId)
        });
        if (!tier) {
          throw new Error(`Invalid tier ID: ${tierId}`);
        }
        const partner = await db.query.explorePartners.findFirst({
          where: eq42(explorePartners.id, partnerId)
        });
        if (!partner) {
          throw new Error("Partner not found");
        }
        await db.update(explorePartners).set({
          tierId,
          updatedAt: sql30`CURRENT_TIMESTAMP`
        }).where(eq42(explorePartners.id, partnerId));
      }
      /**
       * Update partner profile information
       * Requirement 5.1, 5.2, 5.3, 5.4
       */
      async updateProfile(partnerId, data) {
        const updateData = {
          updatedAt: sql30`CURRENT_TIMESTAMP`
        };
        if (data.companyName !== void 0) updateData.companyName = data.companyName;
        if (data.description !== void 0) updateData.description = data.description;
        if (data.logoUrl !== void 0) updateData.logoUrl = data.logoUrl;
        if (data.serviceLocations !== void 0) {
          updateData.serviceLocations = data.serviceLocations;
        }
        const [updated] = await db.update(explorePartners).set(updateData).where(eq42(explorePartners.id, partnerId));
        return updated;
      }
      /**
       * Get partner profile with aggregated data
       * Requirement 5.1, 5.2, 5.3, 5.4
       */
      async getPartnerProfile(partnerId) {
        const partner = await db.query.explorePartners.findFirst({
          where: eq42(explorePartners.id, partnerId),
          with: {
            tier: true
          }
        });
        if (!partner) {
          return null;
        }
        let serviceLocations = [];
        try {
          serviceLocations = typeof partner.serviceLocations === "string" ? JSON.parse(partner.serviceLocations) : partner.serviceLocations || [];
        } catch (e) {
          serviceLocations = [];
        }
        return {
          id: partner.id,
          userId: partner.userId,
          tier: {
            id: partner.tier.id,
            name: partner.tier.name,
            allowedContentTypes: typeof partner.tier.allowedContentTypes === "string" ? JSON.parse(partner.tier.allowedContentTypes) : partner.tier.allowedContentTypes,
            allowedCTAs: typeof partner.tier.allowedCTAs === "string" ? JSON.parse(partner.tier.allowedCTAs) : partner.tier.allowedCTAs
          },
          companyName: partner.companyName,
          description: partner.description,
          logoUrl: partner.logoUrl,
          verificationStatus: partner.verificationStatus,
          trustScore: parseFloat(partner.trustScore.toString()),
          serviceLocations,
          subscriptionTier: "free",
          // Default for now
          approvedContentCount: partner.approvedContentCount,
          createdAt: new Date(partner.createdAt),
          updatedAt: new Date(partner.updatedAt)
        };
      }
      /**
       * Verify partner with credential validation
       * Requirement 5.5, 5.6
       * 
       * This method marks a partner as verified and propagates the verification
       * badge to all their content automatically via the partner_id relationship.
       */
      async verifyPartner(partnerId, credentials) {
        const partner = await db.query.explorePartners.findFirst({
          where: eq42(explorePartners.id, partnerId)
        });
        if (!partner) {
          throw new Error("Partner not found");
        }
        await db.update(explorePartners).set({
          verificationStatus: "verified",
          updatedAt: sql30`CURRENT_TIMESTAMP`
        }).where(eq42(explorePartners.id, partnerId));
        await this.calculateTrustScore(partnerId);
      }
      /**
       * Calculate and update partner trust score
       * Requirement 10.5
       * 
       * Trust score is calculated based on:
       * - Verification status (30%)
       * - Content quality average (30%)
       * - User reviews/ratings (20%)
       * - Engagement metrics (20%)
       */
      async calculateTrustScore(partnerId) {
        const partner = await db.query.explorePartners.findFirst({
          where: eq42(explorePartners.id, partnerId)
        });
        if (!partner) {
          throw new Error("Partner not found");
        }
        let score = 0;
        if (partner.verificationStatus === "verified") {
          score += 30;
        } else if (partner.verificationStatus === "pending") {
          score += 15;
        }
        const contentQualityResult = await db.select({
          avgQuality: sql30`AVG(${contentQualityScores.overallScore})`
        }).from(contentQualityScores).innerJoin(
          exploreContent,
          eq42(exploreContent.id, contentQualityScores.contentId)
        ).where(eq42(exploreContent.partnerId, partnerId)).limit(1);
        const avgContentQuality = contentQualityResult[0]?.avgQuality || 50;
        score += avgContentQuality / 100 * 30;
        score += 10;
        score += 10;
        const finalScore = Math.round(score * 100) / 100;
        await db.update(explorePartners).set({
          trustScore: finalScore.toString(),
          updatedAt: sql30`CURRENT_TIMESTAMP`
        }).where(eq42(explorePartners.id, partnerId));
        return finalScore;
      }
      /**
       * Get partners by tier
       */
      async getPartnersByTier(tierId) {
        return await db.query.explorePartners.findMany({
          where: eq42(explorePartners.tierId, tierId),
          orderBy: [desc27(explorePartners.trustScore)]
        });
      }
      /**
       * Increment approved content count
       * Called when content is approved
       */
      async incrementApprovedContentCount(partnerId) {
        const partner = await db.query.explorePartners.findFirst({
          where: eq42(explorePartners.id, partnerId)
        });
        if (!partner) {
          throw new Error("Partner not found");
        }
        await db.update(explorePartners).set({
          approvedContentCount: partner.approvedContentCount + 1,
          updatedAt: sql30`CURRENT_TIMESTAMP`
        }).where(eq42(explorePartners.id, partnerId));
      }
      /**
       * Check if partner is eligible for auto-approval
       * Partners with 3+ approved content pieces are eligible
       */
      async isEligibleForAutoApproval(partnerId) {
        const partner = await db.query.explorePartners.findFirst({
          where: eq42(explorePartners.id, partnerId)
        });
        if (!partner) {
          return false;
        }
        return partner.approvedContentCount >= 3;
      }
    };
    partnerService = new PartnerService();
  }
});

// server/partnerRouter.ts
var partnerRouter_exports = {};
__export(partnerRouter_exports, {
  default: () => partnerRouter_default
});
import { Router as Router2 } from "express";
var router4, partnerRouter_default;
var init_partnerRouter = __esm({
  "server/partnerRouter.ts"() {
    "use strict";
    init_partnerService();
    init_auth();
    router4 = Router2();
    router4.post("/", requireAuth, async (req, res) => {
      try {
        const { tierId, companyName, description, logoUrl, serviceLocations } = req.body;
        if (!tierId || !companyName) {
          return res.status(400).json({
            error: "Missing required fields: tierId, companyName"
          });
        }
        const partner = await partnerService.registerPartner({
          userId: req.user.id,
          tierId,
          companyName,
          description,
          logoUrl,
          serviceLocations
        });
        res.status(201).json(partner);
      } catch (error) {
        console.error("Error registering partner:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router4.get("/:id", async (req, res) => {
      try {
        const { id } = req.params;
        const profile = await partnerService.getPartnerProfile(id);
        if (!profile) {
          return res.status(404).json({ error: "Partner not found" });
        }
        res.json(profile);
      } catch (error) {
        console.error("Error fetching partner profile:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router4.put("/:id", requireAuth, async (req, res) => {
      try {
        const { id } = req.params;
        const { companyName, description, logoUrl, serviceLocations } = req.body;
        const profile = await partnerService.getPartnerProfile(id);
        if (!profile) {
          return res.status(404).json({ error: "Partner not found" });
        }
        if (profile.userId !== req.user.id) {
          return res.status(403).json({ error: "Unauthorized" });
        }
        const updated = await partnerService.updateProfile(id, {
          companyName,
          description,
          logoUrl,
          serviceLocations
        });
        res.json(updated);
      } catch (error) {
        console.error("Error updating partner profile:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router4.post("/:id/verify", requireAuth, async (req, res) => {
      try {
        const { id } = req.params;
        const { credentials, documentUrls, licenseNumber } = req.body;
        const profile = await partnerService.getPartnerProfile(id);
        if (!profile) {
          return res.status(404).json({ error: "Partner not found" });
        }
        if (profile.userId !== req.user.id) {
          return res.status(403).json({ error: "Unauthorized" });
        }
        await partnerService.verifyPartner(id, {
          credentials,
          documentUrls,
          licenseNumber
        });
        res.json({ message: "Verification submitted successfully" });
      } catch (error) {
        console.error("Error submitting verification:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router4.put("/:id/tier", requireAuth, async (req, res) => {
      try {
        if (req.user.role !== "super_admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const { id } = req.params;
        const { tierId } = req.body;
        if (!tierId) {
          return res.status(400).json({ error: "Missing required field: tierId" });
        }
        await partnerService.assignTier(id, tierId);
        res.json({ message: "Tier assigned successfully" });
      } catch (error) {
        console.error("Error assigning tier:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router4.post("/:id/trust-score", requireAuth, async (req, res) => {
      try {
        const { id } = req.params;
        const score = await partnerService.calculateTrustScore(id);
        res.json({ trustScore: score });
      } catch (error) {
        console.error("Error calculating trust score:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router4.get("/tier/:tierId", async (req, res) => {
      try {
        const { tierId } = req.params;
        const partners2 = await partnerService.getPartnersByTier(parseInt(tierId));
        res.json(partners2);
      } catch (error) {
        console.error("Error fetching partners by tier:", error);
        res.status(500).json({ error: error.message });
      }
    });
    partnerRouter_default = router4;
  }
});

// server/services/partnerAnalyticsService.ts
import { eq as eq43, and as and36, gte as gte10, lte as lte9, sql as sql31, desc as desc28, count as count8, sum as sum2, avg as avg3 } from "drizzle-orm";
async function getPartnerAnalyticsSummary(partnerId, startDate, endDate) {
  const dateFilter = startDate && endDate ? and36(
    gte10(exploreEngagements.createdAt, startDate.toISOString()),
    lte9(exploreEngagements.createdAt, endDate.toISOString())
  ) : void 0;
  const partnerContent = await db.select({ id: exploreContent.id }).from(exploreContent).where(eq43(exploreContent.partnerId, partnerId));
  const partnerShorts = await db.select({ id: exploreShorts.id }).from(exploreShorts).where(eq43(exploreShorts.partnerId, partnerId));
  const contentIds = [
    ...partnerContent.map((c) => c.id),
    ...partnerShorts.map((s) => s.id.toString())
  ];
  if (contentIds.length === 0) {
    return {
      totalViews: 0,
      engagementRate: 0,
      leadConversions: 0,
      totalLeads: 0,
      totalContent: 0,
      averageQualityScore: 0
    };
  }
  const engagementQuery = db.select({
    totalViews: count8(exploreEngagements.id),
    totalEngagements: sum2(sql31`CASE WHEN ${exploreEngagements.engagementType} IN ('save', 'share', 'click') THEN 1 ELSE 0 END`)
  }).from(exploreEngagements).where(
    and36(
      sql31`${exploreEngagements.contentId} IN (${sql31.join(contentIds.map((id) => sql31`${id}`), sql31`, `)})`,
      dateFilter
    )
  );
  const [engagementData] = await engagementQuery;
  const leadQuery = db.select({
    totalLeads: count8(partnerLeads.id),
    convertedLeads: sum2(sql31`CASE WHEN ${partnerLeads.status} = 'converted' THEN 1 ELSE 0 END`)
  }).from(partnerLeads).where(
    and36(
      eq43(partnerLeads.partnerId, partnerId),
      dateFilter ? and36(
        gte10(partnerLeads.createdAt, startDate.toISOString()),
        lte9(partnerLeads.createdAt, endDate.toISOString())
      ) : void 0
    )
  );
  const [leadData] = await leadQuery;
  const qualityQuery = db.select({
    avgScore: avg3(contentQualityScores.overallScore)
  }).from(contentQualityScores).where(
    sql31`${contentQualityScores.contentId} IN (${sql31.join(contentIds.map((id) => sql31`${id}`), sql31`, `)})`
  );
  const [qualityData] = await qualityQuery;
  const totalViews = Number(engagementData?.totalViews || 0);
  const totalEngagements = Number(engagementData?.totalEngagements || 0);
  const engagementRate = totalViews > 0 ? totalEngagements / totalViews * 100 : 0;
  return {
    totalViews,
    engagementRate: Math.round(engagementRate * 100) / 100,
    leadConversions: Number(leadData?.convertedLeads || 0),
    totalLeads: Number(leadData?.totalLeads || 0),
    totalContent: contentIds.length,
    averageQualityScore: Number(qualityData?.avgScore || 0)
  };
}
async function getPerformanceTrends(partnerId, period, startDate, endDate) {
  const partnerContent = await db.select({ id: exploreContent.id }).from(exploreContent).where(eq43(exploreContent.partnerId, partnerId));
  const partnerShorts = await db.select({ id: exploreShorts.id }).from(exploreShorts).where(eq43(exploreShorts.partnerId, partnerId));
  const contentIds = [
    ...partnerContent.map((c) => c.id),
    ...partnerShorts.map((s) => s.id.toString())
  ];
  if (contentIds.length === 0) {
    return [];
  }
  const dateFormat = period === "daily" ? "%Y-%m-%d" : period === "weekly" ? "%Y-%U" : "%Y-%m";
  const trendsQuery = await db.select({
    date: sql31`DATE_FORMAT(${exploreEngagements.createdAt}, ${dateFormat})`,
    views: count8(exploreEngagements.id),
    engagements: sum2(sql31`CASE WHEN ${exploreEngagements.engagementType} IN ('save', 'share', 'click') THEN 1 ELSE 0 END`)
  }).from(exploreEngagements).where(
    and36(
      sql31`${exploreEngagements.contentId} IN (${sql31.join(contentIds.map((id) => sql31`${id}`), sql31`, `)})`,
      gte10(exploreEngagements.createdAt, startDate.toISOString()),
      lte9(exploreEngagements.createdAt, endDate.toISOString())
    )
  ).groupBy(sql31`DATE_FORMAT(${exploreEngagements.createdAt}, ${dateFormat})`);
  const leadTrendsQuery = await db.select({
    date: sql31`DATE_FORMAT(${partnerLeads.createdAt}, ${dateFormat})`,
    leads: count8(partnerLeads.id)
  }).from(partnerLeads).where(
    and36(
      eq43(partnerLeads.partnerId, partnerId),
      gte10(partnerLeads.createdAt, startDate.toISOString()),
      lte9(partnerLeads.createdAt, endDate.toISOString())
    )
  ).groupBy(sql31`DATE_FORMAT(${partnerLeads.createdAt}, ${dateFormat})`);
  const leadMap = new Map(leadTrendsQuery.map((l) => [l.date, Number(l.leads)]));
  return trendsQuery.map((trend) => ({
    date: trend.date,
    views: Number(trend.views),
    engagements: Number(trend.engagements || 0),
    leads: leadMap.get(trend.date) || 0
  }));
}
async function getContentRankedByPerformance(partnerId, limit = 10) {
  const contentPerformance = await db.select({
    contentId: exploreContent.id,
    title: exploreContent.title,
    type: sql31`'card'`,
    createdAt: exploreContent.createdAt,
    views: count8(exploreEngagements.id),
    engagements: sum2(sql31`CASE WHEN ${exploreEngagements.engagementType} IN ('save', 'share', 'click') THEN 1 ELSE 0 END`),
    qualityScore: contentQualityScores.overallScore
  }).from(exploreContent).leftJoin(exploreEngagements, eq43(exploreContent.id, exploreEngagements.contentId)).leftJoin(contentQualityScores, eq43(exploreContent.id, contentQualityScores.contentId)).where(eq43(exploreContent.partnerId, partnerId)).groupBy(exploreContent.id, exploreContent.title, exploreContent.createdAt, contentQualityScores.overallScore).orderBy(desc28(count8(exploreEngagements.id))).limit(limit);
  const shortsPerformance = await db.select({
    contentId: sql31`CAST(${exploreShorts.id} AS CHAR)`,
    title: exploreShorts.title,
    type: sql31`'short'`,
    createdAt: exploreShorts.createdAt,
    views: count8(exploreEngagements.id),
    engagements: sum2(sql31`CASE WHEN ${exploreEngagements.engagementType} IN ('save', 'share', 'click') THEN 1 ELSE 0 END`),
    qualityScore: contentQualityScores.overallScore
  }).from(exploreShorts).leftJoin(exploreEngagements, sql31`CAST(${exploreShorts.id} AS CHAR) = ${exploreEngagements.contentId}`).leftJoin(contentQualityScores, sql31`CAST(${exploreShorts.id} AS CHAR) = ${contentQualityScores.contentId}`).where(eq43(exploreShorts.partnerId, partnerId)).groupBy(exploreShorts.id, exploreShorts.title, exploreShorts.createdAt, contentQualityScores.overallScore).orderBy(desc28(count8(exploreEngagements.id))).limit(limit);
  const allContent = [...contentPerformance, ...shortsPerformance].map((item) => {
    const views = Number(item.views || 0);
    const engagements = Number(item.engagements || 0);
    return {
      contentId: item.contentId,
      title: item.title || "Untitled",
      type: item.type,
      views,
      engagements,
      engagementRate: views > 0 ? engagements / views * 100 : 0,
      qualityScore: Number(item.qualityScore || 0),
      createdAt: item.createdAt
    };
  }).sort((a, b) => b.views - a.views).slice(0, limit);
  return allContent;
}
async function getConversionFunnel(partnerId, startDate, endDate) {
  const summary = await getPartnerAnalyticsSummary(partnerId, startDate, endDate);
  const viewToEngagementRate = summary.totalViews > 0 ? summary.engagementRate / 100 : 0;
  const totalEngagements = Math.round(summary.totalViews * viewToEngagementRate);
  const engagementToLeadRate = totalEngagements > 0 ? summary.totalLeads / totalEngagements * 100 : 0;
  const overallConversionRate = summary.totalViews > 0 ? summary.totalLeads / summary.totalViews * 100 : 0;
  return {
    totalViews: summary.totalViews,
    totalEngagements,
    totalLeads: summary.totalLeads,
    viewToEngagementRate: Math.round(viewToEngagementRate * 1e4) / 100,
    engagementToLeadRate: Math.round(engagementToLeadRate * 100) / 100,
    overallConversionRate: Math.round(overallConversionRate * 100) / 100
  };
}
async function getTierBenchmarks() {
  const benchmarks = await db.select({
    tierId: partnerTiers.id,
    tierName: partnerTiers.name,
    partnerCount: count8(explorePartners.id),
    totalViews: sum2(sql31`(
        SELECT COUNT(*) 
        FROM explore_engagements 
        WHERE content_id IN (
          SELECT id FROM explore_content WHERE partner_id = explore_partners.id
          UNION
          SELECT CAST(id AS CHAR) FROM explore_shorts WHERE partner_id = explore_partners.id
        )
      )`),
    totalEngagements: sum2(sql31`(
        SELECT COUNT(*) 
        FROM explore_engagements 
        WHERE engagement_type IN ('save', 'share', 'click')
        AND content_id IN (
          SELECT id FROM explore_content WHERE partner_id = explore_partners.id
          UNION
          SELECT CAST(id AS CHAR) FROM explore_shorts WHERE partner_id = explore_partners.id
        )
      )`),
    totalLeads: sum2(sql31`(
        SELECT COUNT(*) 
        FROM partner_leads 
        WHERE partner_id = explore_partners.id 
        AND status = 'converted'
      )`)
  }).from(partnerTiers).leftJoin(explorePartners, eq43(partnerTiers.id, explorePartners.tierId)).groupBy(partnerTiers.id, partnerTiers.name);
  return benchmarks.map((b) => {
    const partnerCount = Number(b.partnerCount || 1);
    const avgViews = Number(b.totalViews || 0) / partnerCount;
    const avgEngagements = Number(b.totalEngagements || 0) / partnerCount;
    const avgLeads = Number(b.totalLeads || 0) / partnerCount;
    const avgEngagementRate = avgViews > 0 ? avgEngagements / avgViews * 100 : 0;
    return {
      tierId: b.tierId,
      tierName: b.tierName,
      averageViews: Math.round(avgViews),
      averageEngagementRate: Math.round(avgEngagementRate * 100) / 100,
      averageLeadConversion: Math.round(avgLeads)
    };
  });
}
async function getBoostCampaignROI(partnerId) {
  const campaigns = await db.select({
    id: boostCampaigns.id,
    contentId: boostCampaigns.contentId,
    budget: boostCampaigns.budget,
    spent: boostCampaigns.spent,
    impressions: boostCampaigns.impressions,
    clicks: boostCampaigns.clicks,
    costPerImpression: boostCampaigns.costPerImpression
  }).from(boostCampaigns).where(eq43(boostCampaigns.partnerId, partnerId));
  const roiData = [];
  for (const campaign of campaigns) {
    const [leadData] = await db.select({
      leads: count8(partnerLeads.id)
    }).from(partnerLeads).where(
      and36(
        eq43(partnerLeads.partnerId, partnerId),
        eq43(partnerLeads.contentId, campaign.contentId)
      )
    );
    const leads3 = Number(leadData?.leads || 0);
    const spent = Number(campaign.spent);
    const impressions = Number(campaign.impressions);
    const clicks = Number(campaign.clicks);
    const costPerClick = clicks > 0 ? spent / clicks : 0;
    const costPerLead = leads3 > 0 ? spent / leads3 : 0;
    const averageLeadValue = 500;
    const revenue = leads3 * averageLeadValue;
    const roi = spent > 0 ? (revenue - spent) / spent * 100 : 0;
    roiData.push({
      campaignId: campaign.id,
      campaignName: `Campaign ${campaign.id}`,
      budget: Number(campaign.budget),
      spent,
      impressions,
      clicks,
      leads: leads3,
      costPerImpression: Number(campaign.costPerImpression),
      costPerClick: Math.round(costPerClick * 100) / 100,
      costPerLead: Math.round(costPerLead * 100) / 100,
      roi: Math.round(roi * 100) / 100
    });
  }
  return roiData;
}
var partnerAnalyticsService;
var init_partnerAnalyticsService = __esm({
  "server/services/partnerAnalyticsService.ts"() {
    "use strict";
    init_db();
    init_schema();
    partnerAnalyticsService = {
      // Main methods
      getPartnerAnalyticsSummary,
      getPerformanceTrends,
      getContentRankedByPerformance,
      getConversionFunnel,
      getTierBenchmarks,
      getBoostCampaignROI,
      // Aliases for consistency with test expectations
      getPartnerAnalytics: getPartnerAnalyticsSummary,
      getContentRanking: getContentRankedByPerformance,
      getBenchmarkComparison: getTierBenchmarks,
      getBoostROI: getBoostCampaignROI,
      // Additional helper method
      calculateEngagementRate: (views, engagements) => {
        return views > 0 ? engagements / views * 100 : 0;
      }
    };
  }
});

// server/partnerAnalyticsRouter.ts
var partnerAnalyticsRouter_exports = {};
__export(partnerAnalyticsRouter_exports, {
  default: () => partnerAnalyticsRouter_default
});
import { Router as Router3 } from "express";
var router5, partnerAnalyticsRouter_default;
var init_partnerAnalyticsRouter = __esm({
  "server/partnerAnalyticsRouter.ts"() {
    "use strict";
    init_partnerAnalyticsService();
    router5 = Router3();
    router5.get("/:partnerId/summary", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const { startDate, endDate } = req.query;
        const start = startDate ? new Date(startDate) : void 0;
        const end = endDate ? new Date(endDate) : void 0;
        const summary = await partnerAnalyticsService.getPartnerAnalyticsSummary(
          partnerId,
          start,
          end
        );
        res.json({
          success: true,
          data: summary
        });
      } catch (error) {
        console.error("Error fetching partner analytics summary:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch analytics summary"
        });
      }
    });
    router5.get("/:partnerId/trends", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const { period = "daily", startDate, endDate } = req.query;
        if (!startDate || !endDate) {
          return res.status(400).json({
            success: false,
            error: "startDate and endDate are required"
          });
        }
        if (!["daily", "weekly", "monthly"].includes(period)) {
          return res.status(400).json({
            success: false,
            error: "period must be daily, weekly, or monthly"
          });
        }
        const trends = await partnerAnalyticsService.getPerformanceTrends(
          partnerId,
          period,
          new Date(startDate),
          new Date(endDate)
        );
        res.json({
          success: true,
          data: trends
        });
      } catch (error) {
        console.error("Error fetching performance trends:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch performance trends"
        });
      }
    });
    router5.get("/:partnerId/top-content", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const { limit = "10" } = req.query;
        const topContent = await partnerAnalyticsService.getContentRankedByPerformance(
          partnerId,
          parseInt(limit, 10)
        );
        res.json({
          success: true,
          data: topContent
        });
      } catch (error) {
        console.error("Error fetching top content:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch top content"
        });
      }
    });
    router5.get("/:partnerId/funnel", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const { startDate, endDate } = req.query;
        const start = startDate ? new Date(startDate) : void 0;
        const end = endDate ? new Date(endDate) : void 0;
        const funnel = await partnerAnalyticsService.getConversionFunnel(
          partnerId,
          start,
          end
        );
        res.json({
          success: true,
          data: funnel
        });
      } catch (error) {
        console.error("Error fetching conversion funnel:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch conversion funnel"
        });
      }
    });
    router5.get("/benchmarks", async (req, res) => {
      try {
        const benchmarks = await partnerAnalyticsService.getTierBenchmarks();
        res.json({
          success: true,
          data: benchmarks
        });
      } catch (error) {
        console.error("Error fetching tier benchmarks:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch tier benchmarks"
        });
      }
    });
    router5.get("/:partnerId/boost-roi", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const roiData = await partnerAnalyticsService.getBoostCampaignROI(partnerId);
        res.json({
          success: true,
          data: roiData
        });
      } catch (error) {
        console.error("Error fetching boost ROI:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch boost ROI"
        });
      }
    });
    router5.get("/:partnerId/dashboard", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const { period = "weekly", startDate, endDate } = req.query;
        const start = startDate ? new Date(startDate) : void 0;
        const end = endDate ? new Date(endDate) : void 0;
        const [summary, trends, topContent, funnel, benchmarks, boostROI] = await Promise.all([
          partnerAnalyticsService.getPartnerAnalyticsSummary(partnerId, start, end),
          start && end ? partnerAnalyticsService.getPerformanceTrends(
            partnerId,
            period,
            start,
            end
          ) : Promise.resolve([]),
          partnerAnalyticsService.getContentRankedByPerformance(partnerId, 5),
          partnerAnalyticsService.getConversionFunnel(partnerId, start, end),
          partnerAnalyticsService.getTierBenchmarks(),
          partnerAnalyticsService.getBoostCampaignROI(partnerId)
        ]);
        res.json({
          success: true,
          data: {
            summary,
            trends,
            topContent,
            funnel,
            benchmarks,
            boostROI
          }
        });
      } catch (error) {
        console.error("Error fetching analytics dashboard:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch analytics dashboard"
        });
      }
    });
    partnerAnalyticsRouter_default = router5;
  }
});

// server/services/contentApprovalService.ts
import { eq as eq44, and as and37, desc as desc29, sql as sql32 } from "drizzle-orm";
import { randomUUID as randomUUID2 } from "crypto";
var ContentApprovalService, contentApprovalService;
var init_contentApprovalService = __esm({
  "server/services/contentApprovalService.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_partnerService();
    ContentApprovalService = class {
      /**
       * Submit content for approval
       * Routes first 3 submissions to manual queue
       * Enables auto-approval after 3 approved pieces
       * Requirements: 6.1, 6.2
       */
      async submitForApproval(contentId, partnerId) {
        const partner = await db.query.explorePartners.findFirst({
          where: eq44(explorePartners.id, partnerId)
        });
        if (!partner) {
          throw new Error("Partner not found");
        }
        const existingQueueItem = await db.query.contentApprovalQueue.findFirst({
          where: and37(
            eq44(contentApprovalQueue.contentId, contentId),
            eq44(contentApprovalQueue.partnerId, partnerId)
          )
        });
        if (existingQueueItem) {
          throw new Error("Content already submitted for approval");
        }
        const isEligible = await partnerService.isEligibleForAutoApproval(partnerId);
        const queueId = randomUUID2();
        const [queueItem] = await db.insert(contentApprovalQueue).values({
          id: queueId,
          contentId,
          partnerId,
          status: "pending",
          autoApprovalEligible: isEligible
        });
        return {
          id: queueId,
          contentId,
          partnerId,
          status: "pending",
          submittedAt: /* @__PURE__ */ new Date(),
          autoApprovalEligible: isEligible
        };
      }
      /**
       * Check if partner is eligible for auto-approval
       * Requirements: 6.1, 6.2
       */
      async checkAutoApprovalEligibility(partnerId) {
        return await partnerService.isEligibleForAutoApproval(partnerId);
      }
      /**
       * Flag content for manual review
       * Routes flagged content to manual review regardless of partner status
       * Requirements: 6.3
       */
      async flagContent(contentId, reason, reporterId) {
        const queueItem = await db.query.contentApprovalQueue.findFirst({
          where: eq44(contentApprovalQueue.contentId, contentId)
        });
        if (!queueItem) {
          const content = await db.query.exploreContent.findFirst({
            where: eq44(exploreContent.id, parseInt(contentId))
          });
          if (!content) {
            throw new Error("Content not found");
          }
          if (!content.partnerId) {
            throw new Error("Content does not have an associated partner");
          }
          const queueId = randomUUID2();
          await db.insert(contentApprovalQueue).values({
            id: queueId,
            contentId,
            partnerId: content.partnerId,
            status: "pending",
            autoApprovalEligible: false,
            feedback: `Flagged by user ${reporterId}: ${reason}`
          });
          return;
        }
        await db.update(contentApprovalQueue).set({
          status: "pending",
          autoApprovalEligible: false,
          feedback: `Flagged by user ${reporterId}: ${reason}`
        }).where(eq44(contentApprovalQueue.id, queueItem.id));
      }
      /**
       * Route content to manual review queue
       * Used internally to force manual review
       * Requirements: 6.3
       */
      async routeToManualReview(queueId, reason) {
        await db.update(contentApprovalQueue).set({
          status: "pending",
          autoApprovalEligible: false,
          feedback: reason
        }).where(eq44(contentApprovalQueue.id, queueId));
      }
      /**
       * Review content with approve/reject/revision decision
       * Provides feedback on rejection
       * Requirements: 6.5
       */
      async reviewContent(queueId, decision, reviewerId) {
        const queueItem = await db.query.contentApprovalQueue.findFirst({
          where: eq44(contentApprovalQueue.id, queueId)
        });
        if (!queueItem) {
          throw new Error("Queue item not found");
        }
        if ((decision.status === "rejected" || decision.status === "revision_requested") && !decision.feedback) {
          throw new Error("Feedback is required for rejected or revision-requested content");
        }
        let feedbackMessage = decision.feedback || "";
        if (decision.violationTypes && decision.violationTypes.length > 0) {
          feedbackMessage += `

Violation types: ${decision.violationTypes.join(", ")}`;
        }
        if (decision.status === "rejected") {
          feedbackMessage += "\n\nPlease review our content guidelines and ensure your content:";
          feedbackMessage += "\n- Provides educational value, not just promotion";
          feedbackMessage += "\n- Matches your tier's allowed content types";
          feedbackMessage += "\n- Uses only approved CTAs for your tier";
          feedbackMessage += "\n- Has complete and accurate metadata";
          feedbackMessage += `

Ask yourself: "Would I watch this even if I wasn't buying?"`;
        }
        if (decision.status === "revision_requested") {
          feedbackMessage += "\n\nPlease make the requested changes and resubmit.";
        }
        await db.update(contentApprovalQueue).set({
          status: decision.status,
          reviewedAt: sql32`CURRENT_TIMESTAMP`,
          reviewerId,
          feedback: feedbackMessage
        }).where(eq44(contentApprovalQueue.id, queueId));
        if (decision.status === "approved") {
          await partnerService.incrementApprovedContentCount(queueItem.partnerId);
          await partnerService.calculateTrustScore(queueItem.partnerId);
        }
      }
      /**
       * Get pending reviews for a specific reviewer
       * Requirements: 6.5
       */
      async getPendingReviews(reviewerId, limit = 50) {
        const items = await db.query.contentApprovalQueue.findMany({
          where: eq44(contentApprovalQueue.status, "pending"),
          orderBy: [desc29(contentApprovalQueue.submittedAt)],
          limit
        });
        return items.map((item) => ({
          id: item.id,
          contentId: item.contentId,
          partnerId: item.partnerId,
          status: item.status,
          submittedAt: new Date(item.submittedAt),
          reviewedAt: item.reviewedAt ? new Date(item.reviewedAt) : void 0,
          reviewerId: item.reviewerId || void 0,
          feedback: item.feedback || void 0,
          autoApprovalEligible: item.autoApprovalEligible
        }));
      }
      /**
       * Get review statistics for a partner
       * Requirements: 6.5
       */
      async getPartnerReviewStats(partnerId) {
        const items = await db.query.contentApprovalQueue.findMany({
          where: eq44(contentApprovalQueue.partnerId, partnerId)
        });
        const total = items.length;
        const approved = items.filter((i) => i.status === "approved").length;
        const rejected = items.filter((i) => i.status === "rejected").length;
        const pending = items.filter((i) => i.status === "pending").length;
        const revisionRequested = items.filter((i) => i.status === "revision_requested").length;
        const approvalRate = total > 0 ? approved / total * 100 : 0;
        return {
          total,
          approved,
          rejected,
          pending,
          revisionRequested,
          approvalRate: Math.round(approvalRate * 100) / 100
        };
      }
      /**
       * Get approval queue with filters
       * Requirements: 6.1, 6.2, 6.3
       */
      async getApprovalQueue(filters = {}) {
        const conditions = [];
        if (filters.status) {
          conditions.push(eq44(contentApprovalQueue.status, filters.status));
        }
        if (filters.partnerId) {
          conditions.push(eq44(contentApprovalQueue.partnerId, filters.partnerId));
        }
        const whereClause = conditions.length > 0 ? and37(...conditions) : void 0;
        const items = await db.query.contentApprovalQueue.findMany({
          where: whereClause,
          orderBy: [desc29(contentApprovalQueue.submittedAt)],
          limit: filters.limit || 50,
          offset: filters.offset || 0
        });
        return items.map((item) => ({
          id: item.id,
          contentId: item.contentId,
          partnerId: item.partnerId,
          status: item.status,
          submittedAt: new Date(item.submittedAt),
          reviewedAt: item.reviewedAt ? new Date(item.reviewedAt) : void 0,
          reviewerId: item.reviewerId || void 0,
          feedback: item.feedback || void 0,
          autoApprovalEligible: item.autoApprovalEligible
        }));
      }
      /**
       * Validate content rules against partner tier permissions
       * Requirements: 1.6, 15.2, 15.3
       */
      async validateContentRules(content, partner) {
        const errors = [];
        const tier = await db.query.partnerTiers.findFirst({
          where: eq44(partnerTiers.id, partner.tierId)
        });
        if (!tier) {
          errors.push("Partner tier not found");
          return { isValid: false, errors };
        }
        const allowedContentTypes = typeof tier.allowedContentTypes === "string" ? JSON.parse(tier.allowedContentTypes) : tier.allowedContentTypes;
        const allowedCTAs = typeof tier.allowedCTAs === "string" ? JSON.parse(tier.allowedCTAs) : tier.allowedCTAs;
        if (!allowedContentTypes.includes(content.contentType)) {
          errors.push(
            `Content type "${content.contentType}" not allowed for tier "${tier.name}". Allowed types: ${allowedContentTypes.join(", ")}`
          );
        }
        if (content.ctas && content.ctas.length > 0) {
          const invalidCTAs = content.ctas.filter((cta) => !allowedCTAs.includes(cta));
          if (invalidCTAs.length > 0) {
            errors.push(
              `CTAs not allowed for tier "${tier.name}": ${invalidCTAs.join(", ")}. Allowed CTAs: ${allowedCTAs.join(", ")}`
            );
          }
        }
        if (!content.metadata) {
          errors.push("Content metadata is required");
        } else {
          const requiredFields = ["title", "description"];
          const missingFields = requiredFields.filter((field) => !content.metadata[field]);
          if (missingFields.length > 0) {
            errors.push(`Missing required metadata fields: ${missingFields.join(", ")}`);
          }
          if (content.metadata.title && content.metadata.title.length < 10) {
            errors.push("Title must be at least 10 characters long");
          }
          if (content.metadata.title && content.metadata.title.length > 255) {
            errors.push("Title must not exceed 255 characters");
          }
          if (content.metadata.description && content.metadata.description.length < 20) {
            errors.push("Description must be at least 20 characters long");
          }
          if (content.metadata.description) {
            const promotionalKeywords = [
              "buy now",
              "limited time",
              "act fast",
              "don't miss",
              "exclusive offer",
              "special deal",
              "hurry"
            ];
            const hasPromotionalLanguage = promotionalKeywords.some(
              (keyword) => content.metadata.description.toLowerCase().includes(keyword)
            );
            if (hasPromotionalLanguage) {
              errors.push(
                `Content appears to be purely promotional. Please add educational value. Ask yourself: "Would I watch this even if I wasn't buying?"`
              );
            }
          }
        }
        return {
          isValid: errors.length === 0,
          errors
        };
      }
      /**
       * Validate content type against tier permissions
       * Requirements: 1.6
       */
      async validateContentType(contentType, tierId) {
        const tier = await db.query.partnerTiers.findFirst({
          where: eq44(partnerTiers.id, tierId)
        });
        if (!tier) {
          return false;
        }
        const allowedContentTypes = typeof tier.allowedContentTypes === "string" ? JSON.parse(tier.allowedContentTypes) : tier.allowedContentTypes;
        return allowedContentTypes.includes(contentType);
      }
      /**
       * Validate CTAs against tier permissions
       * Requirements: 1.6
       */
      async validateCTAs(ctas, tierId) {
        const tier = await db.query.partnerTiers.findFirst({
          where: eq44(partnerTiers.id, tierId)
        });
        if (!tier) {
          return { isValid: false, invalidCTAs: ctas };
        }
        const allowedCTAs = typeof tier.allowedCTAs === "string" ? JSON.parse(tier.allowedCTAs) : tier.allowedCTAs;
        const invalidCTAs = ctas.filter((cta) => !allowedCTAs.includes(cta));
        return {
          isValid: invalidCTAs.length === 0,
          invalidCTAs
        };
      }
      /**
       * Validate metadata completeness
       * Requirements: 15.3
       */
      validateMetadataCompleteness(metadata) {
        const requiredFields = ["title", "description"];
        const missingFields = requiredFields.filter((field) => !metadata || !metadata[field]);
        return {
          isValid: missingFields.length === 0,
          missingFields
        };
      }
    };
    contentApprovalService = new ContentApprovalService();
  }
});

// server/contentRouter.ts
var contentRouter_exports = {};
__export(contentRouter_exports, {
  default: () => contentRouter_default
});
import { Router as Router4 } from "express";
var router6, contentRouter_default;
var init_contentRouter = __esm({
  "server/contentRouter.ts"() {
    "use strict";
    init_contentApprovalService();
    init_auth();
    router6 = Router4();
    router6.post("/submit", requireAuth, async (req, res) => {
      try {
        const { contentId, partnerId } = req.body;
        if (!contentId || !partnerId) {
          return res.status(400).json({
            error: "Missing required fields: contentId, partnerId"
          });
        }
        const { partnerService: partnerService2 } = await Promise.resolve().then(() => (init_partnerService(), partnerService_exports));
        const partner = await partnerService2.getPartnerProfile(partnerId);
        if (!partner) {
          return res.status(404).json({ error: "Partner not found" });
        }
        if (partner.userId !== req.user.id) {
          return res.status(403).json({ error: "Unauthorized: You don't own this partner account" });
        }
        const queueItem = await contentApprovalService.submitForApproval(contentId, partnerId);
        res.status(201).json(queueItem);
      } catch (error) {
        console.error("Error submitting content for approval:", error);
        if (error.message === "Partner not found") {
          return res.status(404).json({ error: error.message });
        }
        if (error.message === "Content already submitted for approval") {
          return res.status(409).json({ error: error.message });
        }
        res.status(400).json({ error: error.message });
      }
    });
    router6.get("/approval-queue", requireAuth, async (req, res) => {
      try {
        if (req.user.role !== "super_admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const { status, partnerId, limit, offset } = req.query;
        const filters = {};
        if (status) {
          filters.status = status;
        }
        if (partnerId) {
          filters.partnerId = partnerId;
        }
        if (limit) {
          filters.limit = parseInt(limit);
        }
        if (offset) {
          filters.offset = parseInt(offset);
        }
        const queue = await contentApprovalService.getApprovalQueue(filters);
        res.json(queue);
      } catch (error) {
        console.error("Error fetching approval queue:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router6.post("/:id/review", requireAuth, async (req, res) => {
      try {
        if (req.user.role !== "super_admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const { id } = req.params;
        const { status, feedback, violationTypes } = req.body;
        if (!status) {
          return res.status(400).json({ error: "Missing required field: status" });
        }
        if (!["approved", "rejected", "revision_requested"].includes(status)) {
          return res.status(400).json({
            error: "Invalid status. Must be one of: approved, rejected, revision_requested"
          });
        }
        if ((status === "rejected" || status === "revision_requested") && !feedback) {
          return res.status(400).json({
            error: "Feedback is required for rejected or revision-requested content"
          });
        }
        await contentApprovalService.reviewContent(
          id,
          {
            status,
            feedback,
            violationTypes
          },
          req.user.id
        );
        res.json({ message: "Content reviewed successfully" });
      } catch (error) {
        console.error("Error reviewing content:", error);
        if (error.message === "Queue item not found") {
          return res.status(404).json({ error: error.message });
        }
        res.status(500).json({ error: error.message });
      }
    });
    router6.post("/:id/flag", requireAuth, async (req, res) => {
      try {
        const { id } = req.params;
        const { reason } = req.body;
        if (!reason) {
          return res.status(400).json({ error: "Missing required field: reason" });
        }
        if (reason.length < 10) {
          return res.status(400).json({
            error: "Reason must be at least 10 characters long"
          });
        }
        await contentApprovalService.flagContent(id, reason, req.user.id);
        res.json({ message: "Content flagged successfully" });
      } catch (error) {
        console.error("Error flagging content:", error);
        if (error.message === "Content not found") {
          return res.status(404).json({ error: error.message });
        }
        res.status(500).json({ error: error.message });
      }
    });
    router6.get("/partner/:partnerId/stats", requireAuth, async (req, res) => {
      try {
        const { partnerId } = req.params;
        const { partnerService: partnerService2 } = await Promise.resolve().then(() => (init_partnerService(), partnerService_exports));
        const partner = await partnerService2.getPartnerProfile(partnerId);
        if (!partner) {
          return res.status(404).json({ error: "Partner not found" });
        }
        if (partner.userId !== req.user.id && req.user.role !== "super_admin") {
          return res.status(403).json({ error: "Unauthorized" });
        }
        const stats2 = await contentApprovalService.getPartnerReviewStats(partnerId);
        res.json(stats2);
      } catch (error) {
        console.error("Error fetching partner review stats:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router6.post("/validate", requireAuth, async (req, res) => {
      try {
        const { contentId, partnerId, contentType, metadata, ctas } = req.body;
        if (!partnerId || !contentType) {
          return res.status(400).json({
            error: "Missing required fields: partnerId, contentType"
          });
        }
        const { partnerService: partnerService2 } = await Promise.resolve().then(() => (init_partnerService(), partnerService_exports));
        const partner = await partnerService2.getPartnerProfile(partnerId);
        if (!partner) {
          return res.status(404).json({ error: "Partner not found" });
        }
        if (partner.userId !== req.user.id) {
          return res.status(403).json({ error: "Unauthorized" });
        }
        const validation = await contentApprovalService.validateContentRules(
          {
            contentId: contentId || "preview",
            partnerId,
            contentType,
            metadata,
            ctas
          },
          partner
        );
        res.json(validation);
      } catch (error) {
        console.error("Error validating content:", error);
        res.status(500).json({ error: error.message });
      }
    });
    contentRouter_default = router6;
  }
});

// server/services/topicsService.ts
import { eq as eq45, and as and38, inArray as inArray11, sql as sql33, desc as desc30, asc as asc4 } from "drizzle-orm";
var TopicsService, topicsService;
var init_topicsService = __esm({
  "server/services/topicsService.ts"() {
    "use strict";
    init_db();
    init_schema();
    TopicsService = class {
      /**
       * Get all active topics ordered by display order
       * Requirement 3.1: Display horizontal scrollable list of Topics
       */
      async getAllTopics() {
        const result = await db.select().from(topics).where(eq45(topics.isActive, true)).orderBy(asc4(topics.displayOrder), asc4(topics.name));
        return result.map(this.mapTopicFromDb);
      }
      /**
       * Get a single topic by its slug for URL routing
       * Requirement 3.1: Support URL routing with topic slugs
       */
      async getTopicBySlug(slug) {
        const result = await db.select().from(topics).where(and38(
          eq45(topics.slug, slug),
          eq45(topics.isActive, true)
        )).limit(1);
        if (result.length === 0) {
          return null;
        }
        return this.mapTopicFromDb(result[0]);
      }
      /**
       * Get a single topic by its ID
       */
      async getTopicById(topicId) {
        const result = await db.select().from(topics).where(eq45(topics.id, topicId)).limit(1);
        if (result.length === 0) {
          return null;
        }
        return this.mapTopicFromDb(result[0]);
      }
      /**
       * Get content count for a specific topic
       * Used to determine if topic has sufficient content (min 20 items)
       * Requirements: 3.6, 16.36
       */
      async getTopicContentCount(topicId) {
        const result = await db.select({ count: sql33`count(*)` }).from(contentTopics).where(eq45(contentTopics.topicId, topicId));
        return result[0]?.count || 0;
      }
      /**
       * Get related topics for a given topic
       * Used when a topic has insufficient content
       * Requirement 3.6: Suggest related topics when content is insufficient
       */
      async getRelatedTopics(topicId, limit = 3) {
        const currentTopic = await this.getTopicById(topicId);
        if (!currentTopic) {
          return [];
        }
        const allTopics = await this.getAllTopics();
        const scoredTopics = allTopics.filter((t2) => t2.id !== topicId).map((topic) => {
          let score = 0;
          if (currentTopic.contentTags && topic.contentTags) {
            const overlap = currentTopic.contentTags.filter(
              (tag) => topic.contentTags?.includes(tag)
            );
            score += overlap.length * 3;
          }
          if (currentTopic.propertyFeatures && topic.propertyFeatures) {
            const overlap = currentTopic.propertyFeatures.filter(
              (feature) => topic.propertyFeatures?.includes(feature)
            );
            score += overlap.length * 2;
          }
          if (currentTopic.partnerCategories && topic.partnerCategories) {
            const overlap = currentTopic.partnerCategories.filter(
              (category) => topic.partnerCategories?.includes(category)
            );
            score += overlap.length * 2;
          }
          return { topic, score };
        }).filter((item) => item.score > 0).sort((a, b) => b.score - a.score).slice(0, limit).map((item) => item.topic);
        return scoredTopics;
      }
      /**
       * Check if a topic has sufficient content (minimum 20 items)
       * Requirements: 3.6, 16.36
       */
      async hasSufficientContent(topicId) {
        const count9 = await this.getTopicContentCount(topicId);
        return count9 >= 20;
      }
      /**
       * Map database topic to service interface
       */
      mapTopicFromDb(dbTopic) {
        return {
          id: dbTopic.id,
          slug: dbTopic.slug,
          name: dbTopic.name,
          description: dbTopic.description,
          icon: dbTopic.icon,
          displayOrder: dbTopic.displayOrder,
          isActive: dbTopic.isActive,
          contentTags: dbTopic.contentTags,
          propertyFeatures: dbTopic.propertyFeatures,
          partnerCategories: dbTopic.partnerCategories,
          createdAt: dbTopic.createdAt
        };
      }
      /**
       * Get content for a specific topic with filtering
       * Filters by content_tags, property_features, partner_categories
       * Applies to all content types (videos, cards, neighbourhoods)
       * Requirements: 3.2, 3.3, 3.4
       */
      async getContentForTopic(topicId, pagination, filters) {
        const topic = await this.getTopicById(topicId);
        if (!topic) {
          return [];
        }
        const offset = (pagination.page - 1) * pagination.limit;
        const taggedContentIds = await db.select({ contentId: contentTopics.contentId }).from(contentTopics).where(eq45(contentTopics.topicId, topicId));
        const taggedIds = taggedContentIds.map((item) => item.contentId);
        const conditions = [eq45(exploreContent.isActive, 1)];
        if (taggedIds.length > 0) {
          conditions.push(
            sql33`${exploreContent.id} IN ${taggedIds.map((id) => parseInt(id))}`
          );
        } else {
          const tagConditions = [];
          if (topic.contentTags && topic.contentTags.length > 0) {
            for (const tag of topic.contentTags) {
              tagConditions.push(
                sql33`JSON_CONTAINS(${exploreContent.tags}, JSON_QUOTE(${tag}))`
              );
            }
          }
          if (topic.propertyFeatures && topic.propertyFeatures.length > 0) {
            for (const feature of topic.propertyFeatures) {
              tagConditions.push(
                sql33`JSON_CONTAINS(${exploreContent.metadata}, JSON_QUOTE(${feature}), '$.propertyFeatures')`
              );
            }
          }
          if (topic.partnerCategories && topic.partnerCategories.length > 0) {
            for (const category of topic.partnerCategories) {
              tagConditions.push(
                sql33`JSON_CONTAINS(${exploreContent.metadata}, JSON_QUOTE(${category}), '$.partnerCategory')`
              );
            }
          }
          if (tagConditions.length > 0) {
            conditions.push(sql33`(${sql33.join(tagConditions, sql33` OR `)})`);
          }
        }
        if (filters?.contentTypes && filters.contentTypes.length > 0) {
          conditions.push(inArray11(exploreContent.contentType, filters.contentTypes));
        }
        if (filters?.priceMin !== void 0) {
          conditions.push(sql33`${exploreContent.priceMin} >= ${filters.priceMin}`);
        }
        if (filters?.priceMax !== void 0) {
          conditions.push(sql33`${exploreContent.priceMax} <= ${filters.priceMax}`);
        }
        const content = await db.select().from(exploreContent).where(and38(...conditions)).orderBy(desc30(exploreContent.engagementScore), desc30(exploreContent.createdAt)).limit(pagination.limit).offset(offset);
        return content;
      }
      /**
       * Get shorts (videos) for a specific topic
       * Requirements: 3.2, 3.3, 3.4
       */
      async getShortsForTopic(topicId, pagination, filters) {
        const topic = await this.getTopicById(topicId);
        if (!topic) {
          return [];
        }
        const offset = (pagination.page - 1) * pagination.limit;
        const conditions = [
          eq45(exploreShorts.isPublished, 1)
        ];
        const tagConditions = [];
        if (filters?.contentTypes && filters.contentTypes.length > 0) {
          conditions.push(inArray11(exploreShorts.contentType, filters.contentTypes));
        }
        if (topic.contentTags && topic.contentTags.length > 0) {
          for (const tag of topic.contentTags) {
            tagConditions.push(
              sql33`JSON_CONTAINS(${exploreShorts.highlights}, JSON_QUOTE(${tag}))`
            );
          }
        }
        if (tagConditions.length > 0) {
          conditions.push(sql33`(${sql33.join(tagConditions, sql33` OR `)})`);
        }
        const shorts = await db.select().from(exploreShorts).where(and38(...conditions)).orderBy(desc30(exploreShorts.performanceScore), desc30(exploreShorts.publishedAt)).limit(pagination.limit).offset(offset);
        return shorts;
      }
      /**
       * Tag content with topics and calculate relevance scores
       * Creates content-topic mapping with relevance scoring
       * Requirement 3.2: Create tagContentWithTopics() for content-topic mapping
       */
      async tagContentWithTopics(contentId, topicIds, contentData) {
        await db.delete(contentTopics).where(eq45(contentTopics.contentId, contentId));
        for (const topicId of topicIds) {
          const topic = await this.getTopicById(topicId);
          if (!topic) continue;
          const relevanceScore = this.calculateRelevanceScore(topic, contentData);
          await db.insert(contentTopics).values({
            contentId,
            topicId,
            relevanceScore: relevanceScore.toString(),
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      }
      /**
       * Calculate relevance score for content-topic mapping
       * Score is based on matching tags, features, and categories
       * Requirement 3.2: Calculate relevance scores
       */
      calculateRelevanceScore(topic, contentData) {
        if (!contentData) return 1;
        let score = 0;
        let maxScore = 0;
        if (topic.contentTags && contentData.tags) {
          maxScore += topic.contentTags.length * 3;
          const matches = topic.contentTags.filter(
            (tag) => contentData.tags?.includes(tag)
          ).length;
          score += matches * 3;
        }
        if (topic.propertyFeatures && contentData.propertyFeatures) {
          maxScore += topic.propertyFeatures.length * 2;
          const matches = topic.propertyFeatures.filter(
            (feature) => contentData.propertyFeatures?.includes(feature)
          ).length;
          score += matches * 2;
        }
        if (topic.partnerCategories && contentData.partnerCategory) {
          maxScore += 5;
          if (topic.partnerCategories.includes(contentData.partnerCategory)) {
            score += 5;
          }
        }
        if (maxScore === 0) return 1;
        const normalizedScore = score / maxScore * 10;
        return Math.max(0.1, Math.min(10, normalizedScore));
      }
      /**
       * Auto-tag content based on its attributes
       * Automatically suggests topics for content based on tags, features, and categories
       * Requirement 3.2: Intelligent topic suggestion
       */
      async suggestTopicsForContent(contentData) {
        const allTopics = await this.getAllTopics();
        const scoredTopics = allTopics.map((topic) => ({
          topicId: topic.id,
          relevanceScore: this.calculateRelevanceScore(topic, contentData)
        })).filter((item) => item.relevanceScore >= 3).sort((a, b) => b.relevanceScore - a.relevanceScore);
        return scoredTopics;
      }
      /**
       * Get topic feed with insufficient content handling
       * Shows "Coming Soon" for topics with <20 items and suggests related topics
       * Requirements: 3.6, 16.36
       */
      async getTopicFeedWithFallback(topicId, pagination, filters) {
        const topic = await this.getTopicById(topicId);
        if (!topic) {
          return {
            topic: null,
            hasSufficientContent: false,
            content: [],
            shorts: [],
            relatedTopics: [],
            message: "Topic not found"
          };
        }
        const hasSufficientContent = await this.hasSufficientContent(topicId);
        if (!hasSufficientContent) {
          const relatedTopics = await this.getRelatedTopics(topicId, 3);
          return {
            topic,
            hasSufficientContent: false,
            content: [],
            shorts: [],
            relatedTopics,
            message: "Coming Soon - This topic doesn't have enough content yet. Check out these related topics!"
          };
        }
        const { content, shorts } = await this.getAllContentForTopic(topicId, pagination, filters);
        return {
          topic,
          hasSufficientContent: true,
          content,
          shorts,
          relatedTopics: []
        };
      }
      /**
       * Get topic statistics including content count and readiness
       * Requirements: 3.6, 16.36
       */
      async getTopicStatistics(topicId) {
        const contentCount = await this.getTopicContentCount(topicId);
        const minimumRequired = 20;
        const hasSufficientContent = contentCount >= minimumRequired;
        const percentageComplete = Math.min(100, contentCount / minimumRequired * 100);
        return {
          topicId,
          contentCount,
          hasSufficientContent,
          minimumRequired,
          percentageComplete
        };
      }
      /**
       * Get all topics with their content counts and readiness status
       * Useful for admin dashboards to monitor topic health
       * Requirements: 3.6, 16.36
       */
      async getAllTopicsWithStatistics() {
        const allTopics = await this.getAllTopics();
        const topicsWithStats = await Promise.all(
          allTopics.map(async (topic) => {
            const statistics = await this.getTopicStatistics(topic.id);
            return { topic, statistics };
          })
        );
        return topicsWithStats;
      }
      /**
       * Get all topics for a specific content item
       */
      async getTopicsForContent(contentId) {
        const mappings = await db.select({
          topicId: contentTopics.topicId,
          relevanceScore: contentTopics.relevanceScore
        }).from(contentTopics).where(eq45(contentTopics.contentId, contentId)).orderBy(desc30(contentTopics.relevanceScore));
        const topicIds = mappings.map((m) => m.topicId);
        if (topicIds.length === 0) return [];
        const topicsData = await db.select().from(topics).where(inArray11(topics.id, topicIds));
        return topicsData.map(this.mapTopicFromDb);
      }
      /**
       * Get all content types for a topic (combines explore_content and explore_shorts)
       * Requirements: 3.2, 3.4
       */
      async getAllContentForTopic(topicId, pagination, filters) {
        const [content, shorts] = await Promise.all([
          this.getContentForTopic(topicId, pagination, filters),
          this.getShortsForTopic(topicId, { page: pagination.page, limit: Math.floor(pagination.limit / 2) }, filters)
        ]);
        return { content, shorts };
      }
    };
    topicsService = new TopicsService();
  }
});

// server/topicsRouter.ts
var topicsRouter_exports = {};
__export(topicsRouter_exports, {
  default: () => topicsRouter_default
});
import { Router as Router5 } from "express";
var router7, topicsService2, topicsRouter_default;
var init_topicsRouter = __esm({
  "server/topicsRouter.ts"() {
    "use strict";
    init_topicsService();
    router7 = Router5();
    topicsService2 = new TopicsService();
    router7.get("/", async (req, res) => {
      try {
        const topics2 = await topicsService2.getAllTopics();
        res.json(topics2);
      } catch (error) {
        console.error("Error fetching topics:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router7.get("/:slug", async (req, res) => {
      try {
        const { slug } = req.params;
        const topic = await topicsService2.getTopicBySlug(slug);
        if (!topic) {
          return res.status(404).json({ error: "Topic not found" });
        }
        const hasSufficientContent = await topicsService2.hasSufficientContent(topic.id);
        let relatedTopics = [];
        if (!hasSufficientContent) {
          relatedTopics = await topicsService2.getRelatedTopics(topic.id);
        }
        res.json({
          topic,
          hasSufficientContent,
          relatedTopics: hasSufficientContent ? [] : relatedTopics
        });
      } catch (error) {
        console.error("Error fetching topic:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router7.get("/:slug/feed", async (req, res) => {
      try {
        const { slug } = req.params;
        const {
          page = "1",
          limit = "20",
          contentTypes,
          priceMin,
          priceMax,
          includeShorts = "false"
        } = req.query;
        const topic = await topicsService2.getTopicBySlug(slug);
        if (!topic) {
          return res.status(404).json({ error: "Topic not found" });
        }
        const contentCount = await topicsService2.getTopicContentCount(topic.id);
        if (contentCount < 20) {
          const relatedTopics = await topicsService2.getRelatedTopics(topic.id);
          return res.json({
            content: [],
            shorts: [],
            message: "Coming Soon",
            suggestion: "This topic doesn't have enough content yet. Try these related topics:",
            relatedTopics,
            pagination: {
              page: parseInt(page),
              limit: parseInt(limit),
              total: 0,
              hasMore: false
            }
          });
        }
        const filters = {};
        if (contentTypes) {
          filters.contentTypes = contentTypes.split(",");
        }
        if (priceMin) {
          filters.priceMin = parseFloat(priceMin);
        }
        if (priceMax) {
          filters.priceMax = parseFloat(priceMax);
        }
        const content = await topicsService2.getContentForTopic(
          topic.id,
          {
            page: parseInt(page),
            limit: parseInt(limit)
          },
          filters
        );
        let shorts = [];
        if (includeShorts === "true") {
          shorts = await topicsService2.getShortsForTopic(
            topic.id,
            {
              page: parseInt(page),
              limit: Math.floor(parseInt(limit) / 4)
              // 25% shorts
            },
            filters
          );
        }
        res.json({
          content,
          shorts,
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total: contentCount,
            hasMore: content.length === parseInt(limit)
          }
        });
      } catch (error) {
        console.error("Error fetching topic feed:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router7.get("/:slug/content-count", async (req, res) => {
      try {
        const { slug } = req.params;
        const topic = await topicsService2.getTopicBySlug(slug);
        if (!topic) {
          return res.status(404).json({ error: "Topic not found" });
        }
        const count9 = await topicsService2.getTopicContentCount(topic.id);
        const hasSufficientContent = count9 >= 20;
        res.json({
          topicId: topic.id,
          count: count9,
          hasSufficientContent,
          minimumRequired: 20
        });
      } catch (error) {
        console.error("Error fetching topic content count:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router7.get("/:slug/related", async (req, res) => {
      try {
        const { slug } = req.params;
        const { limit = "3" } = req.query;
        const topic = await topicsService2.getTopicBySlug(slug);
        if (!topic) {
          return res.status(404).json({ error: "Topic not found" });
        }
        const relatedTopics = await topicsService2.getRelatedTopics(
          topic.id,
          parseInt(limit)
        );
        res.json(relatedTopics);
      } catch (error) {
        console.error("Error fetching related topics:", error);
        res.status(500).json({ error: error.message });
      }
    });
    topicsRouter_default = router7;
  }
});

// server/services/partnerSubscriptionService.ts
import { nanoid as nanoid4 } from "nanoid";
function getSubscriptionTierPricing() {
  return Object.values(TIER_PRICING);
}
function getTierPricing(tier) {
  return TIER_PRICING[tier];
}
async function getPartnerSubscription(partnerId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [rows] = await db3.execute(
    `SELECT * FROM partner_subscriptions 
     WHERE partner_id = ? AND status = 'active'
     ORDER BY created_at DESC LIMIT 1`,
    [partnerId]
  );
  const subscriptions = rows;
  if (subscriptions.length === 0) return null;
  return parseSubscription(subscriptions[0]);
}
async function getPartnerSubscriptionHistory(partnerId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [rows] = await db3.execute(
    `SELECT * FROM partner_subscriptions 
     WHERE partner_id = ?
     ORDER BY created_at DESC`,
    [partnerId]
  );
  return rows.map(parseSubscription);
}
async function createSubscription(partnerId, tier) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  if (!TIER_PRICING[tier]) {
    throw new Error(`Invalid subscription tier: ${tier}`);
  }
  const pricing = TIER_PRICING[tier];
  const id = nanoid4();
  const startDate = /* @__PURE__ */ new Date();
  await db3.execute(
    `INSERT INTO partner_subscriptions 
     (id, partner_id, tier, price_monthly, start_date, status, features)
     VALUES (?, ?, ?, ?, ?, 'active', ?)`,
    [
      id,
      partnerId,
      tier,
      pricing.price_monthly,
      startDate,
      JSON.stringify(pricing.features)
    ]
  );
  const subscription = await getPartnerSubscription(partnerId);
  if (!subscription) {
    throw new Error("Failed to create subscription");
  }
  return subscription;
}
async function upgradeSubscription2(subscriptionId, newTier) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  if (!TIER_PRICING[newTier]) {
    throw new Error(`Invalid subscription tier: ${newTier}`);
  }
  const pricing = TIER_PRICING[newTier];
  await db3.execute(
    `UPDATE partner_subscriptions 
     SET tier = ?, 
         price_monthly = ?, 
         features = ?,
         updated_at = CURRENT_TIMESTAMP
     WHERE id = ? AND status = 'active'`,
    [newTier, pricing.price_monthly, JSON.stringify(pricing.features), subscriptionId]
  );
}
async function cancelSubscription(subscriptionId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [rows] = await db3.execute(
    `SELECT partner_id FROM partner_subscriptions WHERE id = ?`,
    [subscriptionId]
  );
  const subscriptions = rows;
  if (subscriptions.length === 0) {
    throw new Error("Subscription not found");
  }
  const partnerId = subscriptions[0].partner_id;
  await db3.execute(
    `UPDATE partner_subscriptions 
     SET status = 'cancelled', 
         end_date = CURRENT_DATE,
         updated_at = CURRENT_TIMESTAMP
     WHERE id = ?`,
    [subscriptionId]
  );
  await createSubscription(partnerId, "basic");
}
async function checkFeatureAccess2(partnerId, feature) {
  const subscription = await getPartnerSubscription(partnerId);
  if (!subscription) {
    const freeTier = TIER_PRICING.free;
    return freeTier.features[feature] !== void 0;
  }
  return subscription.features[feature] !== void 0;
}
async function getFeatureValue(partnerId, feature) {
  const subscription = await getPartnerSubscription(partnerId);
  if (!subscription) {
    return TIER_PRICING.free.features[feature];
  }
  return subscription.features[feature];
}
async function canPerformAction(partnerId, action) {
  const subscription = await getPartnerSubscription(partnerId);
  const tier = subscription?.tier || "free";
  const features = subscription?.features || TIER_PRICING.free.features;
  switch (action) {
    case "create_content":
      const contentCount = await getMonthlyContentCount(partnerId);
      if (contentCount >= features.max_monthly_content) {
        return {
          allowed: false,
          reason: `Monthly content limit reached (${features.max_monthly_content})`
        };
      }
      return { allowed: true };
    case "boost_content":
      return { allowed: true };
    case "view_analytics":
      return { allowed: true };
    case "contact_support":
      if (features.support_level === "community") {
        return {
          allowed: true,
          reason: "Community support only (forum/docs)"
        };
      }
      return { allowed: true };
    default:
      return { allowed: false, reason: "Unknown action" };
  }
}
async function getMonthlyContentCount(partnerId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [rows] = await db3.execute(
    `SELECT COUNT(*) as count 
     FROM explore_content 
     WHERE partner_id = ? 
     AND MONTH(created_at) = MONTH(CURRENT_DATE)
     AND YEAR(created_at) = YEAR(CURRENT_DATE)`,
    [partnerId]
  );
  const result = rows;
  return result[0]?.count || 0;
}
function parseSubscription(row) {
  return {
    id: row.id,
    partner_id: row.partner_id,
    tier: row.tier,
    price_monthly: parseFloat(row.price_monthly),
    start_date: new Date(row.start_date),
    end_date: row.end_date ? new Date(row.end_date) : void 0,
    status: row.status,
    features: typeof row.features === "string" ? JSON.parse(row.features) : row.features,
    created_at: new Date(row.created_at)
  };
}
var TIER_PRICING;
var init_partnerSubscriptionService = __esm({
  "server/services/partnerSubscriptionService.ts"() {
    "use strict";
    init_db();
    TIER_PRICING = {
      free: {
        tier: "free",
        price_monthly: 0,
        display_name: "Free",
        description: "Limited features with reduced visibility",
        features: {
          profile_type: "standard",
          analytics_level: "basic",
          support_level: "community",
          organic_reach_multiplier: 0.5,
          max_monthly_content: 5,
          boost_discount_percent: 0
        }
      },
      basic: {
        tier: "basic",
        price_monthly: 500,
        display_name: "Basic",
        description: "Standard profile with basic analytics and organic reach",
        features: {
          profile_type: "standard",
          analytics_level: "basic",
          support_level: "community",
          organic_reach_multiplier: 1,
          max_monthly_content: 20,
          boost_discount_percent: 0
        }
      },
      premium: {
        tier: "premium",
        price_monthly: 2e3,
        display_name: "Premium",
        description: "Enhanced profile with detailed analytics and priority support",
        features: {
          profile_type: "enhanced",
          analytics_level: "detailed",
          support_level: "priority",
          organic_reach_multiplier: 1.5,
          max_monthly_content: 50,
          boost_discount_percent: 10
        }
      },
      featured: {
        tier: "featured",
        price_monthly: 5e3,
        display_name: "Featured",
        description: "Premium placement with advanced analytics and dedicated support",
        features: {
          profile_type: "premium",
          analytics_level: "advanced",
          support_level: "dedicated",
          organic_reach_multiplier: 2,
          max_monthly_content: 100,
          boost_discount_percent: 20
        }
      }
    };
  }
});

// server/middleware/partnerFeatureAccess.ts
async function attachPartnerSubscription(req, res, next) {
  try {
    const partnerId = req.body.partner_id || req.params.partnerId || req.query.partnerId;
    if (!partnerId) {
      return next();
    }
    const subscription = await getPartnerSubscription(partnerId);
    req.partnerSubscription = subscription;
    next();
  } catch (error) {
    console.error("Failed to attach subscription:", error);
    next();
  }
}
async function getPartnerFeatureAccess(partnerId) {
  const subscription = await getPartnerSubscription(partnerId);
  const tier = subscription?.tier || "free";
  const features = subscription?.features || {
    profile_type: "standard",
    analytics_level: "basic",
    support_level: "community",
    organic_reach_multiplier: 0.5,
    max_monthly_content: 5,
    boost_discount_percent: 0
  };
  const actions = {
    create_content: await canPerformAction(partnerId, "create_content"),
    boost_content: await canPerformAction(partnerId, "boost_content"),
    view_analytics: await canPerformAction(partnerId, "view_analytics"),
    contact_support: await canPerformAction(partnerId, "contact_support")
  };
  return {
    tier,
    features,
    actions
  };
}
function validateTierTransition(currentTier, newTier) {
  const validTiers = ["free", "basic", "premium", "featured"];
  if (!validTiers.includes(currentTier)) {
    return { valid: false, reason: "Invalid current tier" };
  }
  if (!validTiers.includes(newTier)) {
    return { valid: false, reason: "Invalid new tier" };
  }
  if (newTier === "free") {
    return { valid: false, reason: "Cannot upgrade to free tier" };
  }
  return { valid: true };
}
var init_partnerFeatureAccess = __esm({
  "server/middleware/partnerFeatureAccess.ts"() {
    "use strict";
    init_partnerSubscriptionService();
  }
});

// server/partnerSubscriptionRouter.ts
var partnerSubscriptionRouter_exports = {};
__export(partnerSubscriptionRouter_exports, {
  default: () => partnerSubscriptionRouter_default
});
import express3 from "express";
var router8, partnerSubscriptionRouter_default;
var init_partnerSubscriptionRouter = __esm({
  "server/partnerSubscriptionRouter.ts"() {
    "use strict";
    init_partnerSubscriptionService();
    init_partnerFeatureAccess();
    router8 = express3.Router();
    router8.get("/pricing", async (req, res) => {
      try {
        const pricing = getSubscriptionTierPricing();
        res.json(pricing);
      } catch (error) {
        console.error("Failed to get pricing:", error);
        res.status(500).json({ error: "Failed to retrieve pricing information" });
      }
    });
    router8.get("/pricing/:tier", async (req, res) => {
      try {
        const tier = req.params.tier;
        const pricing = getTierPricing(tier);
        if (!pricing) {
          return res.status(404).json({ error: "Tier not found" });
        }
        res.json(pricing);
      } catch (error) {
        console.error("Failed to get tier pricing:", error);
        res.status(500).json({ error: "Failed to retrieve tier pricing" });
      }
    });
    router8.get("/partner/:partnerId", attachPartnerSubscription, async (req, res) => {
      try {
        const { partnerId } = req.params;
        const subscription = await getPartnerSubscription(partnerId);
        if (!subscription) {
          return res.status(404).json({
            error: "No active subscription found",
            message: "Partner is on free tier"
          });
        }
        res.json(subscription);
      } catch (error) {
        console.error("Failed to get subscription:", error);
        res.status(500).json({ error: "Failed to retrieve subscription" });
      }
    });
    router8.get("/partner/:partnerId/history", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const history = await getPartnerSubscriptionHistory(partnerId);
        res.json(history);
      } catch (error) {
        console.error("Failed to get subscription history:", error);
        res.status(500).json({ error: "Failed to retrieve subscription history" });
      }
    });
    router8.get("/partner/:partnerId/features", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const features = await getPartnerFeatureAccess(partnerId);
        res.json(features);
      } catch (error) {
        console.error("Failed to get feature access:", error);
        res.status(500).json({ error: "Failed to retrieve feature access" });
      }
    });
    router8.post("/", async (req, res) => {
      try {
        const { partner_id, tier } = req.body;
        if (!partner_id || !tier) {
          return res.status(400).json({
            error: "Missing required fields",
            required: ["partner_id", "tier"]
          });
        }
        const validTiers = ["basic", "premium", "featured"];
        if (!validTiers.includes(tier)) {
          return res.status(400).json({
            error: "Invalid tier",
            message: "Tier must be one of: basic, premium, featured",
            valid_tiers: validTiers
          });
        }
        const existing = await getPartnerSubscription(partner_id);
        if (existing) {
          return res.status(409).json({
            error: "Subscription already exists",
            message: "Use upgrade endpoint to change subscription tier",
            current_subscription: existing
          });
        }
        const subscription = await createSubscription(partner_id, tier);
        res.status(201).json({
          message: "Subscription created successfully",
          subscription
        });
      } catch (error) {
        console.error("Failed to create subscription:", error);
        res.status(500).json({ error: "Failed to create subscription" });
      }
    });
    router8.put("/:id/upgrade", async (req, res) => {
      try {
        const { id } = req.params;
        const { new_tier } = req.body;
        if (!new_tier) {
          return res.status(400).json({
            error: "Missing required field: new_tier"
          });
        }
        const [rows] = await (await Promise.resolve().then(() => (init_db(), db_exports))).getDb().then(
          (db3) => db3.execute("SELECT tier, partner_id FROM partner_subscriptions WHERE id = ?", [id])
        );
        const subscriptions = rows;
        if (subscriptions.length === 0) {
          return res.status(404).json({ error: "Subscription not found" });
        }
        const currentTier = subscriptions[0].tier;
        const validation = validateTierTransition(currentTier, new_tier);
        if (!validation.valid) {
          return res.status(400).json({
            error: "Invalid tier transition",
            message: validation.reason,
            current_tier: currentTier,
            requested_tier: new_tier
          });
        }
        await upgradeSubscription2(id, new_tier);
        const partnerId = subscriptions[0].partner_id;
        const updated = await getPartnerSubscription(partnerId);
        res.json({
          message: "Subscription upgraded successfully",
          subscription: updated,
          benefits_applied: "immediately"
        });
      } catch (error) {
        console.error("Failed to upgrade subscription:", error);
        res.status(500).json({ error: "Failed to upgrade subscription" });
      }
    });
    router8.delete("/:id", async (req, res) => {
      try {
        const { id } = req.params;
        const [rows] = await (await Promise.resolve().then(() => (init_db(), db_exports))).getDb().then(
          (db3) => db3.execute("SELECT partner_id, tier FROM partner_subscriptions WHERE id = ?", [id])
        );
        const subscriptions = rows;
        if (subscriptions.length === 0) {
          return res.status(404).json({ error: "Subscription not found" });
        }
        const partnerId = subscriptions[0].partner_id;
        const previousTier = subscriptions[0].tier;
        await cancelSubscription(id);
        const newSubscription = await getPartnerSubscription(partnerId);
        res.json({
          message: "Subscription cancelled successfully",
          previous_tier: previousTier,
          new_subscription: newSubscription,
          downgrade_applied: "immediately"
        });
      } catch (error) {
        console.error("Failed to cancel subscription:", error);
        res.status(500).json({ error: "Failed to cancel subscription" });
      }
    });
    router8.post("/check-feature", async (req, res) => {
      try {
        const { partner_id, feature } = req.body;
        if (!partner_id || !feature) {
          return res.status(400).json({
            error: "Missing required fields",
            required: ["partner_id", "feature"]
          });
        }
        const hasAccess = await checkFeatureAccess2(partner_id, feature);
        const featureValue = await getFeatureValue(partner_id, feature);
        const subscription = await getPartnerSubscription(partner_id);
        res.json({
          has_access: hasAccess,
          feature,
          feature_value: featureValue,
          current_tier: subscription?.tier || "free"
        });
      } catch (error) {
        console.error("Failed to check feature access:", error);
        res.status(500).json({ error: "Failed to check feature access" });
      }
    });
    router8.post("/check-action", async (req, res) => {
      try {
        const { partner_id, action } = req.body;
        if (!partner_id || !action) {
          return res.status(400).json({
            error: "Missing required fields",
            required: ["partner_id", "action"]
          });
        }
        const result = await canPerformAction(partner_id, action);
        const subscription = await getPartnerSubscription(partner_id);
        res.json({
          allowed: result.allowed,
          action,
          reason: result.reason,
          current_tier: subscription?.tier || "free"
        });
      } catch (error) {
        console.error("Failed to check action permission:", error);
        res.status(500).json({ error: "Failed to check action permission" });
      }
    });
    partnerSubscriptionRouter_default = router8;
  }
});

// server/services/partnerBoostCampaignService.ts
import { eq as eq46, and as and39, sql as sql34, lte as lte10 } from "drizzle-orm";
import { nanoid as nanoid5 } from "nanoid";
var PartnerBoostCampaignService, partnerBoostCampaignService;
var init_partnerBoostCampaignService = __esm({
  "server/services/partnerBoostCampaignService.ts"() {
    "use strict";
    init_db();
    init_schema();
    PartnerBoostCampaignService = class {
      /**
       * Create a new boost campaign
       * Requirement 8.1: Require topic selection for targeting
       * Requirement 8.4: Track budget, spent, impressions, clicks
       */
      async createCampaign(data) {
        const topic = await db.query.topics.findFirst({
          where: eq46(topics.id, data.topicId)
        });
        if (!topic) {
          throw new Error("Topic not found. Topic selection is required for boost campaigns.");
        }
        const partner = await db.query.explorePartners.findFirst({
          where: eq46(explorePartners.id, data.partnerId)
        });
        if (!partner) {
          throw new Error("Partner not found");
        }
        const eligibility = await this.validateBoostEligibility(data.contentId);
        if (!eligibility.isValid) {
          throw new Error(`Content not eligible for boost: ${eligibility.reason}`);
        }
        const campaignId = nanoid5();
        await db.insert(boostCampaigns).values({
          id: campaignId,
          partnerId: data.partnerId,
          contentId: data.contentId,
          topicId: data.topicId,
          budget: data.budget.toString(),
          spent: "0",
          status: "draft",
          startDate: data.startDate.toISOString(),
          endDate: data.endDate?.toISOString() || null,
          impressions: 0,
          clicks: 0,
          costPerImpression: (data.costPerImpression || 0.1).toString()
        });
        const campaign = await db.query.boostCampaigns.findFirst({
          where: eq46(boostCampaigns.id, campaignId)
        });
        if (!campaign) {
          throw new Error("Failed to create campaign");
        }
        return campaign;
      }
      /**
       * Activate a boost campaign
       * Requirement 8.5: Auto-pause when budget depleted
       */
      async activateCampaign(campaignId) {
        const campaign = await db.query.boostCampaigns.findFirst({
          where: eq46(boostCampaigns.id, campaignId)
        });
        if (!campaign) {
          throw new Error("Campaign not found");
        }
        const spent = parseFloat(campaign.spent || "0");
        const budget = parseFloat(campaign.budget);
        if (spent >= budget) {
          throw new Error("Cannot activate campaign: budget depleted");
        }
        if (campaign.endDate) {
          const endDate = new Date(campaign.endDate);
          const now = /* @__PURE__ */ new Date();
          if (now > endDate) {
            throw new Error("Cannot activate campaign: campaign has expired");
          }
        }
        await db.update(boostCampaigns).set({ status: "active" }).where(eq46(boostCampaigns.id, campaignId));
      }
      /**
       * Pause a boost campaign
       */
      async pauseCampaign(campaignId) {
        await db.update(boostCampaigns).set({ status: "paused" }).where(eq46(boostCampaigns.id, campaignId));
      }
      /**
       * Record impression for a boosted content
       * Requirement 8.4: Track impressions
       * Requirement 8.5: Auto-pause when budget depleted
       */
      async recordImpression(campaignId) {
        const campaign = await db.query.boostCampaigns.findFirst({
          where: eq46(boostCampaigns.id, campaignId)
        });
        if (!campaign || campaign.status !== "active") {
          return;
        }
        const spent = parseFloat(campaign.spent || "0");
        const budget = parseFloat(campaign.budget);
        const costPerImpression = parseFloat(campaign.costPerImpression || "0.10");
        const newSpent = spent + costPerImpression;
        const newImpressions = (campaign.impressions || 0) + 1;
        const shouldDeplete = newSpent >= budget;
        await db.update(boostCampaigns).set({
          impressions: newImpressions,
          spent: newSpent.toString(),
          status: shouldDeplete ? "depleted" : "active"
        }).where(eq46(boostCampaigns.id, campaignId));
        if (shouldDeplete) {
          console.log(`[PartnerBoostCampaign] Campaign ${campaignId} budget depleted. Status set to 'depleted'.`);
        }
      }
      /**
       * Record click for a boosted content
       * Requirement 8.4: Track clicks
       */
      async recordClick(campaignId) {
        const campaign = await db.query.boostCampaigns.findFirst({
          where: eq46(boostCampaigns.id, campaignId)
        });
        if (!campaign || campaign.status !== "active") {
          return;
        }
        const newClicks = (campaign.clicks || 0) + 1;
        await db.update(boostCampaigns).set({
          clicks: newClicks
        }).where(eq46(boostCampaigns.id, campaignId));
      }
      /**
       * Get active campaigns for a specific topic
       * Used by feed generation to inject boosted content
       */
      async getActiveCampaignsForTopic(topicId) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const campaigns = await db.query.boostCampaigns.findMany({
          where: and39(
            eq46(boostCampaigns.topicId, topicId),
            eq46(boostCampaigns.status, "active"),
            lte10(boostCampaigns.startDate, now),
            sql34`(${boostCampaigns.endDate} IS NULL OR ${boostCampaigns.endDate} >= ${now})`
          )
        });
        return campaigns;
      }
      /**
       * Get campaign analytics
       * Requirement 8.4: Provide real-time performance analytics
       */
      async getCampaignAnalytics(campaignId) {
        const campaign = await db.query.boostCampaigns.findFirst({
          where: eq46(boostCampaigns.id, campaignId)
        });
        if (!campaign) {
          throw new Error("Campaign not found");
        }
        const spent = parseFloat(campaign.spent || "0");
        const budget = parseFloat(campaign.budget);
        const impressions = campaign.impressions || 0;
        const clicks = campaign.clicks || 0;
        const costPerImpression = parseFloat(campaign.costPerImpression || "0.10");
        const remainingBudget = budget - spent;
        const clickThroughRate = impressions > 0 ? clicks / impressions * 100 : 0;
        let daysRemaining = 0;
        if (campaign.endDate) {
          const now = /* @__PURE__ */ new Date();
          const endDate = new Date(campaign.endDate);
          daysRemaining = Math.max(0, Math.ceil((endDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24)));
        }
        return {
          campaignId: campaign.id,
          impressions,
          clicks,
          spent,
          budget,
          remainingBudget,
          costPerImpression,
          clickThroughRate,
          status: campaign.status || "draft",
          daysRemaining
        };
      }
      /**
       * Validate boost eligibility
       * Requirement 8.6: Reject boosts that violate content hierarchy
       */
      async validateBoostEligibility(contentId) {
        const content = await db.query.exploreContent.findFirst({
          where: eq46(exploreContent.id, parseInt(contentId))
        });
        const short = await db.query.exploreShorts.findFirst({
          where: eq46(exploreShorts.id, parseInt(contentId))
        });
        if (!content && !short) {
          return {
            isValid: false,
            reason: "Content not found"
          };
        }
        const contentCategory = content?.contentCategory || short?.contentCategory;
        if (contentCategory === "tertiary") {
          return {
            isValid: false,
            reason: "Tertiary content (inspiration/trends) cannot be boosted to maintain content hierarchy. Only primary (properties) and secondary (services/education) content can be boosted."
          };
        }
        const existingBoost = await this.isContentBoosted(contentId);
        if (existingBoost.isBoosted) {
          return {
            isValid: false,
            reason: "Content is already being boosted by an active campaign. Only one active boost per content item is allowed."
          };
        }
        const partnerId = content?.partnerId || short?.partnerId;
        if (!partnerId) {
          return {
            isValid: false,
            reason: "Content must be associated with a partner to be boosted"
          };
        }
        return {
          isValid: true
        };
      }
      /**
       * Check budget depletion for a campaign
       * Used to determine if campaign should be auto-paused
       */
      async checkBudgetDepletion(campaignId) {
        const campaign = await db.query.boostCampaigns.findFirst({
          where: eq46(boostCampaigns.id, campaignId)
        });
        if (!campaign) {
          return false;
        }
        const spent = parseFloat(campaign.spent || "0");
        const budget = parseFloat(campaign.budget);
        return spent >= budget;
      }
      /**
       * Get all campaigns for a partner
       */
      async getPartnerCampaigns(partnerId) {
        const campaigns = await db.query.boostCampaigns.findMany({
          where: eq46(boostCampaigns.partnerId, partnerId)
        });
        return campaigns;
      }
      /**
       * Update expired campaigns
       * Should be run periodically (e.g., via cron job)
       * Marks campaigns as 'completed' when end date is reached
       */
      async updateExpiredCampaigns() {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const result = await db.update(boostCampaigns).set({ status: "completed" }).where(and39(
          eq46(boostCampaigns.status, "active"),
          sql34`${boostCampaigns.endDate} IS NOT NULL AND ${boostCampaigns.endDate} < ${now}`
        ));
        return result[0]?.affectedRows || 0;
      }
      /**
       * Check and auto-pause depleted campaigns
       * Should be run periodically to ensure budget limits are enforced
       * Requirement 8.5: Auto-pause when budget depleted
       */
      async checkAndPauseDepletedCampaigns() {
        const campaigns = await db.query.boostCampaigns.findMany({
          where: eq46(boostCampaigns.status, "active")
        });
        let pausedCount = 0;
        for (const campaign of campaigns) {
          const spent = parseFloat(campaign.spent || "0");
          const budget = parseFloat(campaign.budget);
          if (spent >= budget) {
            await db.update(boostCampaigns).set({ status: "depleted" }).where(eq46(boostCampaigns.id, campaign.id));
            pausedCount++;
            console.log(`[PartnerBoostCampaign] Auto-paused campaign ${campaign.id} due to budget depletion`);
          }
        }
        return pausedCount;
      }
      /**
       * Get budget status for a campaign
       * Returns detailed budget information
       */
      async getBudgetStatus(campaignId) {
        const campaign = await db.query.boostCampaigns.findFirst({
          where: eq46(boostCampaigns.id, campaignId)
        });
        if (!campaign) {
          throw new Error("Campaign not found");
        }
        const budget = parseFloat(campaign.budget);
        const spent = parseFloat(campaign.spent || "0");
        const remaining = Math.max(0, budget - spent);
        const percentageUsed = budget > 0 ? spent / budget * 100 : 0;
        const isDepleted = spent >= budget;
        return {
          budget,
          spent,
          remaining,
          percentageUsed,
          isDepleted
        };
      }
      /**
       * Check if content is currently boosted
       * Requirement 8.2: Display "Sponsored" label on boosted content
       * Returns campaign info if content is actively boosted
       */
      async isContentBoosted(contentId) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const activeCampaign = await db.query.boostCampaigns.findFirst({
          where: and39(
            eq46(boostCampaigns.contentId, contentId),
            eq46(boostCampaigns.status, "active"),
            lte10(boostCampaigns.startDate, now),
            sql34`(${boostCampaigns.endDate} IS NULL OR ${boostCampaigns.endDate} >= ${now})`
          )
        });
        if (activeCampaign) {
          return {
            isBoosted: true,
            campaignId: activeCampaign.id,
            partnerId: activeCampaign.partnerId
          };
        }
        return {
          isBoosted: false
        };
      }
      /**
       * Get sponsored label data for content
       * Requirement 8.2: Add "Sponsored" label to boosted content
       * Returns label configuration if content is boosted
       */
      async getSponsoredLabel(contentId) {
        const boostStatus = await this.isContentBoosted(contentId);
        if (!boostStatus.isBoosted) {
          return null;
        }
        return {
          showLabel: true,
          labelText: "Sponsored",
          campaignId: boostStatus.campaignId
        };
      }
      /**
       * Batch check if multiple content items are boosted
       * Optimized for feed generation
       */
      async getBoostedContentIds(contentIds) {
        if (contentIds.length === 0) {
          return /* @__PURE__ */ new Set();
        }
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const activeCampaigns = await db.query.boostCampaigns.findMany({
          where: and39(
            sql34`${boostCampaigns.contentId} IN (${sql34.join(contentIds.map((id) => sql34`${id}`), sql34`, `)})`,
            eq46(boostCampaigns.status, "active"),
            lte10(boostCampaigns.startDate, now),
            sql34`(${boostCampaigns.endDate} IS NULL OR ${boostCampaigns.endDate} >= ${now})`
          )
        });
        return new Set(activeCampaigns.map((c) => c.contentId));
      }
    };
    partnerBoostCampaignService = new PartnerBoostCampaignService();
  }
});

// server/partnerBoostCampaignRouter.ts
var partnerBoostCampaignRouter_exports = {};
__export(partnerBoostCampaignRouter_exports, {
  default: () => partnerBoostCampaignRouter_default
});
import { Router as Router6 } from "express";
var router9, partnerBoostCampaignRouter_default;
var init_partnerBoostCampaignRouter = __esm({
  "server/partnerBoostCampaignRouter.ts"() {
    "use strict";
    init_partnerBoostCampaignService();
    router9 = Router6();
    router9.post("/", async (req, res) => {
      try {
        const { partnerId, contentId, topicId, budget, startDate, endDate, costPerImpression } = req.body;
        if (!partnerId || !contentId || !topicId || !budget || !startDate) {
          return res.status(400).json({
            error: "Missing required fields: partnerId, contentId, topicId, budget, startDate"
          });
        }
        if (!topicId) {
          return res.status(400).json({
            error: "Topic selection is required for boost campaigns"
          });
        }
        const campaign = await partnerBoostCampaignService.createCampaign({
          partnerId,
          contentId,
          topicId,
          budget: parseFloat(budget),
          startDate: new Date(startDate),
          endDate: endDate ? new Date(endDate) : void 0,
          costPerImpression: costPerImpression ? parseFloat(costPerImpression) : void 0
        });
        res.status(201).json({
          success: true,
          campaign
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Create campaign error:", error);
        res.status(400).json({
          error: error.message || "Failed to create boost campaign"
        });
      }
    });
    router9.put("/:id/activate", async (req, res) => {
      try {
        const { id } = req.params;
        await partnerBoostCampaignService.activateCampaign(id);
        res.json({
          success: true,
          message: "Campaign activated successfully"
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Activate campaign error:", error);
        res.status(400).json({
          error: error.message || "Failed to activate campaign"
        });
      }
    });
    router9.put("/:id/pause", async (req, res) => {
      try {
        const { id } = req.params;
        await partnerBoostCampaignService.pauseCampaign(id);
        res.json({
          success: true,
          message: "Campaign paused successfully"
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Pause campaign error:", error);
        res.status(400).json({
          error: error.message || "Failed to pause campaign"
        });
      }
    });
    router9.get("/:id/analytics", async (req, res) => {
      try {
        const { id } = req.params;
        const analytics = await partnerBoostCampaignService.getCampaignAnalytics(id);
        res.json({
          success: true,
          analytics
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Get analytics error:", error);
        res.status(404).json({
          error: error.message || "Campaign not found"
        });
      }
    });
    router9.get("/:id/budget", async (req, res) => {
      try {
        const { id } = req.params;
        const budgetStatus = await partnerBoostCampaignService.getBudgetStatus(id);
        res.json({
          success: true,
          budget: budgetStatus
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Get budget status error:", error);
        res.status(404).json({
          error: error.message || "Campaign not found"
        });
      }
    });
    router9.get("/partner/:partnerId", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const campaigns = await partnerBoostCampaignService.getPartnerCampaigns(partnerId);
        res.json({
          success: true,
          campaigns
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Get partner campaigns error:", error);
        res.status(500).json({
          error: error.message || "Failed to fetch campaigns"
        });
      }
    });
    router9.get("/topic/:topicId/active", async (req, res) => {
      try {
        const { topicId } = req.params;
        const campaigns = await partnerBoostCampaignService.getActiveCampaignsForTopic(topicId);
        res.json({
          success: true,
          campaigns
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Get active campaigns error:", error);
        res.status(500).json({
          error: error.message || "Failed to fetch active campaigns"
        });
      }
    });
    router9.get("/content/:contentId/boosted", async (req, res) => {
      try {
        const { contentId } = req.params;
        const boostStatus = await partnerBoostCampaignService.isContentBoosted(contentId);
        res.json({
          success: true,
          ...boostStatus
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Check boosted status error:", error);
        res.status(500).json({
          error: error.message || "Failed to check boost status"
        });
      }
    });
    router9.get("/content/:contentId/sponsored-label", async (req, res) => {
      try {
        const { contentId } = req.params;
        const label = await partnerBoostCampaignService.getSponsoredLabel(contentId);
        res.json({
          success: true,
          label
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Get sponsored label error:", error);
        res.status(500).json({
          error: error.message || "Failed to get sponsored label"
        });
      }
    });
    router9.post("/validate-eligibility", async (req, res) => {
      try {
        const { contentId } = req.body;
        if (!contentId) {
          return res.status(400).json({
            error: "contentId is required"
          });
        }
        const validation = await partnerBoostCampaignService.validateBoostEligibility(contentId);
        res.json({
          success: true,
          ...validation
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Validate eligibility error:", error);
        res.status(500).json({
          error: error.message || "Failed to validate eligibility"
        });
      }
    });
    router9.post("/:id/impression", async (req, res) => {
      try {
        const { id } = req.params;
        await partnerBoostCampaignService.recordImpression(id);
        res.json({
          success: true,
          message: "Impression recorded"
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Record impression error:", error);
        res.status(500).json({
          error: error.message || "Failed to record impression"
        });
      }
    });
    router9.post("/:id/click", async (req, res) => {
      try {
        const { id } = req.params;
        await partnerBoostCampaignService.recordClick(id);
        res.json({
          success: true,
          message: "Click recorded"
        });
      } catch (error) {
        console.error("[PartnerBoostCampaignRouter] Record click error:", error);
        res.status(500).json({
          error: error.message || "Failed to record click"
        });
      }
    });
    partnerBoostCampaignRouter_default = router9;
  }
});

// server/services/leadGenerationService.ts
var leadGenerationService;
var init_leadGenerationService = __esm({
  "server/services/leadGenerationService.ts"() {
    "use strict";
    leadGenerationService = {
      /**
       * Create a new lead
       */
      async createLead(data) {
        console.log("[leadGenerationService] createLead called with:", data);
        throw new Error("Lead generation service not yet implemented");
      },
      /**
       * Get leads for a partner with optional filters
       */
      async getPartnerLeads(partnerId, filters) {
        console.log("[leadGenerationService] getPartnerLeads called:", partnerId, filters);
        return [];
      },
      /**
       * Get a specific lead by ID
       */
      async getLeadById(leadId) {
        console.log("[leadGenerationService] getLeadById called:", leadId);
        return null;
      },
      /**
       * Update lead status
       */
      async updateLeadStatus(leadId, status) {
        console.log("[leadGenerationService] updateLeadStatus called:", leadId, status);
      },
      /**
       * Calculate lead price based on type and partner tier
       */
      async calculateLeadPrice(leadType, partnerId) {
        console.log("[leadGenerationService] calculateLeadPrice called:", leadType, partnerId);
        const basePrices = {
          "quote_request": 25,
          "consultation": 50,
          "eligibility_check": 15,
          "general_inquiry": 10
        };
        return basePrices[leadType] || 10;
      },
      /**
       * Notify partner about a new lead
       */
      async notifyPartner(partnerId, lead) {
        console.log("[leadGenerationService] notifyPartner called:", partnerId, lead);
      },
      /**
       * Dispute a lead (for invalid/fake leads)
       */
      async disputeLead(leadId, reason) {
        console.log("[leadGenerationService] disputeLead called:", leadId, reason);
      },
      /**
       * Process a dispute decision
       */
      async processDispute(leadId, decision) {
        console.log("[leadGenerationService] processDispute called:", leadId, decision);
      },
      /**
       * Get lead conversion funnel analytics
       */
      async getLeadConversionFunnel(partnerId) {
        console.log("[leadGenerationService] getLeadConversionFunnel called:", partnerId);
        return {
          new: 0,
          contacted: 0,
          qualified: 0,
          converted: 0,
          lost: 0,
          conversionRate: 0
        };
      }
    };
  }
});

// server/partnerLeadRouter.ts
var partnerLeadRouter_exports = {};
__export(partnerLeadRouter_exports, {
  default: () => partnerLeadRouter_default
});
import { Router as Router7 } from "express";
var router10, partnerLeadRouter_default;
var init_partnerLeadRouter = __esm({
  "server/partnerLeadRouter.ts"() {
    "use strict";
    init_leadGenerationService();
    router10 = Router7();
    router10.post("/", async (req, res) => {
      try {
        const leadData = req.body;
        if (!leadData.partnerId || !leadData.userId || !leadData.type || !leadData.contactInfo) {
          return res.status(400).json({
            error: "Missing required fields: partnerId, userId, type, contactInfo"
          });
        }
        const validTypes = ["quote_request", "consultation", "eligibility_check"];
        if (!validTypes.includes(leadData.type)) {
          return res.status(400).json({
            error: `Invalid lead type. Must be one of: ${validTypes.join(", ")}`
          });
        }
        if (!leadData.contactInfo.name || !leadData.contactInfo.email || !leadData.contactInfo.phone) {
          return res.status(400).json({
            error: "Contact info must include name, email, and phone"
          });
        }
        const lead = await leadGenerationService.createLead(leadData);
        res.status(201).json({
          success: true,
          lead,
          message: "Lead created successfully. Partner has been notified."
        });
      } catch (error) {
        console.error("Error creating lead:", error);
        res.status(500).json({
          error: "Failed to create lead",
          details: error.message
        });
      }
    });
    router10.get("/partner/:partnerId", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const filters = {
          status: req.query.status,
          type: req.query.type,
          limit: req.query.limit ? parseInt(req.query.limit) : void 0,
          offset: req.query.offset ? parseInt(req.query.offset) : void 0
        };
        const leads3 = await leadGenerationService.getPartnerLeads(partnerId, filters);
        res.json({
          success: true,
          leads: leads3,
          count: leads3.length
        });
      } catch (error) {
        console.error("Error fetching partner leads:", error);
        res.status(500).json({
          error: "Failed to fetch leads",
          details: error.message
        });
      }
    });
    router10.get("/:leadId", async (req, res) => {
      try {
        const { leadId } = req.params;
        const lead = await leadGenerationService.getLeadById(leadId);
        if (!lead) {
          return res.status(404).json({
            error: "Lead not found"
          });
        }
        res.json({
          success: true,
          lead
        });
      } catch (error) {
        console.error("Error fetching lead:", error);
        res.status(500).json({
          error: "Failed to fetch lead",
          details: error.message
        });
      }
    });
    router10.put("/:leadId/status", async (req, res) => {
      try {
        const { leadId } = req.params;
        const { status } = req.body;
        const validStatuses = ["new", "contacted", "converted", "disputed", "refunded"];
        if (!validStatuses.includes(status)) {
          return res.status(400).json({
            error: `Invalid status. Must be one of: ${validStatuses.join(", ")}`
          });
        }
        await leadGenerationService.updateLeadStatus(leadId, status);
        res.json({
          success: true,
          message: "Lead status updated successfully"
        });
      } catch (error) {
        console.error("Error updating lead status:", error);
        res.status(500).json({
          error: "Failed to update lead status",
          details: error.message
        });
      }
    });
    router10.post("/:leadId/dispute", async (req, res) => {
      try {
        const { leadId } = req.params;
        const { reason } = req.body;
        if (!reason || reason.trim().length === 0) {
          return res.status(400).json({
            error: "Dispute reason is required"
          });
        }
        await leadGenerationService.disputeLead(leadId, reason);
        res.json({
          success: true,
          message: "Lead dispute submitted. Admin team will review within 48 hours."
        });
      } catch (error) {
        console.error("Error disputing lead:", error);
        res.status(500).json({
          error: "Failed to dispute lead",
          details: error.message
        });
      }
    });
    router10.post("/:leadId/dispute/process", async (req, res) => {
      try {
        const { leadId } = req.params;
        const { decision } = req.body;
        if (!decision || !["refund", "reject"].includes(decision)) {
          return res.status(400).json({
            error: "Decision must be either 'refund' or 'reject'"
          });
        }
        await leadGenerationService.processDispute(leadId, decision);
        res.json({
          success: true,
          message: `Dispute ${decision === "refund" ? "approved and refunded" : "rejected"}`
        });
      } catch (error) {
        console.error("Error processing dispute:", error);
        res.status(500).json({
          error: "Failed to process dispute",
          details: error.message
        });
      }
    });
    router10.get("/partner/:partnerId/funnel", async (req, res) => {
      try {
        const { partnerId } = req.params;
        const funnel = await leadGenerationService.getLeadConversionFunnel(partnerId);
        res.json({
          success: true,
          funnel
        });
      } catch (error) {
        console.error("Error fetching conversion funnel:", error);
        res.status(500).json({
          error: "Failed to fetch conversion funnel",
          details: error.message
        });
      }
    });
    router10.get("/pricing/:type", async (req, res) => {
      try {
        const { type } = req.params;
        const { partnerId } = req.query;
        const validTypes = ["quote_request", "consultation", "eligibility_check"];
        if (!validTypes.includes(type)) {
          return res.status(400).json({
            error: `Invalid lead type. Must be one of: ${validTypes.join(", ")}`
          });
        }
        if (!partnerId) {
          return res.status(400).json({
            error: "partnerId query parameter is required"
          });
        }
        const price = await leadGenerationService.calculateLeadPrice(
          type,
          partnerId
        );
        res.json({
          success: true,
          type,
          price,
          currency: "ZAR"
        });
      } catch (error) {
        console.error("Error calculating lead price:", error);
        res.status(500).json({
          error: "Failed to calculate lead price",
          details: error.message
        });
      }
    });
    partnerLeadRouter_default = router10;
  }
});

// server/_core/index.ts
import "dotenv/config";
import { sql as sql35 } from "drizzle-orm";
import express4 from "express";
import cors from "cors";
import rateLimit from "express-rate-limit";
import { createServer } from "http";
import superjson2 from "superjson";
import { createExpressMiddleware } from "@trpc/server/adapters/express";

// server/_core/authRoutes.ts
init_const();

// server/_core/cookies.ts
var LOCAL_HOSTS = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "::1"]);
function isIpAddress(host) {
  if (/^\d{1,3}(\.\d{1,3}){3}$/.test(host)) return true;
  return host.includes(":");
}
function isSecureRequest(req) {
  if (req.protocol === "https") return true;
  const forwardedProto = req.headers["x-forwarded-proto"];
  if (!forwardedProto) return false;
  const protoList = Array.isArray(forwardedProto) ? forwardedProto : forwardedProto.split(",");
  return protoList.some((proto) => proto.trim().toLowerCase() === "https");
}
function getSessionCookieOptions(req) {
  const hostname = req.hostname;
  const shouldSetDomain = hostname && !LOCAL_HOSTS.has(hostname) && !isIpAddress(hostname) && hostname !== "127.0.0.1" && hostname !== "::1";
  const domain = shouldSetDomain && !hostname.startsWith(".") ? `.${hostname}` : shouldSetDomain ? hostname : void 0;
  const isProduction = process.env.NODE_ENV === "production";
  const isSecure = isSecureRequest(req);
  const isCrossDomain = req.headers.origin?.includes(".vercel.app") || req.headers.origin?.includes(".railway.app") || req.headers.origin?.startsWith("https://") && !req.headers.origin?.includes(hostname);
  return {
    domain,
    httpOnly: true,
    path: "/",
    // For cross-domain (Vercel frontend + Railway backend), use 'none'
    // For same-domain or local dev, use 'lax'
    sameSite: isProduction && isSecure || isCrossDomain ? "none" : "lax",
    // Secure cookies required for sameSite: 'none'
    secure: isProduction && isSecure || isCrossDomain
  };
}

// server/_core/authRoutes.ts
init_auth();
init_env();
function registerAuthRoutes(app) {
  app.post("/api/auth/register", async (req, res) => {
    try {
      const { email, password, name, role, agentProfile } = req.body;
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password are required" });
      }
      if (typeof email !== "string" || typeof password !== "string") {
        return res.status(400).json({ error: "Invalid input types" });
      }
      const passwordStrengthRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]).{8,}$/;
      if (!passwordStrengthRegex.test(password)) {
        return res.status(400).json({
          error: "Password must be at least 8 characters and contain at least one uppercase letter, one lowercase letter, one number, and one special character."
        });
      }
      if (role === "agent") {
        if (!agentProfile || !agentProfile.displayName || !agentProfile.phoneNumber) {
          return res.status(400).json({
            error: "Agent profile with display name and phone number is required for agent registration"
          });
        }
      }
      const allowedRoles = ["agent", "agency_admin", "property_developer", "visitor"];
      const requestedRole = allowedRoles.includes(role) ? role : "visitor";
      const userId = await authService.register(email, password, name, requestedRole, agentProfile);
      const message = role === "agent" ? "Registration successful! Please check your email to verify your account. Your agent profile will be created after email verification." : "Registration successful. Please check your email to verify your account.";
      res.status(201).json({
        success: true,
        message
      });
    } catch (error) {
      console.error("[Auth] Registration failed", error);
      if (error.message?.includes("already exists")) {
        return res.status(409).json({ error: error.message });
      }
      res.status(500).json({ error: "Registration failed" });
    }
  });
  app.post("/api/auth/login", async (req, res) => {
    try {
      console.log("\u{1F510} Login attempt:", req.body);
      const { email, password, rememberMe } = req.body;
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password are required" });
      }
      if (typeof email !== "string" || typeof password !== "string") {
        return res.status(400).json({ error: "Invalid input types" });
      }
      console.log("\u{1F50D} Validating credentials for:", email);
      const { user, sessionToken } = await authService.login(email, password, rememberMe);
      console.log("\u2705 Auth service returned user:", user.email);
      const maxAge = rememberMe ? 30 * 24 * 60 * 60 * 1e3 : 24 * 60 * 60 * 1e3;
      console.log("\u{1F36A} Setting cookie with name:", COOKIE_NAME);
      const cookieOptions = getSessionCookieOptions(req);
      res.cookie(COOKIE_NAME, sessionToken, {
        ...cookieOptions,
        maxAge
      });
      console.log("\u2705 Cookie set successfully");
      res.json({
        success: true,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      });
    } catch (error) {
      console.error("\u274C Login failed:", error);
      console.error("Error stack:", error.stack);
      const errorMessage = error.message || "Unknown error";
      if (errorMessage.includes("Invalid email or password") || errorMessage.includes("verify your email")) {
        return res.status(401).json({ error: errorMessage });
      }
      if (errorMessage.includes("OAuth login")) {
        return res.status(403).json({ error: errorMessage });
      }
      if (errorMessage.includes("pending review") || errorMessage.includes("rejected") || errorMessage.includes("suspended")) {
        return res.status(403).json({ error: errorMessage });
      }
      if (errorMessage.includes("JWT_SECRET")) {
        return res.status(500).json({ error: "Server configuration error. Please contact support." });
      }
      if (errorMessage.includes("connect") || errorMessage.includes("ECONNREFUSED")) {
        return res.status(503).json({ error: "Database service unavailable. Please try again later." });
      }
      res.status(500).json({
        error: "Login failed",
        message: errorMessage,
        stack: process.env.NODE_ENV === "development" ? error.stack : void 0
      });
    }
  });
  app.post("/api/auth/logout", (req, res) => {
    const cookieOptions = getSessionCookieOptions(req);
    res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
    res.json({ success: true, message: "Logged out successfully." });
  });
  app.post("/api/auth/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email || typeof email !== "string") {
        return res.status(400).json({ error: "A valid email is required" });
      }
      await authService.forgotPassword(email);
      res.json({
        success: true,
        message: "If an account with that email exists, a password reset link has been sent."
      });
    } catch (error) {
      console.error("[Auth] Forgot password failed", error);
      res.json({
        success: true,
        message: "If an account with that email exists, a password reset link has been sent."
      });
    }
  });
  app.post("/api/auth/reset-password", async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      if (!token || !newPassword || typeof token !== "string" || typeof newPassword !== "string") {
        return res.status(400).json({ error: "A token and a new password are required" });
      }
      const passwordStrengthRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]).{8,}$/;
      if (!passwordStrengthRegex.test(newPassword)) {
        return res.status(400).json({
          error: "Password must be at least 8 characters and contain at least one uppercase letter, one lowercase letter, one number, and one special character."
        });
      }
      await authService.resetPassword(token, newPassword);
      res.json({ success: true, message: "Your password has been reset successfully." });
    } catch (error) {
      console.error("[Auth] Reset password failed", error);
      res.status(400).json({ error: error.message || "The password reset token is invalid or has expired." });
    }
  });
  app.get("/api/auth/verify-email", async (req, res) => {
    try {
      const { token } = req.query;
      if (!token || typeof token !== "string") {
        return res.status(400).send(
          "<h1>Email Verification Failed</h1><p>The verification link is missing a token.</p>"
        );
      }
      await authService.verifyEmail(token);
      res.redirect(`${ENV.appUrl}/login?verified=true`);
    } catch (error) {
      console.error("[Auth] Email verification failed", error);
      res.status(400).send(
        `<h1>Email Verification Failed</h1><p>${error.message || "The verification link is invalid or has expired."}</p>`
      );
    }
  });
}

// server/routers.ts
import { z as z32 } from "zod";
init_const();

// shared/db-enums.ts
var OWNERSHIP_TYPES = [
  "full-title",
  "sectional-title",
  "leasehold",
  "life-rights"
];
var STRUCTURAL_TYPES = [
  "apartment",
  "freestanding-house",
  "simplex",
  "duplex",
  "penthouse",
  "plot-and-plan",
  "townhouse",
  "studio"
];
var FLOOR_TYPES = ["single-storey", "double-storey", "triplex"];

// server/_core/systemRouter.ts
import { z } from "zod";

// server/_core/notification.ts
init_env();
import { TRPCError } from "@trpc/server";
var TITLE_MAX_LENGTH = 1200;
var CONTENT_MAX_LENGTH = 2e4;
var trimValue = (value) => value.trim();
var isNonEmptyString2 = (value) => typeof value === "string" && value.trim().length > 0;
var buildEndpointUrl = (baseUrl) => {
  const normalizedBase = baseUrl.endsWith("/") ? baseUrl : `${baseUrl}/`;
  return new URL("webdevtoken.v1.WebDevService/SendNotification", normalizedBase).toString();
};
var validatePayload = (input) => {
  if (!isNonEmptyString2(input.title)) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Notification title is required."
    });
  }
  if (!isNonEmptyString2(input.content)) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Notification content is required."
    });
  }
  const title = trimValue(input.title);
  const content = trimValue(input.content);
  if (title.length > TITLE_MAX_LENGTH) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: `Notification title must be at most ${TITLE_MAX_LENGTH} characters.`
    });
  }
  if (content.length > CONTENT_MAX_LENGTH) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: `Notification content must be at most ${CONTENT_MAX_LENGTH} characters.`
    });
  }
  return { title, content };
};
async function notifyOwner(payload) {
  const { title, content } = validatePayload(payload);
  if (!ENV.forgeApiUrl) {
    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "Notification service URL is not configured."
    });
  }
  if (!ENV.forgeApiKey) {
    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "Notification service API key is not configured."
    });
  }
  const endpoint = buildEndpointUrl(ENV.forgeApiUrl);
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        accept: "application/json",
        authorization: `Bearer ${ENV.forgeApiKey}`,
        "content-type": "application/json",
        "connect-protocol-version": "1"
      },
      body: JSON.stringify({ title, content })
    });
    if (!response.ok) {
      const detail = await response.text().catch(() => "");
      console.warn(
        `[Notification] Failed to notify owner (${response.status} ${response.statusText})${detail ? `: ${detail}` : ""}`
      );
      return false;
    }
    return true;
  } catch (error) {
    console.warn("[Notification] Error calling notification service:", error);
    return false;
  }
}

// server/_core/trpc.ts
init_const();
import { initTRPC, TRPCError as TRPCError2 } from "@trpc/server";
import { ZodError } from "zod";
import superjson from "superjson";
var t = initTRPC.context().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    const cause = error.cause;
    const isZod = cause && typeof cause === "object" && ("issues" in cause || cause instanceof ZodError);
    const zodError = isZod ? cause.flatten?.() ?? { formErrors: [], fieldErrors: {} } : void 0;
    return {
      ...shape,
      data: {
        ...shape.data,
        // Safe optional payload for client-side display/debugging
        zodError,
        _zod: zodError,
        // Backwards compatibility for some client versions
        cause: cause ? String(cause?.message ?? cause) : void 0
        // safe string
      }
    };
  }
});
var router = t.router;
var publicProcedure = t.procedure;
var requireUser = t.middleware(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    throw new TRPCError2({ code: "UNAUTHORIZED", message: UNAUTHED_ERR_MSG });
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user
    }
  });
});
var protectedProcedure = t.procedure.use(requireUser);
var requireSuperAdmin = t.middleware(async ({ ctx, next }) => {
  if (!ctx.user) {
    throw new TRPCError2({ code: "UNAUTHORIZED", message: "Not authenticated" });
  }
  if (ctx.user.role !== "super_admin") {
    throw new TRPCError2({
      code: "FORBIDDEN",
      message: "Super admin privileges required. This action is restricted to platform administrators."
    });
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user
    }
  });
});
var requireAgencyAdmin = t.middleware(async ({ ctx, next }) => {
  if (!ctx.user) {
    throw new TRPCError2({ code: "UNAUTHORIZED", message: "Not authenticated" });
  }
  if (ctx.user.role !== "agency_admin" && ctx.user.role !== "super_admin") {
    throw new TRPCError2({
      code: "FORBIDDEN",
      message: "Agency admin privileges required"
    });
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user
    }
  });
});
var requireAgent = t.middleware(async ({ ctx, next }) => {
  if (!ctx.user) {
    throw new TRPCError2({ code: "UNAUTHORIZED", message: "Not authenticated" });
  }
  const allowedRoles = ["agent", "agency_admin", "super_admin"];
  if (!allowedRoles.includes(ctx.user.role)) {
    throw new TRPCError2({
      code: "FORBIDDEN",
      message: "Agent privileges required"
    });
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user
    }
  });
});
var superAdminProcedure = t.procedure.use(requireSuperAdmin);
var agencyAdminProcedure = t.procedure.use(requireAgencyAdmin);
var agentProcedure = t.procedure.use(requireAgent);
var adminProcedure = t.procedure.use(
  t.middleware(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user || ctx.user.role !== "super_admin" && ctx.user.role !== "agency_admin") {
      throw new TRPCError2({ code: "FORBIDDEN", message: NOT_ADMIN_ERR_MSG });
    }
    return next({
      ctx: {
        ...ctx,
        user: ctx.user
      }
    });
  })
);

// server/_core/systemRouter.ts
init_db();
var systemRouter = router({
  health: publicProcedure.input(
    z.object({
      timestamp: z.number().min(0, "timestamp cannot be negative").optional()
    }).optional()
  ).query(async () => {
    const db3 = await getDb();
    let dbStatus = "disconnected";
    let dbError = null;
    try {
      if (db3) {
        await db3.execute("SELECT 1");
        dbStatus = "connected";
      }
    } catch (error) {
      dbError = error instanceof Error ? error.message : "Unknown database error";
      console.error("[Health Check] Database error:", dbError);
    }
    return {
      ok: dbStatus === "connected",
      status: dbStatus === "connected" ? "healthy" : "unhealthy",
      database: dbStatus,
      error: dbError,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      environment: process.env.NODE_ENV || "development"
    };
  }),
  notifyOwner: adminProcedure.input(
    z.object({
      title: z.string().min(1, "title is required"),
      content: z.string().min(1, "content is required")
    })
  ).mutation(async ({ input }) => {
    const delivered = await notifyOwner(input);
    return {
      success: delivered
    };
  })
});

// server/routers.ts
init_db();

// server/adminRouter.ts
import { z as z2 } from "zod";
init_db();
init_schema();
import { eq as eq5, desc as desc3, asc, and as and5, or as or3, like as like2, sql as sql7 } from "drizzle-orm";

// server/_core/auditLog.ts
init_db();
init_schema();
async function logAudit(params) {
  const db3 = await getDb();
  if (!db3) {
    console.warn("[AuditLog] Database not available");
    return;
  }
  const logEntry = {
    userId: params.userId,
    action: params.action,
    targetType: params.targetType || null,
    targetId: params.targetId || null,
    metadata: params.metadata ? JSON.stringify(params.metadata) : null,
    ipAddress: params.req ? getClientIP(params.req) : null,
    userAgent: params.req?.headers["user-agent"] || null
  };
  try {
    await db3.insert(auditLogs).values(logEntry);
    console.log(`[AuditLog] ${params.action} by user ${params.userId}`);
  } catch (error) {
    console.error("[AuditLog] Failed to log action:", error);
  }
}
function getClientIP(req) {
  const forwarded = req.headers["x-forwarded-for"];
  if (forwarded) {
    return Array.isArray(forwarded) ? forwarded[0] : forwarded.split(",")[0].trim();
  }
  const realIP = req.headers["x-real-ip"];
  if (realIP) {
    return Array.isArray(realIP) ? realIP[0] : realIP;
  }
  return req.socket?.remoteAddress || null;
}
var AuditActions = {
  // Super admin actions
  IMPERSONATE_USER: "impersonate_user",
  VIEW_ALL_USERS: "view_all_users",
  VIEW_ALL_AGENCIES: "view_all_agencies",
  VIEW_ALL_PROPERTIES: "view_all_properties",
  UPDATE_USER_ROLE: "update_user_role",
  DELETE_USER: "delete_user",
  DELETE_AGENCY: "delete_agency",
  APPROVE_PROPERTY: "approve_property",
  REJECT_PROPERTY: "reject_property",
  // Agency admin actions
  INVITE_AGENT: "invite_agent",
  APPROVE_JOIN_REQUEST: "approve_join_request",
  REJECT_JOIN_REQUEST: "reject_join_request",
  REMOVE_SUBACCOUNT: "remove_subaccount",
  // Sensitive actions
  UPDATE_SUBSCRIPTION: "update_subscription",
  EXPORT_DATA: "export_data",
  UPDATE_DEVELOPMENT: "update_development"
};

// server/utils/dbTypeUtils.ts
function nowAsDbTimestamp() {
  return (/* @__PURE__ */ new Date()).toISOString();
}

// server/services/developmentService.ts
init_db_connection();
init_schema();
import { eq as eq4, desc as desc2, and as and4, sql as sql6, inArray as inArray2 } from "drizzle-orm";
import { TRPCError as TRPCError3 } from "@trpc/server";
import crypto2 from "crypto";

// server/services/publishNormalizer.ts
function emptyToNull(value) {
  if (value === void 0 || value === null || value === "") return null;
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed === "" ? null : trimmed;
  }
  return String(value).trim() || null;
}
function coerceInt(value) {
  if (value === void 0 || value === null || value === "") return null;
  const num = typeof value === "number" ? value : parseInt(String(value), 10);
  return isNaN(num) ? null : num;
}
function coerceDecimal(value) {
  if (value === void 0 || value === null || value === "") return null;
  const num = typeof value === "number" ? value : parseFloat(String(value));
  return isNaN(num) ? null : num;
}
function boolToInt(value) {
  if (value === true || value === "true" || value === 1 || value === "1") return 1;
  return 0;
}
function mapEnum(value, allowedValues, defaultValue = null) {
  if (value === void 0 || value === null || value === "") return defaultValue;
  const normalized = String(value).toLowerCase().trim();
  const match = allowedValues.find((v) => v.toLowerCase() === normalized);
  return match || defaultValue;
}
function normalizeArray(value) {
  if (!value) return null;
  if (Array.isArray(value)) return value.filter(Boolean);
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    if (trimmed.startsWith("[")) {
      try {
        const parsed = JSON.parse(trimmed);
        return Array.isArray(parsed) ? parsed.filter(Boolean) : null;
      } catch {
        return null;
      }
    }
    if (trimmed.includes(",")) {
      return trimmed.split(",").map((s) => s.trim()).filter(Boolean);
    }
    return [trimmed];
  }
  return null;
}
function normalizeMedia(value) {
  if (!value) return null;
  if (Array.isArray(value) && value.length === 0) return null;
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed === "" || trimmed === "[]" ? null : trimmed;
  }
  try {
    const json2 = JSON.stringify(value);
    return json2 === "[]" || json2 === "{}" ? null : json2;
  } catch {
    return null;
  }
}
function mapStatusEnum(value) {
  const normalized = String(value || "").toLowerCase().trim();
  const mapping = {
    "now-selling": "selling",
    "launching-soon": "launching-soon",
    "sold-out": "sold-out",
    selling: "selling",
    coming_soon: "launching-soon",
    pre_launch: "launching-soon"
  };
  return mapping[normalized] || "launching-soon";
}
function normalizeOwnershipType(value) {
  if (!value) return null;
  if (Array.isArray(value)) {
    value = value[0];
  }
  return mapEnum(value, ["full-title", "sectional-title", "leasehold", "life-rights"]);
}
function normalizeForPublish(wizardData, ownerType = "developer") {
  if (!wizardData.name?.trim()) {
    throw new Error("Development name is required");
  }
  if (!wizardData.city?.trim()) {
    throw new Error("City is required");
  }
  if (!wizardData.province?.trim()) {
    throw new Error("Province is required");
  }
  const devType = mapEnum(wizardData.developmentType, [
    "residential",
    "commercial",
    "mixed_use",
    "land"
  ]);
  if (!devType) {
    throw new Error(
      `Invalid developmentType: ${wizardData.developmentType}. Must be one of: residential, commercial, mixed_use, land`
    );
  }
  return {
    // Required fields
    name: wizardData.name.trim(),
    city: wizardData.city.trim(),
    province: wizardData.province.trim(),
    developmentType: devType,
    status: mapStatusEnum(wizardData.status),
    devOwnerType: ownerType,
    // Defaults for NOT NULL columns
    showHouseAddress: boolToInt(wizardData.showHouseAddress ?? true),
    isFeatured: boolToInt(wizardData.isFeatured ?? false),
    isPublished: boolToInt(wizardData.isPublished ?? false),
    readinessScore: 0,
    approvalStatus: "draft",
    // Optional text fields
    tagline: emptyToNull(wizardData.tagline),
    subtitle: emptyToNull(wizardData.subtitle),
    marketingName: emptyToNull(wizardData.marketingName),
    description: emptyToNull(wizardData.description),
    suburb: emptyToNull(wizardData.suburb),
    address: emptyToNull(wizardData.address),
    postalCode: emptyToNull(wizardData.postalCode),
    latitude: emptyToNull(wizardData.latitude),
    longitude: emptyToNull(wizardData.longitude),
    customClassification: emptyToNull(wizardData.customClassification),
    // Optional enums
    constructionPhase: mapEnum(wizardData.constructionPhase, [
      "planning",
      "under_construction",
      "completed",
      "phase_completed"
    ]),
    nature: mapEnum(wizardData.nature, ["new", "phase", "extension", "redevelopment"], "new"),
    ownershipType: normalizeOwnershipType(wizardData.ownershipType),
    structuralType: mapEnum(wizardData.structuralType, [
      "apartment",
      "freestanding-house",
      "simplex",
      "duplex",
      "penthouse",
      "plot-and-plan",
      "townhouse",
      "studio"
    ]),
    floors: mapEnum(wizardData.floors, ["single-storey", "double-storey", "triplex"]),
    marketingRole: mapEnum(wizardData.marketingRole, ["exclusive", "joint", "open"]),
    // Numeric fields
    priceFrom: coerceInt(wizardData.priceFrom),
    priceTo: coerceInt(wizardData.priceTo),
    monthlyLevyFrom: coerceDecimal(wizardData.monthlyLevyFrom),
    monthlyLevyTo: coerceDecimal(wizardData.monthlyLevyTo),
    ratesFrom: coerceDecimal(wizardData.ratesFrom),
    ratesTo: coerceDecimal(wizardData.ratesTo),
    transferCostsIncluded: wizardData.transferCostsIncluded ? boolToInt(wizardData.transferCostsIncluded) : null,
    totalUnits: coerceInt(wizardData.totalUnits),
    availableUnits: coerceInt(wizardData.availableUnits),
    totalDevelopmentArea: coerceInt(wizardData.totalDevelopmentArea),
    // Array fields
    propertyTypes: normalizeArray(wizardData.propertyTypes),
    amenities: normalizeArray(wizardData.amenities),
    highlights: normalizeArray(wizardData.highlights),
    features: normalizeArray(wizardData.features),
    // Media fields (preserve structure)
    images: normalizeMedia(wizardData.images),
    videos: normalizeMedia(wizardData.videos),
    floorPlans: normalizeMedia(wizardData.floorPlans),
    brochures: normalizeMedia(wizardData.brochures),
    // JSON fields
    estateSpecs: wizardData.estateSpecs || null,
    // Date fields
    completionDate: wizardData.completionDate ? String(wizardData.completionDate) : null,
    // Foreign keys
    developerBrandProfileId: wizardData.developerBrandProfileId || null,
    marketingBrandProfileId: wizardData.marketingBrandProfileId || null,
    locationId: wizardData.locationId || null
  };
}
function validateNormalizedPayload(payload) {
  if (payload.priceFrom && payload.priceTo && payload.priceFrom > payload.priceTo) {
    throw new Error("priceFrom cannot be greater than priceTo");
  }
  if (payload.monthlyLevyFrom && payload.monthlyLevyTo && payload.monthlyLevyFrom > payload.monthlyLevyTo) {
    throw new Error("monthlyLevyFrom cannot be greater than monthlyLevyTo");
  }
}

// server/services/developmentService.ts
init_schema();
function generateSlug(text2) {
  return text2.toString().toLowerCase().trim().replace(/\s+/g, "-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}
async function generateUniqueSlug(baseName) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database connection unavailable for slug generation");
  let slug = generateSlug(baseName);
  let counter = 1;
  let isUnique = false;
  while (!isUnique) {
    const existing = await db3.select({ id: developments.id }).from(developments).where(eq4(developments.slug, slug)).limit(1);
    if (existing.length === 0) {
      isUnique = true;
    } else {
      slug = `${generateSlug(baseName)}-${counter}`;
      counter++;
    }
  }
  return slug;
}
function boolToInt2(value) {
  if (value === true || value === "true" || value === 1 || value === "1") return 1;
  return 0;
}
function parseSlugOrId(input) {
  const trimmed = input.trim();
  const isNumeric = /^\d+$/.test(trimmed);
  if (isNumeric) {
    const parsed = parseInt(trimmed, 10);
    if (!isNaN(parsed) && parsed > 0) {
      return { isId: true, value: parsed };
    }
  }
  return { isId: false, value: trimmed };
}
function normalizeAmenities(amenities3) {
  if (Array.isArray(amenities3)) return amenities3;
  if (typeof amenities3 === "string") {
    try {
      const parsed = JSON.parse(amenities3);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return amenities3 ? [amenities3] : [];
    }
  }
  return [];
}
function normalizeImages(images) {
  if (Array.isArray(images)) return images;
  if (typeof images === "string") {
    if (images.includes(",") && !images.trim().startsWith("[")) {
      return images.split(",").map((img) => img.trim()).filter(Boolean);
    }
    try {
      const parsed = JSON.parse(images);
      if (Array.isArray(parsed)) return parsed;
    } catch {
      return images ? [images] : [];
    }
    return images ? [images] : [];
  }
  return [];
}
function parseJsonField(field) {
  if (Array.isArray(field)) return field;
  if (!field) return [];
  if (typeof field === "string") {
    try {
      const trimmed = field.trim();
      if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
        return JSON.parse(trimmed);
      }
      if (trimmed.includes(",")) {
        return trimmed.split(",").map((s) => s.trim());
      }
      return [trimmed];
    } catch (e) {
      console.warn("[developmentService] Failed to parse JSON field:", field);
      return [];
    }
  }
  return [];
}
function sanitizeEnum(value, allowedValues, defaultValue = null) {
  if (value === void 0 || value === null || value === "") return defaultValue;
  if (allowedValues.includes(value)) return value;
  return defaultValue;
}
function sanitizeInt(value) {
  if (value === void 0 || value === null || value === "") return null;
  const num = parseInt(value, 10);
  return isNaN(num) ? null : num;
}
function validateDevelopmentData(data, developerId) {
  if (!developerId) {
    throw createError("Invalid developerId", "VALIDATION_ERROR", { developerId });
  }
  if (data.devOwnerType && !["platform", "developer"].includes(data.devOwnerType)) {
    throw createError(
      `Invalid devOwnerType: ${data.devOwnerType}. Must be 'platform' or 'developer'`,
      "VALIDATION_ERROR",
      { devOwnerType: data.devOwnerType }
    );
  }
}
function createError(message, code, details) {
  const error = new Error(message);
  error.code = code;
  error.details = details;
  return error;
}
function handleDatabaseError(error, context) {
  console.error("[developmentService] \u26D4 FULL DATABASE ERROR:", {
    message: error.message,
    code: error.code,
    errno: error.errno,
    sqlMessage: error.sqlMessage,
    sqlState: error.sqlState,
    sql: error.sql,
    values: error.values,
    params: error.params,
    allKeys: Object.keys(error),
    context
  });
  console.error("[developmentService] \u26D4 RAW ERROR STACK:", error.stack);
  if (error.cause) {
    console.error("[developmentService] \u26D4 CAUSE ERROR:", {
      causeMessage: error.cause?.message,
      causeCode: error.cause?.code,
      causeSqlMessage: error.cause?.sqlMessage,
      causeSql: error.cause?.sql
    });
  }
  switch (error.code) {
    case "ER_NO_REFERENCED_ROW_2":
      throw createError(
        "Foreign key constraint violation. Invalid developerId or developerBrandProfileId.",
        "FK_CONSTRAINT_ERROR",
        {
          developerId: context.developerId,
          developerBrandProfileId: context.developerBrandProfileId
        }
      );
    case "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD":
      throw createError(
        `Invalid enum value for devOwnerType: ${context.devOwnerType}. Must be 'platform' or 'developer'.`,
        "ENUM_ERROR",
        { devOwnerType: context.devOwnerType }
      );
    case "ER_DUP_ENTRY":
      throw createError(
        "Duplicate entry detected. Development slug or unique field already exists.",
        "DUPLICATE_ENTRY",
        context
      );
    case "ER_DATA_TOO_LONG":
      throw createError("Data too long for one or more fields.", "DATA_TOO_LONG", context);
    default:
      throw createError(
        `Database operation failed: ${error.message}`,
        error.code || "DB_ERROR",
        context
      );
  }
}
async function getPublicDevelopmentBySlug(slugOrId) {
  console.log("[DEBUG] Service: getPublicDevelopmentBySlug called with:", slugOrId);
  try {
    const db3 = await getDb();
    if (!db3) {
      console.error("[CRITICAL] Service: Database connection is NULL");
      return null;
    }
    const { isId, value } = parseSlugOrId(slugOrId);
    if (!isId && (!value || value === "undefined" || value === "null")) return null;
    const whereClause = isId ? and4(eq4(developments.id, value), eq4(developments.isPublished, 1)) : and4(eq4(developments.slug, value), eq4(developments.isPublished, 1));
    const results = await db3.select({
      id: developments.id,
      name: developments.name,
      slug: developments.slug,
      description: developments.description,
      images: developments.images,
      videos: developments.videos,
      locationId: developments.locationId,
      city: developments.city,
      province: developments.province,
      suburb: developments.suburb,
      address: developments.address,
      latitude: developments.latitude,
      longitude: developments.longitude,
      priceFrom: developments.priceFrom,
      priceTo: developments.priceTo,
      amenities: developments.amenities,
      highlights: developments.highlights,
      features: developments.features,
      estateSpecs: developments.estateSpecs,
      monthlyLevyFrom: developments.monthlyLevyFrom,
      monthlyLevyTo: developments.monthlyLevyTo,
      ratesFrom: developments.ratesFrom,
      ratesTo: developments.ratesTo,
      transferCostsIncluded: developments.transferCostsIncluded,
      status: developments.status,
      developmentType: developments.developmentType,
      completionDate: developments.completionDate,
      totalUnits: developments.totalUnits,
      availableUnits: developments.availableUnits,
      floorPlans: developments.floorPlans,
      brochures: developments.brochures,
      showHouseAddress: developments.showHouseAddress,
      isPublished: developments.isPublished,
      marketingRole: developments.marketingRole,
      developer: {
        id: developers.id,
        name: developers.name,
        slug: developers.slug,
        logo: developers.logo,
        description: developers.description,
        website: developers.website,
        email: developers.email,
        phone: developers.phone,
        status: developers.status
      }
    }).from(developments).leftJoin(developers, eq4(developments.developerId, developers.id)).where(whereClause).limit(1);
    if (results.length === 0) return null;
    const dev = results[0];
    const [units, phases] = await Promise.all([
      db3.select().from(unitTypes).where(and4(eq4(unitTypes.developmentId, dev.id), eq4(unitTypes.isActive, 1))).orderBy(unitTypes.basePriceFrom),
      db3.select({
        id: developmentPhases.id,
        developmentId: developmentPhases.developmentId,
        name: developmentPhases.name,
        phaseNumber: developmentPhases.phaseNumber,
        description: developmentPhases.description,
        status: developmentPhases.status,
        totalUnits: developmentPhases.totalUnits,
        availableUnits: developmentPhases.availableUnits,
        priceFrom: developmentPhases.priceFrom,
        priceTo: developmentPhases.priceTo,
        launchDate: developmentPhases.launchDate,
        completionDate: developmentPhases.completionDate
      }).from(developmentPhases).where(eq4(developmentPhases.developmentId, dev.id)).orderBy(developmentPhases.phaseNumber)
    ]);
    return {
      ...dev,
      amenities: normalizeAmenities(dev.amenities),
      // JSON column, Drizzle handles or we normalize
      // Helper to parse TEXT columns that contain JSON strings
      images: parseJsonField(dev.images),
      videos: parseJsonField(dev.videos),
      floorPlans: parseJsonField(dev.floorPlans),
      brochures: parseJsonField(dev.brochures),
      unitTypes: units,
      phases
    };
  } catch (err) {
    console.error("[CRITICAL] Error in getPublicDevelopmentBySlug:", err);
    return null;
  }
}
async function getPublicDevelopment(id) {
  const db3 = await getDb();
  if (!db3) return null;
  const results = await db3.select({
    id: developments.id,
    name: developments.name,
    slug: developments.slug,
    description: developments.description,
    images: developments.images,
    address: developments.address,
    city: developments.city,
    province: developments.province,
    priceFrom: developments.priceFrom,
    priceTo: developments.priceTo,
    monthlyLevyFrom: developments.monthlyLevyFrom,
    monthlyLevyTo: developments.monthlyLevyTo,
    ratesFrom: developments.ratesFrom,
    ratesTo: developments.ratesTo,
    transferCostsIncluded: developments.transferCostsIncluded,
    status: developments.status,
    developerId: developments.developerId
  }).from(developments).where(and4(eq4(developments.id, id), eq4(developments.isPublished, 1))).limit(1);
  if (!results[0]) return null;
  return {
    ...results[0],
    images: parseJsonField(results[0].images)
  };
}
async function listPublicDevelopments(limit = 20) {
  const db3 = await getDb();
  if (!db3) return [];
  const results = await db3.select({
    id: developments.id,
    developerId: developments.developerId,
    name: developments.name,
    slug: developments.slug,
    description: developments.description,
    images: developments.images,
    city: developments.city,
    province: developments.province,
    priceFrom: developments.priceFrom,
    priceTo: developments.priceTo,
    status: developments.status,
    isFeatured: developments.isFeatured,
    developer: {
      id: developers.id,
      name: developers.name,
      logo: developers.logo
    }
  }).from(developments).leftJoin(developers, eq4(developments.developerId, developers.id)).where(eq4(developments.isPublished, 1)).orderBy(desc2(developments.isFeatured), desc2(developments.createdAt)).limit(limit);
  return results.map((dev) => ({
    ...dev,
    images: parseJsonField(dev.images)
  }));
}
async function createDevelopment(developerId, data, metadata = {}) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  console.log("[createDevelopment] Input data:", {
    name: data.name,
    slug: data.slug
  });
  const { unitTypes: unitTypesData, ...developmentData } = data;
  console.log("[createDevelopment] UnitTypes extracted:", {
    hasUnits: !!unitTypesData,
    isArray: Array.isArray(unitTypesData),
    length: unitTypesData?.length
  });
  const { ownerType, brandProfileId, ...restMetadata } = metadata;
  validateDevelopmentData(
    { ...developmentData, devOwnerType: ownerType || "developer" },
    developerId
  );
  const validDeveloper = await db3.query.developers.findFirst({
    where: eq4(developers.id, developerId),
    columns: { id: true, status: true }
    // Minimal select
  });
  if (!validDeveloper) {
    throw createError(`Developer with ID ${developerId} not found`, "NOT_FOUND", { developerId });
  }
  const targetBrandId = brandProfileId ?? developmentData.developerBrandProfileId;
  if (targetBrandId) {
    const validBrand = await db3.query.developerBrandProfiles.findFirst({
      where: eq4(developerBrandProfiles.id, targetBrandId),
      columns: { id: true }
    });
    if (!validBrand) {
      throw createError(`Brand Profile with ID ${targetBrandId} not found`, "NOT_FOUND", {
        brandProfileId: targetBrandId
      });
    }
  }
  if (developmentData.marketingBrandProfileId) {
    const validMarketing = await db3.query.developerBrandProfiles.findFirst({
      where: eq4(developerBrandProfiles.id, developmentData.marketingBrandProfileId),
      columns: { id: true }
    });
    if (!validMarketing) {
      throw createError(
        `Marketing Brand Profile with ID ${developmentData.marketingBrandProfileId} not found`,
        "NOT_FOUND",
        { marketingBrandProfileId: developmentData.marketingBrandProfileId }
      );
    }
  }
  if (developmentData.locationId) {
    const validLocation = await db3.query.locations.findFirst({
      where: eq4(locations.id, developmentData.locationId),
      columns: { id: true }
    });
    if (!validLocation) {
      console.warn(
        `[createDevelopment] Invalid Location ID ${developmentData.locationId} provided. Removing to prevent crash.`
      );
      developmentData.locationId = void 0;
    }
  }
  const allowedDevTypes = /* @__PURE__ */ new Set(["residential", "commercial", "mixed_use", "land"]);
  if (!allowedDevTypes.has(developmentData.developmentType)) {
    throw createError(
      `Invalid developmentType: ${developmentData.developmentType}`,
      "VALIDATION_ERROR",
      {
        developmentType: developmentData.developmentType
      }
    );
  }
  let baseSlug = developmentData.slug;
  if (!baseSlug || baseSlug.trim() === "") {
    if (!developmentData.name) {
      throw createError(
        "Either slug or name must be provided to generate a slug",
        "VALIDATION_ERROR"
      );
    }
    baseSlug = developmentData.name;
  }
  const slug = await generateUniqueSlug(baseSlug, db3);
  console.log("[createDevelopment] Final unique slug:", slug);
  const insertPayload = {
    // 1. Required/Core
    developerId,
    name: developmentData.name,
    slug,
    city: developmentData.city,
    province: developmentData.province,
    developmentType: developmentData.developmentType || "residential",
    status: "launching-soon",
    devOwnerType: ownerType || "developer",
    // Defaults for NOT NULL / Important columns
    isFeatured: 0,
    isPublished: 0,
    views: 0,
    showHouseAddress: boolToInt2(developmentData.showHouseAddress ?? true),
    readinessScore: 0,
    approvalStatus: "draft",
    nature: developmentData.nature || "new",
    // Text/JSON columns that need processing
    images: JSON.stringify(normalizeImages(developmentData.images)),
    amenities: normalizeAmenities(developmentData.amenities),
    highlights: normalizeAmenities(developmentData.highlights),
    features: normalizeAmenities(developmentData.features),
    propertyTypes: developmentData.propertyTypes ? JSON.stringify(developmentData.propertyTypes) : null,
    // 2. Optional Foreign Keys
    developerBrandProfileId: brandProfileId ?? developmentData.developerBrandProfileId ?? null,
    marketingBrandProfileId: developmentData.marketingBrandProfileId || null,
    locationId: developmentData.locationId || null,
    // 3. Optional fields
    marketingRole: developmentData.marketingRole || null,
    tagline: developmentData.tagline?.trim() || null,
    description: developmentData.description?.trim() || null,
    address: developmentData.address?.trim() || null,
    suburb: developmentData.suburb?.trim() || null,
    postalCode: developmentData.postalCode?.trim() || null,
    latitude: developmentData.latitude || null,
    longitude: developmentData.longitude || null,
    priceFrom: developmentData.priceFrom || null,
    priceTo: developmentData.priceTo || null,
    totalUnits: developmentData.totalUnits || null,
    availableUnits: developmentData.availableUnits || null,
    totalDevelopmentArea: developmentData.totalDevelopmentArea || null,
    customClassification: developmentData.customClassification || null,
    // Spec/Config fields
    estateSpecs: developmentData.estateSpecs || null,
    completionDate: developmentData.completionDate || null,
    // Enums - only set if valid
    ownershipType: developmentData.ownershipType || null,
    structuralType: developmentData.structuralType || null,
    floors: developmentData.floors || null,
    // Financial
    monthlyLevyFrom: developmentData.monthlyLevyFrom || null,
    monthlyLevyTo: developmentData.monthlyLevyTo || null,
    ratesFrom: developmentData.ratesFrom || null,
    ratesTo: developmentData.ratesTo || null,
    transferCostsIncluded: developmentData.transferCostsIncluded || null
  };
  if (Array.isArray(developmentData.videos) && developmentData.videos.length > 0) {
    insertPayload.videos = JSON.stringify(developmentData.videos);
  }
  if (Array.isArray(developmentData.floorPlans) && developmentData.floorPlans.length > 0) {
    insertPayload.floorPlans = JSON.stringify(developmentData.floorPlans);
  }
  if (Array.isArray(developmentData.brochures) && developmentData.brochures.length > 0) {
    insertPayload.brochures = JSON.stringify(developmentData.brochures);
  }
  Object.keys(restMetadata).forEach((key) => {
    if (!(key in insertPayload)) {
      insertPayload[key] = restMetadata[key];
    }
  });
  console.log("[createDevelopment] Consolidated payload keys:", Object.keys(insertPayload));
  let resultId;
  let unitTypesCount;
  try {
    const createdDev = await db3.transaction(async (tx) => {
      try {
        const [{ dbName, dbHost }] = await tx.execute(
          sql6`SELECT DATABASE() as dbName, @@hostname as dbHost`
        );
        console.log(`[createDevelopment] !!! SAFE INSERT ACTIVE !!! (DB: ${dbName} @ ${dbHost})`);
      } catch (e) {
        console.warn("DB Fingerprint failed", e);
      }
      let insertResult;
      try {
        [insertResult] = await tx.insert(developments).values(insertPayload);
      } catch (insertErr) {
        console.error("=".repeat(50));
        console.error("[createDevelopment] \u26D4 RAW DB INSERT ERROR:");
        console.error("  message:", insertErr?.message);
        console.error("  code:", insertErr?.code);
        console.error("  errno:", insertErr?.errno);
        console.error("  sqlMessage:", insertErr?.sqlMessage);
        console.error("  sqlState:", insertErr?.sqlState);
        console.error("  sql (first 300 chars):", insertErr?.sql?.substring?.(0, 300));
        console.error("=".repeat(50));
        throw insertErr;
      }
      console.log("[createDevelopment] Raw insert result:", JSON.stringify(insertResult, null, 2));
      const newId = insertResult.insertId;
      let persistedCount = 0;
      if (unitTypesData && Array.isArray(unitTypesData) && unitTypesData.length > 0) {
        await persistUnitTypes(tx, newId, unitTypesData);
        const [{ count: count9 }] = await tx.select({ count: sql6`count(*)` }).from(unitTypes).where(eq4(unitTypes.developmentId, newId));
        console.log(
          `[createDevelopment] Verification read: ${count9} units persisted (expected >= 1)`
        );
        if (Number(count9) === 0) {
          throw new TRPCError3({
            code: "INTERNAL_SERVER_ERROR",
            message: "Unit types were provided but none were persisted. Aborting create."
          });
        }
        persistedCount = Number(count9);
      }
      return { newId, persistedCount };
    });
    resultId = createdDev.newId;
    unitTypesCount = createdDev.persistedCount;
  } catch (error) {
    console.error("[createDevelopment] \u26D4 RAW INSERT ERROR:", {
      message: error?.message,
      code: error?.code,
      errno: error?.errno,
      sqlMessage: error?.sqlMessage,
      sqlState: error?.sqlState,
      sql: error?.sql?.substring?.(0, 500)
    });
    if (error?.cause) {
      console.error("[createDevelopment] \u26D4 CAUSE:", {
        message: error.cause?.message,
        code: error.cause?.code,
        errno: error.cause?.errno,
        sqlMessage: error.cause?.sqlMessage
      });
    }
    handleDatabaseError(error, {
      developerId,
      devOwnerType: ownerType || "developer",
      developerBrandProfileId: brandProfileId ?? null
    });
  }
  const [created] = await db3.select().from(developments).where(eq4(developments.id, resultId)).limit(1);
  if (!created) {
    throw new Error(`Development created but not found on retrieval. ID: ${resultId}`);
  }
  if (typeof unitTypesCount === "number") {
    created.unitTypesCount = unitTypesCount;
  }
  return created;
}
async function updateDevelopment(id, developerId, data) {
  console.log("[updateDevelopment] Starting update for development:", id);
  console.log("[updateDevelopment] Payload keys:", Object.keys(data));
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const {
    unitTypes: unitTypesData,
    media: mediaData,
    amenities: amenitiesData,
    estateSpecs: estateSpecsData,
    specifications: specificationsData,
    phases: phasesData,
    ...developmentData
  } = data;
  const updatePayload = {};
  if (developmentData.name !== void 0) updatePayload.name = developmentData.name;
  if (developmentData.description !== void 0)
    updatePayload.description = developmentData.description;
  if (developmentData.tagline !== void 0) updatePayload.tagline = developmentData.tagline;
  if (developmentData.subtitle !== void 0) updatePayload.subtitle = developmentData.subtitle;
  if (developmentData.developmentType !== void 0)
    updatePayload.developmentType = developmentData.developmentType;
  if (developmentData.propertyCategory !== void 0)
    updatePayload.propertyCategory = developmentData.propertyCategory;
  if (developmentData.subCategory !== void 0)
    updatePayload.subCategory = developmentData.subCategory;
  if (developmentData.address !== void 0) updatePayload.address = developmentData.address;
  if (developmentData.suburb !== void 0) updatePayload.suburb = developmentData.suburb;
  if (developmentData.city !== void 0) updatePayload.city = developmentData.city;
  if (developmentData.province !== void 0) updatePayload.province = developmentData.province;
  if (developmentData.postalCode !== void 0)
    updatePayload.postalCode = developmentData.postalCode;
  if (developmentData.latitude !== void 0) updatePayload.latitude = developmentData.latitude;
  if (developmentData.longitude !== void 0) updatePayload.longitude = developmentData.longitude;
  if (developmentData.status !== void 0) updatePayload.status = developmentData.status;
  if (developmentData.completionDate !== void 0)
    updatePayload.completionDate = developmentData.completionDate;
  if (developmentData.launchDate !== void 0)
    updatePayload.launchDate = developmentData.launchDate;
  const numericFields = [
    "priceFrom",
    "priceTo",
    "monthlyLevyFrom",
    "monthlyLevyTo",
    "ratesFrom",
    "ratesTo",
    "totalUnits",
    "availableUnits",
    "totalDevelopmentArea",
    "erfSizeFrom",
    "erfSizeTo",
    "floorSizeFrom",
    "floorSizeTo",
    "bedroomsFrom",
    "bedroomsTo",
    "bathroomsFrom",
    "bathroomsTo"
  ];
  numericFields.forEach((field) => {
    if (developmentData[field] !== void 0) {
      updatePayload[field] = developmentData[field];
    }
  });
  const booleanFields = [
    "petsAllowed",
    "fibreReady",
    "solarReady",
    "waterBackup",
    "backupPower",
    "gatedCommunity",
    "featured",
    "isPhasedDevelopment"
  ];
  booleanFields.forEach((field) => {
    if (developmentData[field] !== void 0) {
      updatePayload[field] = developmentData[field];
    }
  });
  if (mediaData !== void 0) {
    updatePayload.media = typeof mediaData === "string" ? mediaData : JSON.stringify(mediaData || { photos: [], videos: [], brochures: [] });
  }
  if (amenitiesData !== void 0) {
    updatePayload.amenities = typeof amenitiesData === "string" ? amenitiesData : JSON.stringify(amenitiesData || { standard: [], additional: [] });
  }
  if (developmentData.ownershipType !== void 0)
    updatePayload.ownershipType = developmentData.ownershipType;
  if (developmentData.floors !== void 0) updatePayload.floors = developmentData.floors;
  if (developmentData.structuralType !== void 0)
    updatePayload.structuralType = developmentData.structuralType;
  const extraSpecs = {};
  if (developmentData.transferCostsIncluded !== void 0)
    extraSpecs.transferCostsIncluded = developmentData.transferCostsIncluded;
  if (estateSpecsData !== void 0 || Object.keys(extraSpecs).length > 0) {
    let currentSpecs = estateSpecsData;
    if (typeof currentSpecs === "string") {
      try {
        currentSpecs = JSON.parse(currentSpecs);
      } catch {
        currentSpecs = {};
      }
    }
    const finalSpecs = { ...currentSpecs || {}, ...extraSpecs };
    updatePayload.estateSpecs = JSON.stringify(finalSpecs);
  }
  if (specificationsData !== void 0) {
    updatePayload.specifications = typeof specificationsData === "string" ? specificationsData : JSON.stringify(specificationsData || {});
  }
  if (developmentData.residentialConfig !== void 0) {
    updatePayload.residentialConfig = typeof developmentData.residentialConfig === "string" ? developmentData.residentialConfig : JSON.stringify(developmentData.residentialConfig || {});
  }
  if (developmentData.landConfig !== void 0) {
    updatePayload.landConfig = typeof developmentData.landConfig === "string" ? developmentData.landConfig : JSON.stringify(developmentData.landConfig || {});
  }
  if (developmentData.commercialConfig !== void 0) {
    updatePayload.commercialConfig = typeof developmentData.commercialConfig === "string" ? developmentData.commercialConfig : JSON.stringify(developmentData.commercialConfig || {});
  }
  if (developmentData.mixedUseConfig !== void 0) {
    updatePayload.mixedUseConfig = typeof developmentData.mixedUseConfig === "string" ? developmentData.mixedUseConfig : JSON.stringify(developmentData.mixedUseConfig || {});
  }
  if (developmentData.metaTitle !== void 0) {
    updatePayload.metaTitle = developmentData.metaTitle;
  }
  if (developmentData.metaDescription !== void 0) {
    updatePayload.metaDescription = developmentData.metaDescription;
  }
  if (developmentData.keywords !== void 0) {
    updatePayload.keywords = typeof developmentData.keywords === "string" ? developmentData.keywords : JSON.stringify(developmentData.keywords || []);
  }
  if (developmentData.brandProfileId !== void 0)
    updatePayload.developerBrandProfileId = developmentData.brandProfileId;
  if (developmentData.agentId !== void 0) updatePayload.agentId = developmentData.agentId;
  updatePayload.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
  console.log("[updateDevelopment] Update payload fields:", Object.keys(updatePayload));
  await db3.update(developments).set(updatePayload).where(eq4(developments.id, id));
  if (unitTypesData !== void 0) {
    if (Array.isArray(unitTypesData)) {
      if (unitTypesData.length === 0) {
        console.warn("[updateDevelopment] Empty unitTypes - will DELETE all units");
      }
      await persistUnitTypes(db3, id, unitTypesData);
    } else {
      console.warn("[updateDevelopment] unitTypes is not an array:", typeof unitTypesData);
    }
  } else {
    console.log("[updateDevelopment] No unitTypes in payload - preserving existing");
  }
  if (phasesData !== void 0 && Array.isArray(phasesData)) {
    await persistDevelopmentPhases(db3, id, phasesData);
  }
  console.log("[updateDevelopment] Update completed successfully");
  return { success: true };
}
var asInt = (val, fallback = 0) => {
  if (val === void 0 || val === null || val === "") return fallback;
  const num = parseInt(String(val), 10);
  return isNaN(num) ? fallback : num;
};
var asStringOrNull = (v) => {
  if (typeof v !== "string") return null;
  const s = v.trim();
  return s.length ? s : null;
};
var asDecimalOrNull = (v) => {
  if (v === null || v === void 0 || v === "") return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
};
var asDateOnlyOrNull = (v) => {
  if (typeof v !== "string") return null;
  const s = v.trim();
  if (!s) return null;
  if (s.length >= 10) return s.slice(0, 10);
  return null;
};
var normalizeParkingKind = (v) => {
  const s = String(v).trim().toLowerCase();
  if (["none", "open", "covered", "carport", "garage", "1", "2"].includes(s)) {
    return s;
  }
  return "none";
};
var mapParkingToDbEnum = (kind, bays) => {
  if (kind === "garage") return "garage";
  if (kind === "carport") return "carport";
  if (kind === "none") return "none";
  if (kind === "open" || kind === "covered") {
    return bays >= 2 ? "2" : "1";
  }
  if (kind === "1" || kind === "2") return kind;
  return "none";
};
async function persistUnitTypes(db3, developmentId, unitTypesData) {
  console.log(
    `[persistUnitTypes] Processing ${unitTypesData.length} units for development ${developmentId}`
  );
  if (!unitTypesData || unitTypesData.length === 0) {
    console.log("[persistUnitTypes] Empty payload - preserving existing units");
    return;
  }
  const existingUnits = await db3.select({ id: unitTypes.id }).from(unitTypes).where(eq4(unitTypes.developmentId, developmentId));
  const existingIds = new Set(existingUnits.map((u) => String(u.id).trim()));
  const normalizedIncoming = unitTypesData.map((u) => ({
    ...u,
    // If it looks like a temp ID (number) or empty, treat as null for 'new' check
    normalizedId: u.id ? String(u.id).trim() : null
  }));
  const incomingIds = new Set(
    normalizedIncoming.filter((u) => u.normalizedId && existingIds.has(u.normalizedId)).map((u) => u.normalizedId)
  );
  const idsToDelete = Array.from(existingIds).filter((id) => !incomingIds.has(id));
  if (idsToDelete.length > 0) {
    console.log(`[persistUnitTypes] Deleting ${idsToDelete.length} units:`, idsToDelete);
    await db3.delete(unitTypes).where(and4(eq4(unitTypes.developmentId, developmentId), inArray2(unitTypes.id, idsToDelete)));
  }
  for (const unit of normalizedIncoming) {
    const isNewUnit = !unit.normalizedId || !existingIds.has(unit.normalizedId);
    const unitId = isNewUnit ? crypto2.randomUUID() : unit.normalizedId;
    if (unitId.length > 36) {
      throw new Error(
        `Unit ID violation: '${unitId}' length (${unitId.length}) > 36. Aborting save.`
      );
    }
    const kind = normalizeParkingKind(unit.parkingType || unit.parking);
    const rawBays = asInt(unit.parkingBays ?? unit.parkingSpaces ?? 0, 0);
    const parkingEnum = mapParkingToDbEnum(kind, rawBays);
    const parkingBays = parkingEnum === "none" ? 0 : rawBays;
    let parkingType = asStringOrNull(unit.parkingType);
    if (!parkingType && (kind === "open" || kind === "covered")) {
      parkingType = kind;
    }
    if (parkingEnum === "garage") {
      if (parkingType !== "tandem" && parkingType !== "side-by-side") parkingType = null;
    } else if (parkingEnum !== "garage" && parkingEnum !== "carport") {
      if (kind === "open" || kind === "covered") {
        parkingType = kind;
      } else {
        parkingType = null;
      }
    }
    const basePriceFrom = (() => {
      const v = asDecimalOrNull(unit.basePriceFrom);
      if (v !== null) return v;
      const fallback = asDecimalOrNull(unit.priceFrom);
      if (fallback !== null) return fallback;
      console.warn(`UnitType ${unitId}: basePriceFrom missing, defaulting to 0`);
      return 0;
    })();
    const unitPayload = {
      developmentId,
      label: unit.label || unit.name || "Unnamed Unit",
      name: unit.name || unit.label || "Unnamed Unit",
      // Sanitized Enums
      ownershipType: sanitizeEnum(
        unit.ownershipType,
        ["full-title", "sectional-title", "leasehold", "life-rights"],
        null
      ),
      structuralType: sanitizeEnum(
        unit.structuralType,
        [
          "apartment",
          "freestanding-house",
          "simplex",
          "duplex",
          "penthouse",
          "plot-and-plan",
          "townhouse",
          "studio"
        ],
        "apartment"
      ),
      floors: sanitizeEnum(unit.floors, ["single-storey", "double-storey", "triplex"], null),
      // Parking - explicit assignment
      parking: parkingEnum,
      parkingType,
      parkingBays,
      // Numeric Fields
      bedrooms: sanitizeInt(unit.bedrooms) ?? 0,
      bathrooms: asDecimalOrNull(unit.bathrooms) ?? 1,
      // Nullable size fields
      sizeFrom: sanitizeInt(unit.sizeFrom ?? unit.floorSizeFrom),
      sizeTo: sanitizeInt(unit.sizeTo ?? unit.floorSizeTo),
      yardSize: sanitizeInt(unit.yardSize),
      unitSize: sanitizeInt(unit.unitSize),
      // Pricing
      priceFrom: asDecimalOrNull(unit.priceFrom),
      priceTo: asDecimalOrNull(unit.priceTo),
      basePriceFrom,
      basePriceTo: asDecimalOrNull(unit.basePriceTo),
      depositRequired: asDecimalOrNull(unit.depositRequired),
      // Stock fields
      availableUnits: sanitizeInt(unit.availableUnits) ?? 0,
      totalUnits: sanitizeInt(unit.totalUnits) ?? 0,
      // Date
      completionDate: asDateOnlyOrNull(unit.completionDate),
      // Text fields
      internalNotes: asStringOrNull(unit.internalNotes),
      configDescription: asStringOrNull(unit.configDescription),
      virtualTourLink: asStringOrNull(unit.virtualTourLink),
      description: asStringOrNull(unit.description),
      // Boolean -> tinyint
      transferCostsIncluded: unit.transferCostsIncluded ? 1 : 0,
      // JSON fields
      extras: JSON.stringify(unit.extras || []),
      specifications: JSON.stringify(unit.specifications || {}),
      specOverrides: JSON.stringify(unit.specOverrides || {}),
      baseFeatures: JSON.stringify(unit.baseFeatures || {}),
      baseFinishes: JSON.stringify(unit.baseFinishes || {}),
      amenities: JSON.stringify(unit.amenities || { standard: [], additional: [] }),
      baseMedia: JSON.stringify(unit.baseMedia || { gallery: [], floorPlans: [], renders: [] }),
      features: JSON.stringify(unit.features || {}),
      // Timestamps
      updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
      // Force Active
      isActive: 1
    };
    if (isNewUnit) {
      await db3.insert(unitTypes).values({
        ...unitPayload,
        id: unitId,
        createdAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
      });
    } else {
      await db3.update(unitTypes).set(unitPayload).where(and4(eq4(unitTypes.developmentId, developmentId), eq4(unitTypes.id, unitId)));
    }
  }
  try {
    const finalCount = await db3.select({ count: sql6`count(*)` }).from(unitTypes).where(eq4(unitTypes.developmentId, developmentId));
    console.log(`[persistUnitTypes] DONE. DB count: ${finalCount[0]?.count ?? "?"}`);
  } catch (e) {
    console.warn("[persistUnitTypes] Verification count failed:", e);
  }
}
async function persistDevelopmentPhases(db3, developmentId, phasesData) {
  console.log(`[persistDevelopmentPhases] Processing ${phasesData.length} phases`);
  const existingPhases = await db3.select({ id: developmentPhases.id }).from(developmentPhases).where(eq4(developmentPhases.developmentId, developmentId));
  const existingIds = new Set(existingPhases.map((p) => Number(p.id)));
  const incomingIds = new Set(phasesData.filter((p) => p.id).map((p) => Number(p.id)));
  const idsToDelete = Array.from(existingIds).filter((id) => !incomingIds.has(id));
  if (idsToDelete.length > 0) {
    await db3.delete(developmentPhases).where(
      and4(
        eq4(developmentPhases.developmentId, developmentId),
        inArray2(developmentPhases.id, idsToDelete)
      )
    );
  }
  for (const phase of phasesData) {
    if (!phase.id) {
      phase.id = `phase-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    const phasePayload = {
      id: phase.id,
      developmentId,
      name: phase.name || "Unnamed Phase",
      description: phase.description || null,
      status: phase.status || "planning",
      completionDate: phase.completionDate || null,
      totalUnits: phase.totalUnits || null,
      availableUnits: phase.availableUnits || null,
      media: JSON.stringify(phase.media || {})
    };
    if (existingIds.has(phase.id)) {
      await db3.update(developmentPhases).set(phasePayload).where(eq4(developmentPhases.id, phase.id));
    } else {
      await db3.insert(developmentPhases).values({
        ...phasePayload,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  }
}
async function getDevelopmentWithPhases(id) {
  console.log("[getDevelopmentWithPhases] Loading development:", id);
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  try {
    const [{ dbName }] = await db3.execute(sql6`SELECT DATABASE() as dbName`);
    console.log(`[getDevelopmentWithPhases] DB Connection verified: ${dbName}`);
  } catch (e) {
    console.warn("[getDevelopmentWithPhases] DB Check skipped");
  }
  const [dev] = await db3.select().from(developments).where(eq4(developments.id, id)).limit(1);
  if (!dev) {
    throw new Error("Development not found");
  }
  let unitTypesData = [];
  let phasesData = [];
  try {
    const [unitTypesRes, phasesRes] = await Promise.all([
      db3.select().from(unitTypes).where(eq4(unitTypes.developmentId, id)),
      db3.select().from(developmentPhases).where(eq4(developmentPhases.developmentId, id))
    ]);
    unitTypesData = unitTypesRes || [];
    phasesData = phasesRes || [];
    console.log(
      `[getDevelopmentWithPhases] Loaded ${unitTypesData.length} units, ${phasesData.length} phases`
    );
  } catch (error) {
    console.error("[getDevelopmentWithPhases] Failed to load related data:", error.message);
  }
  const parse = (val, def) => {
    if (!val) return def;
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        console.warn("[getDevelopmentWithPhases] JSON parse failed for:", val);
        return def;
      }
    }
    return val;
  };
  const dbImages = parse(dev.images, []);
  const dbMedia = parse(dev.media, { photos: [], videos: [], brochures: [] });
  const heroImage = dbMedia.heroImage?.url || (dbImages[0]?.url ?? dbImages[0]);
  return {
    ...dev,
    // Parsed images array (for assertPublishable validation)
    images: dbImages,
    // Parse JSON columns
    media: {
      ...dbMedia,
      // Ensure heroImage is available for validation
      heroImage: heroImage ? { url: heroImage } : void 0
    },
    amenities: parse(dev.amenities, { standard: [], additional: [] }),
    estateSpecs: parse(dev.estateSpecs, {}),
    specifications: parse(dev.specifications, {}),
    residentialConfig: parse(dev.residentialConfig, {}),
    landConfig: parse(dev.landConfig, {}),
    commercialConfig: parse(dev.commercialConfig, {}),
    mixedUseConfig: parse(dev.mixedUseConfig, {}),
    // keywords: parse(dev.keywords, []),
    // CRITICAL: Always return arrays (never undefined)
    unitTypes: unitTypesData.map((u) => ({
      ...u,
      extras: parse(u.extras, []),
      specifications: parse(u.specifications, {}),
      amenities: parse(u.amenities, { standard: [], additional: [] }),
      baseMedia: parse(u.baseMedia, { gallery: [], floorPlans: [], renders: [] })
      // NOTE: 'specs' column does not exist - spec variations are in separate table
    })),
    phases: phasesData.map((p) => ({
      ...p,
      media: parse(p.media, {})
    }))
  };
}
async function getDevelopmentsByDeveloperId(developerId) {
  const db3 = await getDb();
  if (!db3) return [];
  const results = await db3.select().from(developments).where(eq4(developments.developerId, developerId));
  return results.map((dev) => ({
    ...dev,
    amenities: normalizeAmenities(dev.amenities),
    images: parseJsonField(dev.images),
    videos: parseJsonField(dev.videos),
    floorPlans: parseJsonField(dev.floorPlans),
    brochures: parseJsonField(dev.brochures)
  }));
}
async function createPhase(developmentId, developerId, data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [result] = await db3.insert(developmentPhases).values({
    ...data,
    developmentId
  });
  const [created] = await db3.select().from(developmentPhases).where(eq4(developmentPhases.id, result.insertId)).limit(1);
  return created;
}
async function updatePhase(phaseId, developerId, data) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developmentPhases).set(data).where(eq4(developmentPhases.id, phaseId));
  const [updated] = await db3.select().from(developmentPhases).where(eq4(developmentPhases.id, phaseId)).limit(1);
  return updated;
}
async function deleteDevelopment(id, developerId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  if (developerId !== void 0 && developerId !== -1) {
    const [dev] = await db3.select().from(developments).where(eq4(developments.id, id)).limit(1);
    if (!dev) throw new Error("Development not found");
    if (dev.developerId !== developerId)
      throw new Error("Unauthorized: You do not own this development");
  }
  console.log("[deleteDevelopment] Deleting unit types for development:", id);
  await db3.delete(unitTypes).where(eq4(unitTypes.developmentId, id));
  console.log("[deleteDevelopment] Deleting phases for development:", id);
  await db3.delete(developmentPhases).where(eq4(developmentPhases.developmentId, id));
  console.log("[deleteDevelopment] Deleting development:", id);
  const result = await db3.delete(developments).where(eq4(developments.id, id));
  return result;
}
async function publishDevelopment(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developments).set({
    isPublished: 1,
    publishedAt: (/* @__PURE__ */ new Date()).toISOString(),
    status: "launching-soon"
  }).where(eq4(developments.id, id));
  const [updated] = await db3.select().from(developments).where(eq4(developments.id, id)).limit(1);
  return updated;
}
async function approveDevelopment(id, adminId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developments).set({
    status: "selling",
    // or 'launching-soon' based on business logic, but 'active' implies live
    approvalStatus: "approved",
    isPublished: true,
    approvedAt: (/* @__PURE__ */ new Date()).toISOString(),
    approvedBy: adminId
  }).where(eq4(developments.id, id));
}
async function rejectDevelopment(id, adminId, reason) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developments).set({
    status: "rejected",
    isPublished: false,
    rejectionReason: reason
  }).where(eq4(developments.id, id));
}
async function requestChanges(id, adminId, notes) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(developments).set({
    status: "pending_changes",
    isPublished: false,
    changeRequestNotes: notes
  }).where(eq4(developments.id, id));
}
var developmentService = {
  // Admin Workflow
  approveDevelopment,
  rejectDevelopment,
  requestChanges,
  // Public
  getPublicDevelopmentBySlug,
  getPublicDevelopment,
  listPublicDevelopments,
  // Admin/Developer
  createDevelopment,
  updateDevelopment,
  getDevelopmentWithPhases,
  getDevelopmentsByDeveloperId,
  getDeveloperDevelopments: getDevelopmentsByDeveloperId,
  createPhase,
  updatePhase,
  deleteDevelopment,
  publishDevelopment,
  saveDraft,
  publishDevelopmentStrict
};
async function saveDraft(developerId, wizardState) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  if (!developerId) {
    throw new Error("Developer ID is required");
  }
  try {
    const draftPayload = {
      developerId,
      developerBrandProfileId: wizardState.developerBrandProfileId || null,
      draftName: wizardState.name || "Untitled Draft",
      draftData: wizardState,
      progress: 0,
      // Calculate based on completed steps if needed
      currentStep: 0
    };
    const [result] = await db3.insert(developmentDrafts).values(draftPayload);
    return { draftId: result.insertId };
  } catch (error) {
    console.error("[saveDraft] Error:", error);
    throw new Error(`Failed to save draft: ${error.message}`);
  }
}
async function publishDevelopmentStrict(developerId, wizardState, ownerType = "developer") {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  console.log("[publishDevelopmentStrict] Starting publish for developer:", developerId);
  let normalized;
  try {
    normalized = normalizeForPublish(wizardState, ownerType);
  } catch (error) {
    throw new TRPCError3({
      code: "BAD_REQUEST",
      message: "Normalization failed",
      cause: {
        field: "normalization",
        error: error.message
      }
    });
  }
  try {
    validateNormalizedPayload(normalized);
  } catch (error) {
    throw new TRPCError3({
      code: "BAD_REQUEST",
      message: "Validation failed",
      cause: {
        field: "validation",
        error: error.message
      }
    });
  }
  validateForPublish(wizardState);
  const slug = await generateUniqueSlug(normalized.name);
  try {
    const result = await db3.transaction(async (tx) => {
      const devPayload = {
        ...normalized,
        developerId,
        slug,
        isPublished: 1,
        publishedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const [insertResult] = await tx.insert(developments).values(devPayload);
      const newId = insertResult.insertId;
      let unitCount = 0;
      if (wizardState.unitTypes && Array.isArray(wizardState.unitTypes) && wizardState.unitTypes.length > 0) {
        await persistUnitTypes(tx, newId, wizardState.unitTypes);
        const [{ count: count9 }] = await tx.select({ count: sql6`count(*)` }).from(unitTypes).where(eq4(unitTypes.developmentId, newId));
        unitCount = Number(count9);
        if (unitCount === 0) {
          throw new TRPCError3({
            code: "INTERNAL_SERVER_ERROR",
            message: "Unit types were provided but none were persisted"
          });
        }
      }
      return { newId, unitCount };
    });
    console.log("[publishDevelopmentStrict] Success:", result);
    return { developmentId: result.newId, unitTypesCount: result.unitCount };
  } catch (error) {
    console.error("[publishDevelopmentStrict] Transaction failed:", error);
    if (error instanceof TRPCError3) {
      throw error;
    }
    throw new TRPCError3({
      code: "INTERNAL_SERVER_ERROR",
      message: `Publish failed: ${error.message}`
    });
  }
}
function validateForPublish(wizardState) {
  const errors = {};
  if (!wizardState.unitTypes || !Array.isArray(wizardState.unitTypes) || wizardState.unitTypes.length === 0) {
    errors["unitTypes"] = "At least one unit type is required";
  }
  const hasHeroImage = wizardState.images && Array.isArray(wizardState.images) && wizardState.images.length > 0 || wizardState.images && typeof wizardState.images === "string" && wizardState.images.trim() !== "";
  if (!hasHeroImage) {
    errors["media.heroImage"] = "At least one photo (Hero Image) is required";
  }
  if (Object.keys(errors).length > 0) {
    throw new TRPCError3({
      code: "BAD_REQUEST",
      message: "Publish validation failed",
      cause: {
        fields: errors
      }
    });
  }
}

// server/adminRouter.ts
var adminRouter = router({
  /**
  * Super Admin: Get action items (pending counts)
  * Designed for fast polling on the dashboard
  */
  getAdminActionItems: superAdminProcedure.query(async () => {
    const [agents2, listings2, developments3] = await Promise.all([
      countPendingAgents(),
      countPendingListings(),
      countPendingDevelopments()
    ]);
    return {
      pendingAgentApprovals: agents2,
      pendingListingApprovals: listings2,
      pendingDevelopmentApprovals: developments3,
      flaggedItems: 0
      // Placeholder
    };
  }),
  /**
   * Super Admin: Get Ecosystem Overview Stats
   */
  getEcosystemStats: superAdminProcedure.query(async () => {
    return getEcosystemStats();
  }),
  /**
   * Super Admin: List all users with pagination and filters
   */
  listUsers: superAdminProcedure.input(
    z2.object({
      page: z2.number().default(1),
      limit: z2.number().default(50),
      role: z2.enum(["visitor", "agent", "agency_admin", "super_admin"]).optional(),
      agencyId: z2.number().optional(),
      search: z2.string().optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.VIEW_ALL_USERS,
      metadata: { filters: input },
      req: ctx.req
    });
    const offset = (input.page - 1) * input.limit;
    const conditions = [];
    if (input.role) conditions.push(eq5(users.role, input.role));
    if (input.agencyId) conditions.push(eq5(users.agencyId, input.agencyId));
    if (input.search) {
      conditions.push(
        or3(
          like2(users.email, `%${input.search}%`),
          like2(users.firstName, `%${input.search}%`),
          like2(users.lastName, `%${input.search}%`)
        )
      );
    }
    const where = conditions.length > 0 ? and5(...conditions) : void 0;
    const [usersList, totalResult] = await Promise.all([
      db3.select().from(users).where(where).limit(input.limit).offset(offset).orderBy(desc3(users.createdAt)),
      db3.select({ count: sql7`count(*)` }).from(users).where(where)
    ]);
    const total = Number(totalResult[0]?.count || 0);
    return {
      users: usersList.map((u) => ({
        ...u,
        passwordHash: void 0
        // Never expose password hash
      })),
      pagination: {
        page: input.page,
        limit: input.limit,
        total,
        totalPages: Math.ceil(total / input.limit)
      }
    };
  }),
  /**
   * Super Admin: List all agencies
   */
  listAgencies: superAdminProcedure.input(
    z2.object({
      page: z2.number().default(1),
      limit: z2.number().default(50),
      search: z2.string().optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.VIEW_ALL_AGENCIES,
      metadata: { filters: input },
      req: ctx.req
    });
    const offset = (input.page - 1) * input.limit;
    const where = input.search ? or3(like2(agencies.name, `%${input.search}%`), like2(agencies.city, `%${input.search}%`)) : void 0;
    const [agenciesList, totalResult] = await Promise.all([
      db3.select().from(agencies).where(where).limit(input.limit).offset(offset).orderBy(desc3(agencies.createdAt)),
      db3.select({ count: sql7`count(*)` }).from(agencies).where(where)
    ]);
    const total = Number(totalResult[0]?.count || 0);
    return {
      agencies: agenciesList,
      pagination: {
        page: input.page,
        limit: input.limit,
        total,
        totalPages: Math.ceil(total / input.limit)
      }
    };
  }),
  /**
   * Super Admin: Update user role
   */
  updateUserRole: superAdminProcedure.input(
    z2.object({
      userId: z2.number(),
      role: z2.enum(["visitor", "agent", "agency_admin", "super_admin"])
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await db3.update(users).set({ role: input.role }).where(eq5(users.id, input.userId));
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.UPDATE_USER_ROLE,
      targetType: "user",
      targetId: input.userId,
      metadata: { newRole: input.role },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Super Admin: Get audit logs
   */
  /*
  // Super Admin: Get audit logs
  getAuditLogs: superAdminProcedure
    .input(
      z.object({
        page: z.number().default(1),
        limit: z.number().default(50),
        userId: z.number().optional(),
        action: z.string().optional(),
      }),
    )
    .query(async ({ ctx, input }) => {
       // ... Implementation commented out due to missing schema
       throw new Error("Feature temporarily unavailable");
    }),
  */
  /**
   * Agency Admin: List subaccounts (agents in their agency)
   */
  listSubaccounts: agencyAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const agencyId = ctx.user.role === "super_admin" ? void 0 : ctx.user.agencyId;
    if (ctx.user.role === "agency_admin" && !agencyId) {
      throw new Error("Agency admin must be associated with an agency");
    }
    const subaccounts = await db3.select().from(users).where(and5(eq5(users.isSubaccount, 1), agencyId ? eq5(users.agencyId, agencyId) : void 0)).orderBy(desc3(users.createdAt));
    return subaccounts.map((u) => ({
      ...u,
      passwordHash: void 0
    }));
  }),
  /**
   * Agency Admin: List join requests for their agency
   */
  listJoinRequests: agencyAdminProcedure.input(
    z2.object({
      status: z2.enum(["pending", "approved", "rejected"]).optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const agencyId = ctx.user.role === "super_admin" ? void 0 : ctx.user.agencyId;
    if (ctx.user.role === "agency_admin" && !agencyId) {
      throw new Error("Agency admin must be associated with an agency");
    }
    const conditions = [];
    if (agencyId) conditions.push(eq5(agencyJoinRequests.agencyId, agencyId));
    if (input.status) conditions.push(eq5(agencyJoinRequests.status, input.status));
    const where = conditions.length > 0 ? and5(...conditions) : void 0;
    const requests = await db3.select().from(agencyJoinRequests).where(where).orderBy(desc3(agencyJoinRequests.createdAt));
    return requests;
  }),
  /**
   * Agency Admin: Approve/reject join request
   */
  reviewJoinRequest: agencyAdminProcedure.input(
    z2.object({
      requestId: z2.number(),
      status: z2.enum(["approved", "rejected"])
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const [request] = await db3.select().from(agencyJoinRequests).where(eq5(agencyJoinRequests.id, input.requestId)).limit(1);
    if (!request) {
      throw new Error("Join request not found");
    }
    if (ctx.user.role === "agency_admin" && request.agencyId !== ctx.user.agencyId) {
      throw new Error("Unauthorized: Can only review requests for your own agency");
    }
    await db3.update(agencyJoinRequests).set({
      status: input.status,
      reviewedBy: ctx.user.id,
      reviewedAt: nowAsDbTimestamp()
    }).where(eq5(agencyJoinRequests.id, input.requestId));
    if (input.status === "approved") {
      await db3.update(users).set({
        agencyId: request.agencyId,
        isSubaccount: 1
      }).where(eq5(users.id, request.userId));
    }
    await logAudit({
      userId: ctx.user.id,
      action: input.status === "approved" ? AuditActions.APPROVE_JOIN_REQUEST : AuditActions.REJECT_JOIN_REQUEST,
      targetType: "join_request",
      targetId: input.requestId,
      metadata: { userId: request.userId, agencyId: request.agencyId },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Super Admin: Get platform analytics
   */
  getAnalytics: superAdminProcedure.query(async () => {
    return await getPlatformAnalytics();
  }),
  /**
   * Super Admin: Get listing statistics
   */
  getListingStats: superAdminProcedure.query(async () => {
    return await getListingStats();
  }),
  /**
   * Super Admin: List properties for oversight (Super Admin only)
   */
  listProperties: superAdminProcedure.input(
    z2.object({
      page: z2.number().default(1),
      limit: z2.number().default(50),
      status: z2.enum([
        "draft",
        "pending_review",
        "approved",
        "published",
        "rejected",
        "archived",
        "sold",
        "rented"
      ]).optional(),
      agencyId: z2.number().optional(),
      search: z2.string().optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.VIEW_ALL_PROPERTIES,
      metadata: { filters: input },
      req: ctx.req
    });
    const offset = (input.page - 1) * input.limit;
    const conditions = [];
    if (input.status) conditions.push(eq5(listings.status, input.status));
    if (input.agencyId) {
      conditions.push(eq5(listings.agencyId, input.agencyId));
    }
    if (input.search) {
      conditions.push(
        or3(
          like2(listings.title, `%${input.search}%`),
          like2(listings.address, `%${input.search}%`),
          like2(listings.city, `%${input.search}%`),
          like2(listings.slug, `%${input.search}%`)
        )
      );
    }
    const where = conditions.length > 0 ? and5(...conditions) : void 0;
    let orderByClause = [desc3(listings.createdAt)];
    if (input.status === "pending_review" || input.status === "approved") {
    }
    if (input.status === "pending_review") {
      orderByClause = [
        asc(listings.readinessScore),
        // Lowest readiness first (Review edge cases)
        desc3(listings.askingPrice),
        // High value items
        desc3(listings.createdAt)
        // Oldest first if tie
      ];
    }
    const [listingsList, totalResult] = await Promise.all([
      db3.select({
        id: listings.id,
        title: listings.title,
        askingPrice: listings.askingPrice,
        monthlyRent: listings.monthlyRent,
        status: listings.status,
        approvalStatus: listings.approvalStatus,
        city: listings.city,
        createdAt: listings.createdAt,
        propertyDetails: listings.propertyDetails,
        action: listings.action,
        // Agent Info
        agent: {
          id: agents.id,
          firstName: agents.firstName,
          lastName: agents.lastName,
          profileImage: agents.profileImage,
          isVerified: agents.isVerified
        },
        // Owner Info (fallback)
        owner: {
          id: users.id,
          firstName: users.firstName,
          lastName: users.lastName,
          email: users.email
        },
        // Media
        thumbnail: listingMedia.thumbnailUrl,
        mediaType: listingMedia.mediaType,
        // Scores (Phase 2/3)
        readinessScore: listings.readinessScore,
        qualityScore: listings.qualityScore
      }).from(listings).leftJoin(agents, eq5(listings.agentId, agents.id)).leftJoin(users, eq5(listings.ownerId, users.id)).leftJoin(listingMedia, eq5(listings.mainMediaId, listingMedia.id)).where(where).limit(input.limit).offset(offset).orderBy(...orderByClause),
      db3.select({ count: sql7`count(*)` }).from(listings).where(where)
    ]);
    const total = Number(totalResult[0]?.count || 0);
    return {
      properties: listingsList.map((l) => ({
        ...l,
        // Normalize price for display
        price: l.action === "rent" ? Number(l.monthlyRent) : Number(l.askingPrice),
        // Calculate Vibe Score (Mock for now, can be enhanced)
        vibeScore: Math.floor(Math.random() * 30) + 70
        // Random 70-100 for demo
      })),
      pagination: {
        page: input.page,
        limit: input.limit,
        total,
        totalPages: Math.ceil(total / input.limit)
      }
    };
  }),
  /**
   * Super Admin: Get Property Listing Stats (Health Monitor)
   */
  getPropertiesStats: superAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const [stats2] = await db3.select({
      totalInventoryValue: sql7`sum(${listings.askingPrice})`,
      newListingsToday: sql7`count(case when ${listings.createdAt} >= DATE_SUB(NOW(), INTERVAL 24 HOUR) then 1 end)`,
      pendingApprovals: sql7`count(case when ${listings.approvalStatus} = 'pending' then 1 end)`,
      // Quality Metrics
      averageQuality: sql7`avg(${listings.qualityScore})`,
      featuredCount: sql7`count(case when ${listings.qualityScore} >= 90 then 1 end)`,
      optimizedCount: sql7`count(case when ${listings.qualityScore} >= 75 AND ${listings.qualityScore} < 90 then 1 end)`
    }).from(listings).where(eq5(listings.status, "published"));
    const [pendingResult] = await db3.select({ count: sql7`count(*)` }).from(listings).where(eq5(listings.approvalStatus, "pending"));
    return {
      totalInventoryValue: Number(stats2?.totalInventoryValue || 0),
      newListingsToday: Number(stats2?.newListingsToday || 0),
      pendingApprovals: Number(pendingResult?.count || 0),
      // Quality Stats (Phase 6) - Using raw SQL to be safe if Drizzle types lag
      qualityMetrics: {
        averageScore: Number(stats2?.averageQuality || 0),
        featuredCount: Number(stats2?.featuredCount || 0),
        optimizedCount: Number(stats2?.optimizedCount || 0)
      }
    };
  }),
  /**
   * Super Admin: Get Development Approval Analytics (Fast-Track Monitoring)
   */
  getDevelopmentAnalytics: superAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const [pendingRes] = await db3.select({ count: sql7`count(*)` }).from(developments).where(eq5(developments.approvalStatus, "pending"));
    const [queueStats] = await db3.execute(sql7`
        SELECT
            COUNT(*) as total_processed,
            SUM(CASE WHEN status = 'approved' AND review_notes LIKE 'Auto-approved%' THEN 1 ELSE 0 END) as auto_approved,
            SUM(CASE WHEN status = 'approved' AND (review_notes IS NULL OR review_notes NOT LIKE 'Auto-approved%') THEN 1 ELSE 0 END) as manual_approved,
            SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) as rejected,
            AVG(CASE 
                WHEN status = 'approved' AND (review_notes IS NULL OR review_notes NOT LIKE 'Auto-approved%') 
                THEN TIMESTAMPDIFF(SECOND, submitted_at, reviewed_at) 
                ELSE NULL 
            END) as avg_manual_seconds
        FROM development_approval_queue
        WHERE status IN ('approved', 'rejected')
    `);
    const stats2 = queueStats[0] || {};
    const totalProcessed = Number(stats2.total_processed || 0);
    const autoApproved = Number(stats2.auto_approved || 0);
    const manualApproved = Number(stats2.manual_approved || 0);
    const approvalRate = totalProcessed > 0 ? (autoApproved + manualApproved) / totalProcessed : 0;
    const autoApprovalRate = autoApproved + manualApproved > 0 ? autoApproved / (autoApproved + manualApproved) : 0;
    return {
      pendingCount: Number(pendingRes?.count || 0),
      totalProcessed,
      autoApprovedCount: autoApproved,
      manualApprovedCount: manualApproved,
      rejectedCount: Number(stats2.rejected || 0),
      avgManualApprovalSeconds: Number(stats2.avg_manual_seconds || 0),
      autoApprovalRate
    };
  }),
  /**
   * Super Admin: Moderate property listing (approve/reject)
   */
  moderateProperty: superAdminProcedure.input(
    z2.object({
      propertyId: z2.number(),
      action: z2.enum(["approve", "reject", "archive"]),
      reason: z2.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    let newStatus;
    switch (input.action) {
      case "approve":
        newStatus = "available";
        break;
      case "reject":
        newStatus = "archived";
        break;
      case "archive":
        newStatus = "archived";
        break;
      default:
        throw new Error("Invalid action");
    }
    await updateProperty(
      input.propertyId,
      ctx.user.id,
      { status: newStatus },
      ctx.user.role
    );
    await logAudit({
      userId: ctx.user.id,
      action: input.action === "approve" ? AuditActions.APPROVE_PROPERTY : AuditActions.REJECT_PROPERTY,
      targetType: "property",
      targetId: input.propertyId,
      metadata: { reason: input.reason, newStatus },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Super Admin: Update subscription plan
   */
  /*
  updateSubscription: superAdminProcedure.mutation(async () => { throw new Error("Unavailable"); }),
  getPlatformSettings: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  updatePlatformSetting: superAdminProcedure.mutation(async () => { throw new Error("Unavailable"); }),
  */
  /**
   * Super Admin: Get comprehensive revenue analytics
   */
  /*
  getRevenueAnalytics: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  getCommissionBreakdown: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  getSubscriptionRevenue: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  getRevenueByPeriod: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  getRevenueByCategory: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  getLTVAnalytics: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  getRevenueForecast: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  getFailedPayments: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  */
  /**
   * Super Admin: Get General Platform Analytics
   */
  getGeneralAnalytics: superAdminProcedure.query(async () => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const results = await Promise.all([
      db3.select({ count: sql7`count(*)` }).from(users),
      db3.select({ count: sql7`count(*)` }).from(agencies),
      db3.select({ count: sql7`count(*)` }).from(listings),
      db3.select({ count: sql7`count(*)` }).from(listings).where(eq5(listings.status, "active")),
      db3.select({ count: sql7`count(*)` }).from(users).where(eq5(users.role, "agent")),
      db3.select().from(users).orderBy(desc3(users.createdAt)).limit(5),
      db3.select().from(listings).orderBy(desc3(listings.createdAt)).limit(5)
    ]);
    const [
      totalUsers,
      totalAgencies,
      totalListings,
      activeListings,
      totalAgents,
      recentUsers,
      recentListings
    ] = results;
    return {
      counts: {
        users: Number(totalUsers[0]?.count || 0),
        agencies: Number(totalAgencies[0]?.count || 0),
        listings: Number(totalListings[0]?.count || 0),
        activeListings: Number(activeListings[0]?.count || 0),
        agents: Number(totalAgents[0]?.count || 0)
      },
      recentActivity: {
        users: recentUsers,
        listings: recentListings
      }
    };
  }),
  /**
   * Super Admin: Get agents by status for approval
   */
  getPendingAgents: superAdminProcedure.input(
    z2.object({
      status: z2.enum(["pending", "approved", "rejected", "suspended"]).optional()
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const where = input.status ? eq5(agents.status, input.status) : void 0;
    const agentsList = await db3.select({
      id: agents.id,
      userId: agents.userId,
      displayName: agents.displayName,
      phone: agents.phone,
      phoneNumber: agents.phone,
      email: agents.email,
      bio: agents.bio,
      licenseNumber: agents.licenseNumber,
      specializations: agents.specialization,
      status: agents.status,
      rejectionReason: agents.rejectionReason,
      createdAt: agents.createdAt,
      approvedAt: agents.approvedAt
    }).from(agents).where(where).orderBy(desc3(agents.createdAt));
    return agentsList;
  }),
  /**
   * Super Admin: Approve agent application
   */
  approveAgent: superAdminProcedure.input(
    z2.object({
      agentId: z2.number()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await db3.update(agents).set({
      status: "approved",
      approvedBy: ctx.user.id,
      approvedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " "),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
    }).where(eq5(agents.id, input.agentId));
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.APPROVE_JOIN_REQUEST,
      targetType: "agent",
      targetId: input.agentId,
      metadata: { status: "approved" },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Super Admin: Reject agent application
   */
  rejectAgent: superAdminProcedure.input(
    z2.object({
      agentId: z2.number(),
      reason: z2.string()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await db3.update(agents).set({
      status: "rejected",
      rejectionReason: input.reason,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ")
    }).where(eq5(agents.id, input.agentId));
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.REJECT_JOIN_REQUEST,
      targetType: "agent",
      targetId: input.agentId,
      metadata: { status: "rejected", reason: input.reason },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Admin: List pending developments
   */
  adminListPendingDevelopments: superAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const pendingDevs = await db3.select({
      development: developments,
      developer: developers,
      queueEntry: developmentApprovalQueue
    }).from(developmentApprovalQueue).innerJoin(developments, eq5(developmentApprovalQueue.developmentId, developments.id)).innerJoin(developers, eq5(developments.developerId, developers.id)).where(eq5(developmentApprovalQueue.status, "pending")).orderBy(desc3(developmentApprovalQueue.submittedAt));
    return pendingDevs.map((item) => ({
      ...item.development,
      developerName: item.developer.name,
      submittedAt: item.queueEntry.submittedAt,
      queueId: item.queueEntry.id
    }));
  }),
  /**
   * Admin: Approve development
   */
  adminApproveDevelopment: superAdminProcedure.input(z2.object({
    developmentId: z2.number(),
    complianceChecks: z2.record(z2.boolean()).optional()
  })).mutation(async ({ ctx, input }) => {
    await developmentService.approveDevelopment(
      input.developmentId,
      ctx.user.id,
      input.complianceChecks
    );
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.UPDATE_DEVELOPMENT,
      targetType: "development",
      targetId: input.developmentId,
      metadata: { action: "approve", compliance: input.complianceChecks },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Admin: Reject development
   */
  adminRejectDevelopment: superAdminProcedure.input(z2.object({
    developmentId: z2.number(),
    reason: z2.string()
  })).mutation(async ({ ctx, input }) => {
    await developmentService.rejectDevelopment(input.developmentId, ctx.user.id, input.reason);
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.UPDATE_DEVELOPMENT,
      targetType: "development",
      targetId: input.developmentId,
      metadata: { action: "reject", reason: input.reason },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Admin: Request changes (Soft Rejection)
   */
  adminRequestChanges: superAdminProcedure.input(z2.object({
    developmentId: z2.number(),
    feedback: z2.string()
  })).mutation(async ({ ctx, input }) => {
    await developmentService.requestChanges(
      input.developmentId,
      ctx.user.id,
      input.feedback
    );
    await logAudit({
      userId: ctx.user.id,
      action: AuditActions.UPDATE_DEVELOPMENT,
      targetType: "development",
      targetId: input.developmentId,
      metadata: { action: "request_changes", feedback: input.feedback },
      req: ctx.req
    });
    return { success: true };
  })
  /**
   * Admin: Get Audit Logs for a Development
   */
  /*
  getDevelopmentAuditLogs: superAdminProcedure.query(async () => { throw new Error("Unavailable"); }),
  */
});

// server/agencyRouter.ts
import { z as z3 } from "zod";
init_schema();
init_db();
import { eq as eq6, like as like3, or as or4, desc as desc4, and as and6 } from "drizzle-orm";
var createAgencySchema = z3.object({
  name: z3.string().min(2, "Agency name must be at least 2 characters"),
  slug: z3.string().min(2).regex(/^[a-z0-9-]+$/, "Slug must contain only lowercase letters, numbers, and hyphens"),
  description: z3.string().optional(),
  logo: z3.string().url().optional(),
  website: z3.string().url().optional(),
  email: z3.string().email().optional(),
  phone: z3.string().optional(),
  address: z3.string().optional(),
  city: z3.string().optional(),
  province: z3.string().optional()
});
var updateAgencySchema = createAgencySchema.partial().extend({
  id: z3.number()
});
var agencyFiltersSchema = z3.object({
  search: z3.string().optional(),
  province: z3.string().optional(),
  subscriptionPlan: z3.enum(["free", "basic", "premium", "enterprise"]).optional(),
  isVerified: z3.boolean().optional(),
  limit: z3.number().min(1).max(100).default(20),
  offset: z3.number().min(0).default(0)
});
var agencyRouter = router({
  /**
   * Create agency during onboarding (authenticated users only)
   */
  createOnboarding: protectedProcedure.input(
    z3.object({
      basicInfo: z3.object({
        name: z3.string().min(2, "Agency name must be at least 2 characters"),
        description: z3.string().min(10, "Description must be at least 10 characters"),
        email: z3.string().email("Invalid email address"),
        phone: z3.string().optional(),
        website: z3.string().url().optional().or(z3.literal("")),
        address: z3.string().min(5, "Address must be at least 5 characters"),
        city: z3.string().min(2, "City is required"),
        province: z3.string().min(2, "Province is required")
      }),
      branding: z3.object({
        logoUrl: z3.string().optional(),
        primaryColor: z3.string().regex(/^#[0-9A-F]{6}$/i, "Invalid color format"),
        secondaryColor: z3.string().regex(/^#[0-9A-F]{6}$/i, "Invalid color format"),
        tagline: z3.string().max(100, "Tagline must be less than 100 characters").optional(),
        companyName: z3.string().min(2, "Company name is required")
      }),
      teamEmails: z3.array(z3.string().email()).optional().default([]),
      planId: z3.number()
    })
  ).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [plan] = await db3.select().from(plans).where(eq6(plans.id, input.planId)).limit(1);
    if (!plan || !plan.isActive) {
      throw new Error("Selected plan is not available");
    }
    const existing = await db3.select().from(agencies).where(
      or4(eq6(agencies.name, input.basicInfo.name), eq6(agencies.email, input.basicInfo.email))
    ).limit(1);
    if (existing.length > 0) {
      throw new Error("Agency name or email already registered");
    }
    const slug = input.basicInfo.name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
    const [slugExists] = await db3.select().from(agencies).where(eq6(agencies.slug, slug)).limit(1);
    const finalSlug = slugExists ? `${slug}-${Date.now()}` : slug;
    const [agencyResult] = await db3.insert(agencies).values({
      name: input.basicInfo.name,
      slug: finalSlug,
      description: input.basicInfo.description,
      email: input.basicInfo.email,
      phone: input.basicInfo.phone || null,
      website: input.basicInfo.website || null,
      address: input.basicInfo.address,
      city: input.basicInfo.city,
      province: input.basicInfo.province,
      logo: input.branding.logoUrl || null,
      subscriptionPlan: "free",
      subscriptionStatus: "pending_payment",
      // Will be updated to 'active' after payment
      isVerified: 0
    });
    const agencyId = Number(agencyResult.insertId);
    await db3.insert(agencyBranding).values({
      agencyId,
      primaryColor: input.branding.primaryColor,
      secondaryColor: input.branding.secondaryColor,
      companyName: input.branding.companyName,
      tagline: input.branding.tagline || null,
      logoUrl: input.branding.logoUrl || null,
      isEnabled: 1
    });
    await db3.update(users).set({
      agencyId,
      role: "agency_admin",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq6(users.id, ctx.user.id));
    if (input.teamEmails && input.teamEmails.length > 0) {
      const invitationValues = input.teamEmails.map((email) => ({
        agencyId,
        email,
        invitedBy: ctx.user.id,
        role: "agent",
        token: `invite-${Date.now()}-${Math.random().toString(36).substring(7)}`,
        status: "pending",
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
        // 7 days
      }));
      await db3.insert(invitations).values(invitationValues);
    }
    await logAudit({
      userId: ctx.user.id,
      action: "agency.create_onboarding",
      targetType: "agency",
      targetId: agencyId,
      metadata: { planId: input.planId },
      req: ctx.req
    });
    return { agencyId, slug: finalSlug };
  }),
  /**
  /**
   * Create a new agency (Super Admin only)
   */
  create: superAdminProcedure.input(createAgencySchema).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const existing = await db3.select().from(agencies).where(eq6(agencies.slug, input.slug)).limit(1);
    if (existing.length > 0) {
      throw new Error("An agency with this slug already exists");
    }
    const [result] = await db3.insert(agencies).values({
      name: input.name,
      slug: input.slug,
      description: input.description || null,
      logo: input.logo || null,
      website: input.website || null,
      email: input.email || null,
      phone: input.phone || null,
      address: input.address || null,
      city: input.city || null,
      province: input.province || null,
      subscriptionPlan: "free",
      subscriptionStatus: "trial",
      isVerified: 0
    });
    await logAudit({
      userId: ctx.user.id,
      action: "agency.create",
      targetType: "agency",
      targetId: Number(result.insertId),
      req: ctx.req
    });
    const [agency] = await db3.select().from(agencies).where(eq6(agencies.id, Number(result.insertId)));
    return agency;
  }),
  /**
   * Get all agencies with filters (Super Admin only)
   */
  list: superAdminProcedure.input(agencyFiltersSchema).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    let query = db3.select().from(agencies);
    const conditions = [];
    if (input.search) {
      conditions.push(
        or4(
          like3(agencies.name, `%${input.search}%`),
          like3(agencies.email, `%${input.search}%`),
          like3(agencies.city, `%${input.search}%`)
        )
      );
    }
    if (input.province) {
      conditions.push(eq6(agencies.province, input.province));
    }
    if (input.subscriptionPlan) {
      conditions.push(eq6(agencies.subscriptionPlan, input.subscriptionPlan));
    }
    if (input.isVerified !== void 0) {
      conditions.push(eq6(agencies.isVerified, input.isVerified ? 1 : 0));
    }
    if (conditions.length > 0) {
      query = query.where(or4(...conditions));
    }
    const results = await query.orderBy(desc4(agencies.createdAt)).limit(input.limit).offset(input.offset);
    const [{ count: count9 }] = await db3.select({ count: agencies.id }).from(agencies);
    return {
      agencies: results,
      total: Number(count9) || 0,
      limit: input.limit,
      offset: input.offset
    };
  }),
  /**
   * Get agency by ID (Public - for display)
   */
  getById: publicProcedure.input(z3.object({ id: z3.number() })).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [agency] = await db3.select().from(agencies).where(eq6(agencies.id, input.id)).limit(1);
    if (!agency) {
      throw new Error("Agency not found");
    }
    return agency;
  }),
  /**
   * Get agency by slug (Public - for display)
   */
  getBySlug: publicProcedure.input(z3.object({ slug: z3.string() })).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [agency] = await db3.select().from(agencies).where(eq6(agencies.slug, input.slug)).limit(1);
    if (!agency) {
      throw new Error("Agency not found");
    }
    return agency;
  }),
  /**
   * Update agency (Super Admin or Agency Admin for their own agency)
   */
  update: agencyAdminProcedure.input(updateAgencySchema).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const { id, ...updateData } = input;
    const [agency] = await db3.select().from(agencies).where(eq6(agencies.id, id)).limit(1);
    if (!agency) {
      throw new Error("Agency not found");
    }
    if (ctx.user.role !== "super_admin") {
      if (!ctx.user.agencyId || ctx.user.agencyId !== id) {
        throw new Error("You can only update your own agency");
      }
    }
    await db3.update(agencies).set({
      ...updateData,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq6(agencies.id, id));
    await logAudit({
      userId: ctx.user.id,
      action: "agency.update",
      targetType: "agency",
      targetId: id,
      req: ctx.req
    });
    const [updated] = await db3.select().from(agencies).where(eq6(agencies.id, id));
    return updated;
  }),
  /**
   * Delete agency (Super Admin only)
   */
  delete: superAdminProcedure.input(z3.object({ id: z3.number() })).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [agency] = await db3.select().from(agencies).where(eq6(agencies.id, input.id)).limit(1);
    if (!agency) {
      throw new Error("Agency not found");
    }
    await db3.delete(agencies).where(eq6(agencies.id, input.id));
    await logAudit({
      userId: ctx.user.id,
      action: "agency.delete",
      targetType: "agency",
      targetId: input.id,
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Verify agency (Super Admin only)
   */
  verify: superAdminProcedure.input(z3.object({ id: z3.number(), isVerified: z3.boolean() })).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    await db3.update(agencies).set({
      isVerified: input.isVerified ? 1 : 0,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq6(agencies.id, input.id));
    await logAudit({
      userId: ctx.user.id,
      action: input.isVerified ? "agency.verify" : "agency.unverify",
      targetType: "agency",
      targetId: input.id,
      req: ctx.req
    });
    const [updated] = await db3.select().from(agencies).where(eq6(agencies.id, input.id));
    return updated;
  }),
  /**
   * Get agency dashboard statistics
   */
  getDashboardStats: agencyAdminProcedure.query(async ({ ctx }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getAgencyDashboardStats(ctx.user.agencyId);
  }),
  /**
   * Get agency performance data for charts
   */
  getPerformanceData: agencyAdminProcedure.input(z3.object({ months: z3.number().default(6) }).optional()).query(async ({ ctx, input }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getAgencyPerformanceData(ctx.user.agencyId, input?.months || 6);
  }),
  /**
   * Get recent leads for agency dashboard
   */
  getRecentLeads: agencyAdminProcedure.input(z3.object({ limit: z3.number().default(5) }).optional()).query(async ({ ctx, input }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getAgencyRecentLeads(ctx.user.agencyId, input?.limit || 5);
  }),
  /**
   * Get recent listings for agency dashboard
   */
  getRecentListings: agencyAdminProcedure.input(z3.object({ limit: z3.number().default(5) }).optional()).query(async ({ ctx, input }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getAgencyRecentListings(ctx.user.agencyId, input?.limit || 5);
  }),
  /**
   * Get all agents in the agency (for management)
   */
  listAgents: agencyAdminProcedure.query(async ({ ctx }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getAgencyAgents(ctx.user.agencyId);
  }),
  /**
   * Update agent role within agency
   */
  updateAgentRole: agencyAdminProcedure.input(
    z3.object({
      userId: z3.number(),
      role: z3.enum(["agent", "agency_admin"])
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [user] = await db3.select().from(users).where(eq6(users.id, input.userId)).limit(1);
    if (!user || user.agencyId !== ctx.user.agencyId) {
      throw new Error("User not found in your agency");
    }
    if (user.id === ctx.user.id && input.role !== "agency_admin") {
      const agencyAdmins = await db3.select().from(users).where(and6(eq6(users.agencyId, ctx.user.agencyId), eq6(users.role, "agency_admin")));
      if (agencyAdmins.length === 1) {
        throw new Error("Cannot demote the last agency admin");
      }
    }
    await db3.update(users).set({
      role: input.role,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq6(users.id, input.userId));
    await logAudit({
      userId: ctx.user.id,
      action: "agency.agent_role_update",
      targetType: "user",
      targetId: input.userId,
      metadata: { newRole: input.role },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Remove agent from agency
   */
  removeAgent: agencyAdminProcedure.input(z3.object({ userId: z3.number() })).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [user] = await db3.select().from(users).where(eq6(users.id, input.userId)).limit(1);
    if (!user || user.agencyId !== ctx.user.agencyId) {
      throw new Error("User not found in your agency");
    }
    if (user.id === ctx.user.id) {
      throw new Error("Cannot remove yourself from the agency");
    }
    await db3.update(users).set({
      agencyId: null,
      isSubaccount: 0,
      role: "visitor",
      // Reset to default role
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq6(users.id, input.userId));
    await logAudit({
      userId: ctx.user.id,
      action: "agency.agent_removed",
      targetType: "user",
      targetId: input.userId,
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Get lead conversion statistics
   */
  getLeadConversionStats: agencyAdminProcedure.input(z3.object({ months: z3.number().default(6) }).optional()).query(async ({ ctx, input }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getLeadConversionStats(ctx.user.agencyId, input?.months || 6);
  }),
  /**
   * Get commission and earnings statistics
   */
  getCommissionStats: agencyAdminProcedure.input(z3.object({ months: z3.number().default(6) }).optional()).query(async ({ ctx, input }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getAgencyCommissionStats(ctx.user.agencyId, input?.months || 6);
  }),
  /**
   * Get agent performance leaderboard
   */
  getAgentLeaderboard: agencyAdminProcedure.input(z3.object({ months: z3.number().default(3) }).optional()).query(async ({ ctx, input }) => {
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    return await getAgentPerformanceLeaderboard(ctx.user.agencyId, input?.months || 3);
  }),
  /**
   * Get agency branding (public endpoint for theme customization)
   */
  getBranding: publicProcedure.input(z3.object({ agencyId: z3.number().optional() }).optional()).query(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      return {
        companyName: "Real Estate Portal",
        primaryColor: "#1e40af",
        secondaryColor: "#3b82f6",
        logoUrl: null,
        tagline: "Find Your Dream Home",
        isEnabled: true
      };
    }
    try {
      const targetAgencyId = input?.agencyId || ctx.user?.agencyId;
      if (!targetAgencyId) {
        return {
          companyName: "Real Estate Portal",
          primaryColor: "#1e40af",
          secondaryColor: "#3b82f6",
          logoUrl: null,
          tagline: "Find Your Dream Home",
          isEnabled: true
        };
      }
      const [branding] = await db3.select().from(agencyBranding).where(eq6(agencyBranding.agencyId, targetAgencyId)).limit(1);
      if (!branding || !branding.isEnabled) {
        return {
          companyName: "Real Estate Portal",
          primaryColor: "#1e40af",
          secondaryColor: "#3b82f6",
          logoUrl: null,
          tagline: "Find Your Dream Home",
          isEnabled: true
        };
      }
      return {
        companyName: branding.companyName,
        primaryColor: branding.primaryColor,
        secondaryColor: branding.secondaryColor,
        logoUrl: branding.logoUrl,
        tagline: branding.tagline,
        isEnabled: Boolean(branding.isEnabled)
      };
    } catch (error) {
      console.error("[agency.getBranding] Error:", error);
      return {
        companyName: "Real Estate Portal",
        primaryColor: "#1e40af",
        secondaryColor: "#3b82f6",
        logoUrl: null,
        tagline: "Find Your Dream Home",
        isEnabled: true
      };
    }
  })
});

// server/userRouter.ts
import { z as z4 } from "zod";
init_schema();
init_db();
import { eq as eq7, like as like4, or as or5, desc as desc5, and as and7 } from "drizzle-orm";
var userFiltersSchema = z4.object({
  search: z4.string().optional(),
  role: z4.enum(["visitor", "agent", "agency_admin", "property_developer", "super_admin"]).optional(),
  agencyId: z4.number().optional(),
  limit: z4.number().min(1).max(100).default(20),
  offset: z4.number().min(0).default(0)
});
var updateUserRoleSchema = z4.object({
  userId: z4.number(),
  role: z4.enum(["visitor", "agent", "agency_admin", "property_developer", "super_admin"])
});
var assignToAgencySchema = z4.object({
  userId: z4.number(),
  agencyId: z4.number().nullable(),
  isSubaccount: z4.boolean().default(false)
});
var userRouter = router({
  /**
   * Get all users with filters (Super Admin only)
   */
  list: superAdminProcedure.input(userFiltersSchema).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    let query = db3.select().from(users);
    const conditions = [];
    if (input.search) {
      conditions.push(
        or5(
          like4(users.email, `%${input.search}%`),
          like4(users.name, `%${input.search}%`),
          like4(users.firstName, `%${input.search}%`),
          like4(users.lastName, `%${input.search}%`)
        )
      );
    }
    if (input.role) {
      conditions.push(eq7(users.role, input.role));
    }
    if (input.agencyId !== void 0) {
      if (input.agencyId === null) {
        conditions.push(eq7(users.agencyId, null));
      } else {
        conditions.push(eq7(users.agencyId, input.agencyId));
      }
    }
    if (conditions.length > 0) {
      query = query.where(and7(...conditions));
    }
    const results = await query.orderBy(desc5(users.createdAt)).limit(input.limit).offset(input.offset);
    const allUsers = await db3.select().from(users);
    const total = allUsers.length;
    return {
      users: results,
      total,
      limit: input.limit,
      offset: input.offset
    };
  }),
  /**
   * Get user by ID (Super Admin only)
   */
  getById: superAdminProcedure.input(z4.object({ userId: z4.number() })).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [user] = await db3.select().from(users).where(eq7(users.id, input.userId)).limit(1);
    if (!user) {
      throw new Error("User not found");
    }
    return user;
  }),
  /**
   * Update user role (Super Admin only)
   */
  updateRole: superAdminProcedure.input(updateUserRoleSchema).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [user] = await db3.select().from(users).where(eq7(users.id, input.userId)).limit(1);
    if (!user) {
      throw new Error("User not found");
    }
    if (user.role === "super_admin" && input.role !== "super_admin") {
      const superAdmins = await db3.select().from(users).where(eq7(users.role, "super_admin"));
      if (superAdmins.length === 1) {
        throw new Error("Cannot demote the last super admin");
      }
    }
    await db3.update(users).set({
      role: input.role,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq7(users.id, input.userId));
    await logAudit({
      userId: ctx.user.id,
      action: "user.update_role",
      targetType: "user",
      targetId: input.userId,
      metadata: {
        oldRole: user.role,
        newRole: input.role
      },
      req: ctx.req
    });
    const [updated] = await db3.select().from(users).where(eq7(users.id, input.userId));
    return updated;
  }),
  /**
   * Assign user to agency (Super Admin only)
   */
  assignToAgency: superAdminProcedure.input(assignToAgencySchema).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [user] = await db3.select().from(users).where(eq7(users.id, input.userId)).limit(1);
    if (!user) {
      throw new Error("User not found");
    }
    await db3.update(users).set({
      agencyId: input.agencyId,
      isSubaccount: input.agencyId ? input.isSubaccount ? 1 : 0 : 0,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq7(users.id, input.userId));
    await logAudit({
      userId: ctx.user.id,
      action: input.agencyId ? "user.assign_agency" : "user.remove_agency",
      targetType: "user",
      targetId: input.userId,
      metadata: {
        agencyId: input.agencyId,
        isSubaccount: input.isSubaccount
      },
      req: ctx.req
    });
    const [updated] = await db3.select().from(users).where(eq7(users.id, input.userId));
    return updated;
  }),
  /**
   * Delete user (Super Admin only)
   */
  delete: superAdminProcedure.input(z4.object({ userId: z4.number() })).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [user] = await db3.select().from(users).where(eq7(users.id, input.userId)).limit(1);
    if (!user) {
      throw new Error("User not found");
    }
    if (user.id === ctx.user.id) {
      throw new Error("Cannot delete your own account");
    }
    if (user.role === "super_admin") {
      const superAdmins = await db3.select().from(users).where(eq7(users.role, "super_admin"));
      if (superAdmins.length === 1) {
        throw new Error("Cannot delete the last super admin");
      }
    }
    await db3.delete(users).where(eq7(users.id, input.userId));
    await logAudit({
      userId: ctx.user.id,
      action: "user.delete",
      targetType: "user",
      targetId: input.userId,
      metadata: {
        email: user.email,
        role: user.role
      },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Get user statistics
   */
  stats: superAdminProcedure.query(async () => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const allUsers = await db3.select().from(users);
    const stats2 = {
      total: allUsers.length,
      byRole: {
        super_admin: allUsers.filter((u) => u.role === "super_admin").length,
        agency_admin: allUsers.filter((u) => u.role === "agency_admin").length,
        agent: allUsers.filter((u) => u.role === "agent").length,
        visitor: allUsers.filter((u) => u.role === "visitor").length
      },
      withAgency: allUsers.filter((u) => u.agencyId !== null).length,
      subaccounts: allUsers.filter((u) => u.isSubaccount === 1).length
    };
    return stats2;
  })
});

// server/invitationRouter.ts
import { z as z5 } from "zod";
init_schema();
init_db();
import { eq as eq8, and as and8, desc as desc6 } from "drizzle-orm";
init_auth();
init_const();
import crypto3 from "crypto";
var createInvitationSchema = z5.object({
  email: z5.string().email("Invalid email address"),
  role: z5.enum(["agent", "agency_admin"]).default("agent")
});
var acceptInvitationSchema = z5.object({
  token: z5.string()
});
var invitationRouter = router({
  /**
   * Create a new invitation (Agency Admin only)
   */
  create: agencyAdminProcedure.input(createInvitationSchema).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency to send invitations");
    }
    const [existingUser] = await db3.select().from(users).where(eq8(users.email, input.email)).limit(1);
    if (existingUser && existingUser.agencyId === ctx.user.agencyId) {
      throw new Error("This user is already part of your agency");
    }
    const [existingInvitation] = await db3.select().from(invitations).where(
      and8(
        eq8(invitations.email, input.email),
        eq8(invitations.agencyId, ctx.user.agencyId),
        eq8(invitations.status, "pending")
      )
    ).limit(1);
    if (existingInvitation) {
      throw new Error("An invitation has already been sent to this email");
    }
    const token = crypto3.randomBytes(32).toString("hex");
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);
    const [result] = await db3.insert(invitations).values({
      agencyId: ctx.user.agencyId,
      invitedBy: ctx.user.id,
      email: input.email,
      role: input.role,
      token,
      status: "pending",
      expiresAt
    });
    await logAudit({
      userId: ctx.user.id,
      action: "invitation.create",
      targetType: "invitation",
      targetId: Number(result.insertId),
      metadata: {
        email: input.email,
        role: input.role
      },
      req: ctx.req
    });
    const [invitation] = await db3.select().from(invitations).where(eq8(invitations.id, Number(result.insertId)));
    return invitation;
  }),
  /**
   * List invitations for the agency (Agency Admin only)
   */
  list: agencyAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    if (!ctx.user.agencyId) {
      throw new Error("You must be part of an agency");
    }
    const results = await db3.select().from(invitations).where(eq8(invitations.agencyId, ctx.user.agencyId)).orderBy(desc6(invitations.createdAt));
    return results;
  }),
  /**
   * Get invitation by token (Public - for acceptance page)
   */
  getByToken: publicProcedure.input(z5.object({ token: z5.string() })).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [invitation] = await db3.select().from(invitations).where(eq8(invitations.token, input.token)).limit(1);
    if (!invitation) {
      throw new Error("Invitation not found");
    }
    if (/* @__PURE__ */ new Date() > new Date(invitation.expiresAt)) {
      await db3.update(invitations).set({ status: "expired" }).where(eq8(invitations.id, invitation.id));
      throw new Error("This invitation has expired");
    }
    if (invitation.status !== "pending") {
      throw new Error(`This invitation is ${invitation.status}`);
    }
    return invitation;
  }),
  /**
   * Accept invitation (Authenticated user)
   */
  accept: protectedProcedure.input(acceptInvitationSchema).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [invitation] = await db3.select().from(invitations).where(eq8(invitations.token, input.token)).limit(1);
    if (!invitation) {
      throw new Error("Invitation not found");
    }
    if (invitation.status !== "pending") {
      throw new Error(`This invitation is ${invitation.status}`);
    }
    if (/* @__PURE__ */ new Date() > new Date(invitation.expiresAt)) {
      await db3.update(invitations).set({ status: "expired" }).where(eq8(invitations.id, invitation.id));
      throw new Error("This invitation has expired");
    }
    if (ctx.user.email !== invitation.email) {
      throw new Error("This invitation is for a different email address");
    }
    await db3.update(users).set({
      agencyId: invitation.agencyId,
      role: invitation.role,
      isSubaccount: 1,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq8(users.id, ctx.user.id));
    await db3.update(invitations).set({
      status: "accepted",
      acceptedAt: /* @__PURE__ */ new Date(),
      acceptedBy: ctx.user.id
    }).where(eq8(invitations.id, invitation.id));
    const [updatedUser] = await db3.select().from(users).where(eq8(users.id, ctx.user.id)).limit(1);
    if (updatedUser) {
      const sessionToken = await authService.createSessionToken(
        updatedUser.id,
        updatedUser.email,
        updatedUser.name || updatedUser.email
      );
      ctx.res.cookie(COOKIE_NAME, sessionToken, getSessionCookieOptions(ctx.req));
    }
    await logAudit({
      userId: ctx.user.id,
      action: "invitation.accept",
      targetType: "invitation",
      targetId: invitation.id,
      metadata: {
        agencyId: invitation.agencyId
      },
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Cancel invitation (Agency Admin only)
   */
  cancel: agencyAdminProcedure.input(z5.object({ invitationId: z5.number() })).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [invitation] = await db3.select().from(invitations).where(eq8(invitations.id, input.invitationId)).limit(1);
    if (!invitation) {
      throw new Error("Invitation not found");
    }
    if (invitation.agencyId !== ctx.user.agencyId) {
      throw new Error("You can only cancel invitations from your agency");
    }
    await db3.update(invitations).set({ status: "cancelled" }).where(eq8(invitations.id, input.invitationId));
    await logAudit({
      userId: ctx.user.id,
      action: "invitation.cancel",
      targetType: "invitation",
      targetId: input.invitationId,
      req: ctx.req
    });
    return { success: true };
  }),
  /**
   * Resend invitation (creates new token with new expiry)
   */
  resend: agencyAdminProcedure.input(z5.object({ invitationId: z5.number() })).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3) {
      throw new Error("Database not available");
    }
    const [invitation] = await db3.select().from(invitations).where(eq8(invitations.id, input.invitationId)).limit(1);
    if (!invitation) {
      throw new Error("Invitation not found");
    }
    if (invitation.agencyId !== ctx.user.agencyId) {
      throw new Error("You can only resend invitations from your agency");
    }
    const token = crypto3.randomBytes(32).toString("hex");
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);
    await db3.update(invitations).set({
      token,
      expiresAt,
      status: "pending",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq8(invitations.id, input.invitationId));
    await logAudit({
      userId: ctx.user.id,
      action: "invitation.resend",
      targetType: "invitation",
      targetId: input.invitationId,
      req: ctx.req
    });
    const [updated] = await db3.select().from(invitations).where(eq8(invitations.id, input.invitationId));
    return updated;
  })
});

// server/agentRouter.ts
init_db();
init_schema();
init_env();
import { z as z6 } from "zod";
import { eq as eq9, and as and9, desc as desc7, gte as gte3, lte as lte3, sql as sql8, count as count2, or as or7 } from "drizzle-orm";
var agentRouter = router({
  /**
   * Get agent's dashboard KPIs
   */
  getDashboardStats: agentProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      return {
        activeListings: 0,
        newLeadsThisWeek: 0,
        showingsToday: 0,
        offersInProgress: 0,
        commissionsPending: 0
      };
    }
    const agentId = agentRecord.id;
    const todayDate = /* @__PURE__ */ new Date();
    todayDate.setHours(0, 0, 0, 0);
    const tomorrowDate = new Date(todayDate);
    tomorrowDate.setDate(tomorrowDate.getDate() + 1);
    const today = todayDate.toISOString();
    const tomorrow = tomorrowDate.toISOString();
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3).toISOString();
    const [activeListingsResult] = await db3.select({ count: count2() }).from(properties).where(and9(eq9(properties.agentId, agentId), eq9(properties.status, "available")));
    const [newLeadsResult] = await db3.select({ count: count2() }).from(leads).where(and9(eq9(leads.agentId, agentId), gte3(leads.createdAt, weekAgo)));
    const [showingsTodayResult] = await db3.select({ count: count2() }).from(showings).where(
      and9(
        eq9(showings.agentId, agentId),
        gte3(showings.scheduledAt, today),
        lte3(showings.scheduledAt, tomorrow)
      )
    );
    const [offersInProgressResult] = await db3.select({ count: count2() }).from(offers).where(and9(eq9(offers.agentId, agentId), eq9(offers.status, "pending")));
    const [pendingCommissionsResult] = await db3.select({ total: sql8`SUM(${commissions.amount})` }).from(commissions).where(and9(eq9(commissions.agentId, agentId), eq9(commissions.status, "pending")));
    return {
      activeListings: activeListingsResult?.count || 0,
      newLeadsThisWeek: newLeadsResult?.count || 0,
      showingsToday: showingsTodayResult?.count || 0,
      offersInProgress: offersInProgressResult?.count || 0,
      commissionsPending: Number(pendingCommissionsResult?.total || 0)
    };
  }),
  /**
   * Get leads pipeline for Kanban board
   */
  getLeadsPipeline: agentProcedure.input(
    z6.object({
      filters: z6.object({
        propertyId: z6.number().optional(),
        source: z6.string().optional(),
        dateRange: z6.object({
          start: z6.string().optional(),
          end: z6.string().optional()
        }).optional()
      }).optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const conditions = [eq9(leads.agentId, agentRecord.id)];
    if (input.filters?.propertyId) {
      conditions.push(eq9(leads.propertyId, input.filters.propertyId));
    }
    if (input.filters?.source) {
      conditions.push(eq9(leads.source, input.filters.source));
    }
    if (input.filters?.dateRange?.start) {
      conditions.push(gte3(leads.createdAt, new Date(input.filters.dateRange.start).toISOString()));
    }
    if (input.filters?.dateRange?.end) {
      conditions.push(lte3(leads.createdAt, new Date(input.filters.dateRange.end).toISOString()));
    }
    const leadsList = await db3.select({
      lead: leads,
      property: properties
    }).from(leads).leftJoin(properties, eq9(leads.propertyId, properties.id)).where(and9(...conditions)).orderBy(leads.createdAt);
    const pipeline = {
      new: [],
      contacted: [],
      viewing: [],
      offer: [],
      closed: []
    };
    leadsList.forEach(({ lead, property }) => {
      let stage = "new";
      switch (lead.status) {
        case "new":
          stage = "new";
          break;
        case "contacted":
        case "qualified":
          stage = "contacted";
          break;
        case "viewing_scheduled":
          stage = "viewing";
          break;
        case "offer_sent":
        case "converted":
          stage = "offer";
          break;
        case "closed":
          stage = "closed";
          break;
        default:
          stage = "new";
      }
      pipeline[stage].push({
        id: lead.id,
        name: lead.name,
        email: lead.email,
        phone: lead.phone,
        status: lead.status,
        source: lead.source,
        notes: lead.notes,
        createdAt: lead.createdAt || /* @__PURE__ */ new Date(),
        property: property ? {
          id: property.id,
          title: property.title,
          city: property.city,
          price: Number(property.price)
        } : null
      });
    });
    return pipeline;
  }),
  /**
   * Move lead to different pipeline stage
   */
  moveLeadToStage: agentProcedure.input(
    z6.object({
      leadId: z6.number(),
      targetStage: z6.enum(["new", "contacted", "viewing", "offer", "closed"]),
      notes: z6.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const [lead] = await db3.select().from(leads).where(eq9(leads.id, input.leadId)).limit(1);
    if (!lead || lead.agentId !== agentRecord.id) {
      throw new Error("Lead not found or unauthorized");
    }
    let newStatus = "new";
    switch (input.targetStage) {
      case "new":
        newStatus = "new";
        break;
      case "contacted":
        newStatus = "contacted";
        break;
      case "viewing":
        newStatus = "viewing_scheduled";
        break;
      case "offer":
        newStatus = "offer_sent";
        break;
      case "closed":
        newStatus = "closed";
        break;
    }
    await db3.update(leads).set({
      status: newStatus,
      updatedAt: nowAsDbTimestamp()
    }).where(eq9(leads.id, input.leadId));
    await db3.insert(leadActivities).values({
      leadId: input.leadId,
      agentId: agentRecord.id,
      activityType: "status_change",
      description: input.notes || `Moved to ${input.targetStage} stage`
    });
    await db3.insert(notifications).values({
      userId: ctx.user.id,
      type: "lead_assigned",
      title: "Lead Status Updated",
      content: `Lead "${lead.name}" moved to ${input.targetStage} stage`,
      data: JSON.stringify({ leadId: input.leadId, newStage: input.targetStage })
    });
    return { success: true };
  }),
  /**
   * Get agent's listings with images
   * Get agent's listings
   */
  getMyListings: agentProcedure.input(
    z6.object({
      status: z6.string().optional(),
      limit: z6.number().default(50)
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    const conditions = [];
    if (agentRecord) {
      conditions.push(
        or7(
          eq9(properties.agentId, agentRecord.id),
          eq9(properties.ownerId, ctx.user.id)
        )
      );
    } else {
      conditions.push(eq9(properties.ownerId, ctx.user.id));
    }
    if (input.status && input.status !== "all") {
      conditions.push(eq9(properties.status, input.status));
    }
    const listings2 = await db3.select().from(properties).where(and9(...conditions)).orderBy(desc7(properties.createdAt)).limit(input.limit);
    const listingsWithImages = await Promise.all(
      listings2.map(async (property) => {
        const images = await db3.select().from(propertyImages).where(eq9(propertyImages.propertyId, property.id)).orderBy(propertyImages.displayOrder).limit(1);
        const cdnUrl = ENV.cloudFrontUrl || `https://${ENV.s3BucketName}.s3.${ENV.awsRegion}.amazonaws.com`;
        const primaryImage = images.length > 0 ? images[0].imageUrl.startsWith("http") ? images[0].imageUrl : `${cdnUrl}/${images[0].imageUrl}` : null;
        return {
          ...property,
          primaryImage,
          imageCount: 0,
          // TODO: Get actual count
          enquiries: property.enquiries || 0
        };
      })
    );
    return listingsWithImages;
  }),
  /**
   * Archive property
   */
  archiveProperty: agentProcedure.input(z6.object({ id: z6.number() })).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [property] = await db3.select().from(properties).where(eq9(properties.id, input.id)).limit(1);
    if (!property) {
      throw new Error("Property not found");
    }
    const isOwner = property.ownerId === ctx.user.id;
    let isAgent = false;
    if (property.agentId) {
      const [agentRecord] = await db3.select().from(agents).where(and9(eq9(agents.id, property.agentId), eq9(agents.userId, ctx.user.id))).limit(1);
      isAgent = !!agentRecord;
    }
    if (!isOwner && !isAgent) {
      throw new Error("Not authorized to archive this property");
    }
    await db3.update(properties).set({ status: "archived" }).where(eq9(properties.id, input.id));
    return { success: true };
  }),
  /**
   * Delete property
   */
  deleteProperty: agentProcedure.input(z6.object({ id: z6.number() })).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [property] = await db3.select().from(properties).where(eq9(properties.id, input.id)).limit(1);
    if (!property) {
      throw new Error("Property not found");
    }
    const isOwner = property.ownerId === ctx.user.id;
    let isAgent = false;
    if (property.agentId) {
      const [agentRecord] = await db3.select().from(agents).where(and9(eq9(agents.id, property.agentId), eq9(agents.userId, ctx.user.id))).limit(1);
      isAgent = !!agentRecord;
    }
    if (!isOwner && !isAgent) {
      throw new Error("Not authorized to delete this property");
    }
    await db3.delete(properties).where(eq9(properties.id, input.id));
    return { success: true };
  }),
  /**
   * Create agent profile
   */
  createProfile: agentProcedure.input(
    z6.object({
      displayName: z6.string().min(2).max(100),
      phone: z6.string().min(10).max(20),
      bio: z6.string().max(1e3).optional(),
      profilePhoto: z6.string().optional(),
      licenseNumber: z6.string().optional(),
      specializations: z6.array(z6.string()).optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [existing] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (existing) {
      throw new Error("Agent profile already exists");
    }
    const agentId = await db3.createAgentProfile({
      userId: ctx.user.id,
      displayName: input.displayName,
      phone: input.phone,
      bio: input.bio,
      profilePhoto: input.profilePhoto,
      licenseNumber: input.licenseNumber,
      specializations: input.specializations
    });
    return { success: true, agentId };
  }),
  /**
   * Get agent's leads with filtering
   */
  getMyLeads: agentProcedure.input(
    z6.object({
      status: z6.enum([
        "all",
        "new",
        "contacted",
        "qualified",
        "converted",
        "closed",
        "viewing_scheduled",
        "offer_sent",
        "lost"
      ]).optional(),
      limit: z6.number().optional().default(100)
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const conditions = [eq9(leads.agentId, agentRecord.id)];
    if (input.status && input.status !== "all") {
      conditions.push(eq9(leads.status, input.status));
    }
    const leadsList = await db3.select({
      lead: leads,
      property: properties
    }).from(leads).leftJoin(properties, eq9(leads.propertyId, properties.id)).where(and9(...conditions)).orderBy(desc7(leads.createdAt)).limit(input.limit);
    return leadsList.map(({ lead, property }) => ({
      ...lead,
      property: property ? {
        id: property.id,
        title: property.title,
        city: property.city,
        price: Number(property.price)
      } : null
    }));
  }),
  /**
   * Update lead status
   */
  updateLeadStatus: agentProcedure.input(
    z6.object({
      leadId: z6.number(),
      status: z6.enum([
        "new",
        "contacted",
        "qualified",
        "converted",
        "closed",
        "viewing_scheduled",
        "offer_sent",
        "lost"
      ]),
      notes: z6.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const [lead] = await db3.select().from(leads).where(eq9(leads.id, input.leadId)).limit(1);
    if (!lead || lead.agentId !== agentRecord.id) {
      throw new Error("Lead not found or unauthorized");
    }
    await db3.update(leads).set({
      status: input.status,
      updatedAt: nowAsDbTimestamp()
    }).where(eq9(leads.id, input.leadId));
    await db3.insert(leadActivities).values({
      leadId: input.leadId,
      agentId: agentRecord.id,
      activityType: "status_change",
      description: input.notes || `Status changed to ${input.status}`
    });
    return { success: true };
  }),
  /**
   * Add lead activity/note
   */
  addLeadActivity: agentProcedure.input(
    z6.object({
      leadId: z6.number(),
      activityType: z6.enum([
        "call",
        "email",
        "meeting",
        "note",
        "status_change",
        "viewing_scheduled",
        "offer_sent"
      ]),
      description: z6.string(),
      metadata: z6.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const [lead] = await db3.select().from(leads).where(eq9(leads.id, input.leadId)).limit(1);
    if (!lead || lead.agentId !== agentRecord.id) {
      throw new Error("Lead not found or unauthorized");
    }
    await db3.insert(leadActivities).values({
      leadId: input.leadId,
      agentId: agentRecord.id,
      activityType: input.activityType,
      description: input.description,
      metadata: input.metadata
    });
    await db3.update(leads).set({ updatedAt: nowAsDbTimestamp() }).where(eq9(leads.id, input.leadId));
    return { success: true };
  }),
  /**
   * Get lead activities
   */
  getLeadActivities: agentProcedure.input(
    z6.object({
      leadId: z6.number()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const activities2 = await db3.select().from(leadActivities).where(eq9(leadActivities.leadId, input.leadId)).orderBy(desc7(leadActivities.createdAt));
    return activities2;
  }),
  /**
   * Get agent's showings/calendar
   */
  getMyShowings: agentProcedure.input(
    z6.object({
      startDate: z6.string().optional(),
      endDate: z6.string().optional(),
      status: z6.enum(["all", "requested", "confirmed", "completed", "cancelled"]).optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const conditions = [eq9(showings.agentId, agentRecord.id)];
    if (input.startDate) {
      conditions.push(gte3(showings.scheduledAt, new Date(input.startDate).toISOString()));
    }
    if (input.endDate) {
      conditions.push(lte3(showings.scheduledAt, new Date(input.endDate).toISOString()));
    }
    if (input.status && input.status !== "all") {
      conditions.push(eq9(showings.status, input.status));
    }
    const showingsList = await db3.select({
      showing: showings,
      property: properties,
      lead: leads
    }).from(showings).leftJoin(properties, eq9(showings.propertyId, properties.id)).leftJoin(leads, eq9(showings.leadId, leads.id)).where(and9(...conditions)).orderBy(showings.scheduledAt);
    return showingsList.map(
      ({ showing, property, lead }) => ({
        ...showing,
        property: property ? {
          id: property.id,
          title: property.title,
          address: property.address,
          city: property.city
        } : null,
        client: lead ? {
          name: lead.name,
          email: lead.email,
          phone: lead.phone
        } : null
      })
    );
  }),
  /**
   * Update showing status
   */
  updateShowingStatus: agentProcedure.input(
    z6.object({
      showingId: z6.number(),
      status: z6.enum(["requested", "confirmed", "completed", "cancelled"]),
      notes: z6.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    await db3.update(showings).set({
      status: input.status,
      notes: input.notes || showings.notes,
      updatedAt: nowAsDbTimestamp()
    }).where(and9(eq9(showings.id, input.showingId), eq9(showings.agentId, agentRecord.id)));
    return { success: true };
  }),
  /**
   * Get agent's commissions
   */
  getMyCommissions: agentProcedure.input(
    z6.object({
      status: z6.enum(["all", "pending", "approved", "paid", "cancelled"]).optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const conditions = [eq9(commissions.agentId, agentRecord.id)];
    if (input.status && input.status !== "all") {
      conditions.push(eq9(commissions.status, input.status));
    }
    const commissionsList = await db3.select({
      commission: commissions,
      property: properties,
      lead: leads
    }).from(commissions).leftJoin(properties, eq9(commissions.propertyId, properties.id)).leftJoin(leads, eq9(commissions.leadId, leads.id)).where(and9(...conditions)).orderBy(desc7(commissions.createdAt));
    return commissionsList.map(
      ({ commission, property, lead }) => ({
        ...commission,
        property: property ? {
          id: property.id,
          title: property.title
        } : null,
        client: lead ? {
          name: lead.name
        } : null
      })
    );
  }),
  /**
   * Get performance analytics
   */
  getPerformanceAnalytics: agentProcedure.input(
    z6.object({
      period: z6.enum(["week", "month", "quarter", "year"]).optional().default("month")
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const now = /* @__PURE__ */ new Date();
    const periodDays = {
      week: 7,
      month: 30,
      quarter: 90,
      year: 365
    }[input.period];
    const startDate = new Date(now.getTime() - periodDays * 24 * 60 * 60 * 1e3).toISOString();
    const [leadsContactedResult] = await db3.select({ count: count2() }).from(leads).where(and9(eq9(leads.agentId, agentRecord.id), gte3(leads.createdAt, startDate)));
    const [propertiesClosedResult] = await db3.select({ count: count2() }).from(properties).where(
      and9(
        eq9(properties.agentId, agentRecord.id),
        sql8`${properties.status} IN ('sold', 'rented')`,
        gte3(properties.updatedAt, startDate)
      )
    );
    const [totalLeadsResult] = await db3.select({ count: count2() }).from(leads).where(and9(eq9(leads.agentId, agentRecord.id), gte3(leads.createdAt, startDate)));
    const [convertedLeadsResult] = await db3.select({ count: count2() }).from(leads).where(
      and9(
        eq9(leads.agentId, agentRecord.id),
        eq9(leads.status, "converted"),
        gte3(leads.createdAt, startDate)
      )
    );
    const totalLeads = totalLeadsResult?.count || 0;
    const convertedLeads = convertedLeadsResult?.count || 0;
    const conversionRate = totalLeads > 0 ? convertedLeads / totalLeads * 100 : 0;
    return {
      leadsContacted: leadsContactedResult?.count || 0,
      propertiesClosed: propertiesClosedResult?.count || 0,
      conversionRate: Math.round(conversionRate * 10) / 10,
      totalLeads,
      convertedLeads
    };
  }),
  /**
   * Get notifications for the current agent
   */
  getNotifications: agentProcedure.input(
    z6.object({
      limit: z6.number().optional().default(50),
      offset: z6.number().optional().default(0),
      unreadOnly: z6.boolean().optional().default(false)
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const conditions = [eq9(notifications.userId, ctx.user.id)];
    if (input.unreadOnly) {
      conditions.push(eq9(notifications.isRead, 0));
    }
    const notificationsList = await db3.select().from(notifications).where(and9(...conditions)).orderBy(desc7(notifications.createdAt)).limit(input.limit).offset(input.offset);
    return notificationsList;
  }),
  /**
   * Mark notification as read
   */
  markNotificationAsRead: agentProcedure.input(z6.object({ notificationId: z6.number() })).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    await db3.update(notifications).set({ isRead: 1, readAt: /* @__PURE__ */ new Date() }).where(
      and9(eq9(notifications.id, input.notificationId), eq9(notifications.userId, ctx.user.id))
    );
    return { success: true };
  }),
  /**
   * Mark all notifications as read
   */
  markAllNotificationsAsRead: agentProcedure.mutation(async ({ ctx }) => {
    const db3 = await getDb();
    await db3.update(notifications).set({ isRead: 1, readAt: /* @__PURE__ */ new Date() }).where(eq9(notifications.userId, ctx.user.id));
    return { success: true };
  }),
  /**
   * Get unread notifications count
   */
  getUnreadNotificationCount: agentProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    const [result] = await db3.select({ count: count2() }).from(notifications).where(and9(eq9(notifications.userId, ctx.user.id), eq9(notifications.isRead, 0)));
    return { count: result?.count || 0 };
  }),
  /**
   * Export commissions to CSV
   */
  exportCommissionsCSV: agentProcedure.input(
    z6.object({
      status: z6.enum(["all", "pending", "approved", "paid", "cancelled"]).optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const conditions = [eq9(commissions.agentId, agentRecord.id)];
    if (input.status && input.status !== "all") {
      conditions.push(eq9(commissions.status, input.status));
    }
    const commissionsList = await db3.select({
      commission: commissions,
      property: properties,
      lead: leads
    }).from(commissions).leftJoin(properties, eq9(commissions.propertyId, properties.id)).leftJoin(leads, eq9(commissions.leadId, leads.id)).where(and9(...conditions)).orderBy(desc7(commissions.createdAt));
    const csvHeaders = [
      "Property",
      "Client",
      "Sale Price",
      "Commission %",
      "Amount",
      "Status",
      "Transaction Type",
      "Created Date",
      "Payout Date"
    ];
    const csvRows = commissionsList.map(({ commission, property, lead }) => [
      property?.title || "N/A",
      lead?.name || "N/A",
      commission.amount ? `R${(commission.amount / 100).toFixed(2)}` : "N/A",
      commission.percentage ? `${(commission.percentage / 100).toFixed(2)}%` : "N/A",
      commission.amount ? `R${(commission.amount / 100).toFixed(2)}` : "N/A",
      commission.status,
      commission.transactionType,
      new Date(commission.createdAt).toLocaleDateString(),
      commission.payoutDate ? new Date(commission.payoutDate).toLocaleDateString() : "N/A"
    ]);
    const csvContent = [csvHeaders, ...csvRows].map((row) => row.map((cell) => `"${cell}"`).join(",")).join("\n");
    return {
      filename: `commissions-${input.status || "all"}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`,
      content: csvContent
    };
  }),
  /**
   * Quick update property
   */
  quickUpdateProperty: agentProcedure.input(
    z6.object({
      propertyId: z6.number(),
      updates: z6.object({
        price: z6.number().optional(),
        status: z6.enum(["available", "sold", "rented", "pending", "draft", "published", "archived"]).optional(),
        featured: z6.boolean().optional()
      })
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [agentRecord] = await db3.select().from(agents).where(eq9(agents.userId, ctx.user.id)).limit(1);
    if (!agentRecord) {
      throw new Error("Agent profile not found");
    }
    const [property] = await db3.select().from(properties).where(and9(eq9(properties.id, input.propertyId), eq9(properties.agentId, agentRecord.id))).limit(1);
    if (!property) {
      throw new Error("Property not found or unauthorized");
    }
    const updateData = { ...input.updates, updatedAt: nowAsDbTimestamp() };
    if (input.updates.featured !== void 0) {
      updateData.featured = input.updates.featured ? 1 : 0;
    }
    await db3.update(properties).set(updateData).where(eq9(properties.id, input.propertyId));
    return { success: true };
  })
});

// server/routers/aiAgentRouter.ts
import { z as z7 } from "zod";

// server/services/agentService.ts
init_db_connection();
init_schema();
import { eq as eq10, desc as desc8, and as and10, like as like6, or as or8, sql as sql9 } from "drizzle-orm";
async function storeConversation(data) {
  try {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const result = await db3.insert(agentMemory).values(data);
    return Number(result[0].insertId);
  } catch (error) {
    console.error("[agentService] Failed to store conversation:", error);
    throw new Error("Failed to store conversation in database");
  }
}
async function getConversationHistory(sessionId, limit = 50) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(agentMemory).where(eq10(agentMemory.sessionId, sessionId)).orderBy(desc8(agentMemory.createdAt)).limit(limit);
}
async function getConversationsByUser(userId, limit = 20) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(agentMemory).where(eq10(agentMemory.userId, userId)).orderBy(desc8(agentMemory.createdAt)).limit(limit);
}
async function createTask(data) {
  try {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const result = await db3.insert(agentTasks).values({
      ...data,
      status: "pending"
    });
    return Number(result[0].insertId);
  } catch (error) {
    console.error("[agentService] Failed to create task:", error);
    throw new Error("Failed to create task in database");
  }
}
async function updateTaskStatus(taskId, status, outputData, errorMessage) {
  try {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const updates = {
      status,
      updatedAt: sql9`CURRENT_TIMESTAMP`
    };
    if (status === "running" && !outputData) {
      updates.startedAt = /* @__PURE__ */ new Date();
    }
    if (status === "completed" || status === "failed") {
      updates.completedAt = /* @__PURE__ */ new Date();
    }
    if (outputData !== void 0) {
      updates.outputData = outputData;
    }
    if (errorMessage) {
      updates.errorMessage = errorMessage;
    }
    await db3.update(agentTasks).set(updates).where(eq10(agentTasks.taskId, taskId));
  } catch (error) {
    console.error("[agentService] Failed to update task status:", error);
    throw new Error("Failed to update task status in database");
  }
}
async function getTaskById(taskId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.select().from(agentTasks).where(eq10(agentTasks.taskId, taskId)).limit(1);
  return result[0];
}
async function getTasksBySession(sessionId, limit = 50) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(agentTasks).where(eq10(agentTasks.sessionId, sessionId)).orderBy(desc8(agentTasks.createdAt)).limit(limit);
}
async function getTasksByUser(userId, limit = 50) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(agentTasks).where(eq10(agentTasks.userId, userId)).orderBy(desc8(agentTasks.createdAt)).limit(limit);
}
async function addKnowledge(data) {
  try {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const result = await db3.insert(agentKnowledge).values(data);
    return Number(result[0].insertId);
  } catch (error) {
    console.error("[agentService] Failed to add knowledge:", error);
    throw new Error("Failed to add knowledge to database");
  }
}
async function updateKnowledge(id, updates) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(agentKnowledge).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq10(agentKnowledge.id, id));
}
async function searchKnowledge(query, limit = 10) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(agentKnowledge).where(
    and10(
      eq10(agentKnowledge.isActive, 1),
      or8(
        like6(agentKnowledge.topic, `%${query}%`),
        like6(agentKnowledge.content, `%${query}%`),
        like6(agentKnowledge.category, `%${query}%`)
      )
    )
  ).limit(limit);
}
async function getKnowledgeByCategory(category, limit = 20) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  return await db3.select().from(agentKnowledge).where(and10(eq10(agentKnowledge.isActive, 1), eq10(agentKnowledge.category, category))).orderBy(desc8(agentKnowledge.createdAt)).limit(limit);
}
async function getKnowledgeById(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const result = await db3.select().from(agentKnowledge).where(eq10(agentKnowledge.id, id)).limit(1);
  return result[0];
}
async function deactivateKnowledge(id) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  await db3.update(agentKnowledge).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq10(agentKnowledge.id, id));
}

// server/routers/aiAgentRouter.ts
var aiAgentRouter = router({
  // ==================== MEMORY ENDPOINTS ====================
  storeConversation: protectedProcedure.input(
    z7.object({
      sessionId: z7.string(),
      conversationId: z7.string().optional(),
      userInput: z7.string(),
      agentResponse: z7.string(),
      metadata: z7.object({
        model: z7.string().optional(),
        tokens: z7.number().optional(),
        duration: z7.number().optional(),
        context: z7.any().optional()
      }).optional()
    })
  ).mutation(async ({ input, ctx }) => {
    const id = await storeConversation({
      ...input,
      userId: ctx.user.id
    });
    return { id, success: true };
  }),
  getHistory: protectedProcedure.input(
    z7.object({
      sessionId: z7.string(),
      limit: z7.number().min(1).max(100).default(50)
    })
  ).query(async ({ input }) => {
    return await getConversationHistory(input.sessionId, input.limit);
  }),
  getMyConversations: protectedProcedure.input(
    z7.object({
      limit: z7.number().min(1).max(100).default(20)
    })
  ).query(async ({ input, ctx }) => {
    return await getConversationsByUser(ctx.user.id, input.limit);
  }),
  // ==================== TASK ENDPOINTS ====================
  createTask: protectedProcedure.input(
    z7.object({
      taskId: z7.string(),
      sessionId: z7.string().optional(),
      taskType: z7.string(),
      inputData: z7.any().optional(),
      priority: z7.number().default(0)
    })
  ).mutation(async ({ input, ctx }) => {
    const id = await createTask({
      ...input,
      userId: ctx.user.id
    });
    return { id, success: true };
  }),
  updateTask: protectedProcedure.input(
    z7.object({
      taskId: z7.string(),
      status: z7.enum(["pending", "running", "completed", "failed"]),
      outputData: z7.any().optional(),
      errorMessage: z7.string().optional()
    })
  ).mutation(async ({ input }) => {
    await updateTaskStatus(
      input.taskId,
      input.status,
      input.outputData,
      input.errorMessage
    );
    return { success: true };
  }),
  getTask: protectedProcedure.input(z7.object({ taskId: z7.string() })).query(async ({ input }) => {
    return await getTaskById(input.taskId);
  }),
  getSessionTasks: protectedProcedure.input(
    z7.object({
      sessionId: z7.string(),
      limit: z7.number().min(1).max(100).default(50)
    })
  ).query(async ({ input }) => {
    return await getTasksBySession(input.sessionId, input.limit);
  }),
  getMyTasks: protectedProcedure.input(
    z7.object({
      limit: z7.number().min(1).max(100).default(50)
    })
  ).query(async ({ input, ctx }) => {
    return await getTasksByUser(ctx.user.id, input.limit);
  }),
  // ==================== KNOWLEDGE BASE ENDPOINTS ====================
  addKnowledge: protectedProcedure.input(
    z7.object({
      topic: z7.string(),
      content: z7.string(),
      category: z7.string().optional(),
      tags: z7.array(z7.string()).optional(),
      metadata: z7.object({
        source: z7.string().optional(),
        author: z7.string().optional(),
        confidence: z7.number().optional(),
        lastVerified: z7.string().optional()
      }).optional()
    })
  ).mutation(async ({ input, ctx }) => {
    const id = await addKnowledge({
      ...input,
      createdBy: ctx.user.id
    });
    return { id, success: true };
  }),
  updateKnowledge: protectedProcedure.input(
    z7.object({
      id: z7.number(),
      topic: z7.string().optional(),
      content: z7.string().optional(),
      category: z7.string().optional(),
      tags: z7.array(z7.string()).optional(),
      metadata: z7.any().optional(),
      isActive: z7.number().optional()
    })
  ).mutation(async ({ input }) => {
    const { id, ...updates } = input;
    await updateKnowledge(id, updates);
    return { success: true };
  }),
  searchKnowledge: publicProcedure.input(
    z7.object({
      query: z7.string(),
      limit: z7.number().min(1).max(50).default(10)
    })
  ).query(async ({ input }) => {
    return await searchKnowledge(input.query, input.limit);
  }),
  getKnowledgeByCategory: publicProcedure.input(
    z7.object({
      category: z7.string(),
      limit: z7.number().min(1).max(50).default(20)
    })
  ).query(async ({ input }) => {
    return await getKnowledgeByCategory(input.category, input.limit);
  }),
  getKnowledge: publicProcedure.input(z7.object({ id: z7.number() })).query(async ({ input }) => {
    return await getKnowledgeById(input.id);
  }),
  deactivateKnowledge: protectedProcedure.input(z7.object({ id: z7.number() })).mutation(async ({ input }) => {
    await deactivateKnowledge(input.id);
    return { success: true };
  })
});

// server/videoRouter.ts
init_schema();
import { z as z8 } from "zod";
import { eq as eq11, and as and11, desc as desc9, sql as sql10 } from "drizzle-orm";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
var s3 = new S3Client({
  region: process.env.AWS_REGION || "eu-north-1",
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || "",
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || ""
  }
});
var videoRouter = router({
  // Generate presigned URL for S3 upload
  getPresignedUrl: protectedProcedure.input(
    z8.object({
      fileName: z8.string(),
      fileType: z8.string()
    })
  ).mutation(async ({ input }) => {
    if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
      console.error("AWS credentials not configured");
      throw new Error("Video upload is not configured. Please contact support.");
    }
    const bucketName = process.env.AWS_S3_BUCKET || "listify-properties-sa";
    const region = process.env.AWS_REGION || "eu-north-1";
    const timestamp2 = Date.now();
    const sanitizedFileName = input.fileName.replace(/[^a-zA-Z0-9.-]/g, "_");
    const key = `videos/${timestamp2}-${sanitizedFileName}`;
    try {
      const command = new PutObjectCommand({
        Bucket: bucketName,
        Key: key,
        ContentType: input.fileType,
        ChecksumAlgorithm: void 0
        // Explicitly disable checksum to prevent CORS/Signature issues
      });
      const presignedUrl = await getSignedUrl(s3, command, { expiresIn: 3600 });
      console.log(`Generated presigned URL for: ${key}`);
      return {
        uploadUrl: presignedUrl,
        videoUrl: `https://${bucketName}.s3.${region}.amazonaws.com/${key}`
      };
    } catch (error) {
      console.error("Failed to generate presigned URL:", error);
      throw new Error(`Failed to generate upload URL: ${error.message}`);
    }
  }),
  // Upload video with S3 presigned URL
  uploadVideo: protectedProcedure.input(
    z8.object({
      propertyId: z8.number().optional(),
      developmentId: z8.number().optional(),
      videoUrl: z8.string(),
      caption: z8.string().optional(),
      type: z8.enum(["listing", "content"]),
      duration: z8.number().max(60).default(0)
      // Max 60 seconds
    })
  ).mutation(async ({ ctx, input }) => {
    if (ctx.user.role !== "agent" && ctx.user.role !== "agency_admin" && ctx.user.role !== "super_admin") {
      throw new Error("Only agents can upload videos");
    }
    const agent = await ctx.db.select().from(agents).where(eq11(agents.userId, ctx.user.id)).limit(1);
    if (!agent[0]) {
      throw new Error("Agent profile not found");
    }
    if (input.type === "listing" && !input.propertyId && !input.developmentId) {
      throw new Error("Listing videos must be linked to a property or development");
    }
    const [newVideo] = await ctx.db.insert(videos).values({
      agentId: agent[0].id,
      propertyId: input.propertyId,
      developmentId: input.developmentId,
      videoUrl: input.videoUrl,
      caption: input.caption,
      type: input.type,
      duration: input.duration
    });
    return { ...input, id: newVideo.insertId, agentId: agent[0].id, views: 0, likes: 0, shares: 0, createdAt: /* @__PURE__ */ new Date() };
  }),
  // Get all videos for the explore feed
  getVideos: publicProcedure.query(async ({ ctx }) => {
    const videosWithData = await ctx.db.select({
      id: videos.id,
      videoUrl: videos.videoUrl,
      caption: videos.caption,
      type: videos.type,
      duration: videos.duration,
      views: videos.views,
      likes: videos.likes,
      shares: videos.shares,
      createdAt: videos.createdAt,
      // Property data for listing videos
      propertyId: properties.id,
      propertyTitle: properties.title,
      propertyLocation: properties.address,
      propertyPrice: properties.price,
      // Development data
      developmentId: developments.id,
      developmentName: developments.name,
      // Agent data
      agentId: agents.id,
      agentName: agents.displayName,
      agentFirstName: agents.firstName,
      agentLastName: agents.lastName,
      agentEmail: agents.email,
      // User like status (for authenticated users)
      userLiked: videoLikes.id
    }).from(videos).leftJoin(properties, eq11(videos.propertyId, properties.id)).leftJoin(agents, eq11(videos.agentId, agents.id)).leftJoin(developments, eq11(videos.developmentId, developments.id)).leftJoin(
      videoLikes,
      and11(
        eq11(videoLikes.videoId, videos.id),
        ctx.user?.id ? eq11(videoLikes.userId, ctx.user.id) : sql10`1=0`
        // Always false if no user
      )
    ).where(eq11(videos.isPublished, 1)).orderBy(desc9(videos.createdAt)).limit(50);
    return videosWithData.map((video) => ({
      ...video,
      isLiked: !!video.userLiked,
      userLiked: void 0
      // Remove internal field
    }));
  }),
  // Get videos by type (listing or content)
  getVideosByType: publicProcedure.input(
    z8.object({
      type: z8.enum(["listing", "content"]).optional(),
      limit: z8.number().default(20)
    })
  ).query(async ({ ctx, input }) => {
    const whereCondition = input.type ? and11(eq11(videos.isPublished, 1), eq11(videos.type, input.type)) : eq11(videos.isPublished, 1);
    const videosWithData = await ctx.db.select({
      id: videos.id,
      videoUrl: videos.videoUrl,
      caption: videos.caption,
      type: videos.type,
      duration: videos.duration,
      views: videos.views,
      likes: videos.likes,
      shares: videos.shares,
      createdAt: videos.createdAt,
      propertyId: properties.id,
      propertyTitle: properties.title,
      propertyLocation: properties.address,
      propertyPrice: properties.price,
      developmentId: developments.id,
      developmentName: developments.name,
      agentId: agents.id,
      agentName: agents.displayName,
      agentFirstName: agents.firstName,
      agentLastName: agents.lastName,
      agentEmail: agents.email,
      userLiked: videoLikes.id
    }).from(videos).leftJoin(properties, eq11(videos.propertyId, properties.id)).leftJoin(agents, eq11(videos.agentId, agents.id)).leftJoin(developments, eq11(videos.developmentId, developments.id)).leftJoin(
      videoLikes,
      and11(
        eq11(videoLikes.videoId, videos.id),
        ctx.user?.id ? eq11(videoLikes.userId, ctx.user.id) : sql10`1=0`
      )
    ).where(whereCondition).orderBy(desc9(videos.createdAt)).limit(input.limit);
    return videosWithData.map((video) => ({
      ...video,
      isLiked: !!video.userLiked,
      userLiked: void 0
    }));
  }),
  // Toggle like/unlike on a video
  toggleLike: protectedProcedure.input(z8.object({ videoId: z8.number() })).mutation(async ({ ctx, input }) => {
    const existingLike = await ctx.db.select().from(videoLikes).where(and11(eq11(videoLikes.videoId, input.videoId), eq11(videoLikes.userId, ctx.user.id))).limit(1);
    if (existingLike[0]) {
      await ctx.db.delete(videoLikes).where(eq11(videoLikes.id, existingLike[0].id));
      await ctx.db.update(videos).set({ likes: sql10`likes - 1` }).where(eq11(videos.id, input.videoId));
      return { liked: false };
    } else {
      await ctx.db.insert(videoLikes).values({
        videoId: input.videoId,
        userId: ctx.user.id
      });
      await ctx.db.update(videos).set({ likes: sql10`likes + 1` }).where(eq11(videos.id, input.videoId));
      return { liked: true };
    }
  }),
  // Increment view count
  incrementViews: publicProcedure.input(z8.object({ videoId: z8.number() })).mutation(async ({ ctx, input }) => {
    await ctx.db.update(videos).set({ views: sql10`views + 1` }).where(eq11(videos.id, input.videoId));
    return { success: true };
  }),
  // Contact agent through video
  contactAgent: publicProcedure.input(
    z8.object({
      agentId: z8.number(),
      videoId: z8.number().optional(),
      propertyId: z8.number().optional(),
      name: z8.string(),
      email: z8.string().email(),
      phone: z8.string().optional(),
      message: z8.string()
    })
  ).mutation(async ({ ctx, input }) => {
    const agent = await ctx.db.select().from(agents).where(eq11(agents.id, input.agentId)).limit(1);
    if (!agent[0]) {
      throw new Error("Agent not found");
    }
    const leadData = {
      name: input.name,
      email: input.email,
      phone: input.phone,
      message: input.message,
      leadType: "inquiry",
      status: "new",
      source: input.videoId ? "explore_video" : "direct_contact",
      agentId: input.agentId,
      propertyId: input.propertyId
    };
    const [newLead] = await ctx.db.insert(leads).values(leadData);
    console.log(`Contact request from ${input.name} to agent ${agent[0].displayName}`);
    return {
      success: true,
      leadId: newLead[0].id,
      message: "Your inquiry has been sent to the agent"
    };
  }),
  // Get agent's videos
  getAgentVideos: protectedProcedure.input(
    z8.object({
      agentId: z8.number().optional(),
      limit: z8.number().default(20)
    })
  ).query(async ({ ctx, input }) => {
    let targetAgentId = input.agentId;
    if (!targetAgentId) {
      const agent = await ctx.db.select().from(agents).where(eq11(agents.userId, ctx.user.id)).limit(1);
      if (!agent[0]) {
        throw new Error("Agent profile not found");
      }
      targetAgentId = agent[0].id;
    }
    const videosData = await ctx.db.select({
      id: videos.id,
      videoUrl: videos.videoUrl,
      caption: videos.caption,
      type: videos.type,
      duration: videos.duration,
      views: videos.views,
      likes: videos.likes,
      shares: videos.shares,
      isPublished: videos.isPublished,
      isFeatured: videos.isFeatured,
      createdAt: videos.createdAt,
      propertyTitle: properties.title,
      propertyLocation: properties.address,
      propertyPrice: properties.price,
      developmentName: developments.name,
      likesCount: sql10`COUNT(${videoLikes.id})`.as("likes_count")
    }).from(videos).leftJoin(properties, eq11(videos.propertyId, properties.id)).leftJoin(developments, eq11(videos.developmentId, developments.id)).leftJoin(videoLikes, eq11(videoLikes.videoId, videos.id)).where(eq11(videos.agentId, targetAgentId)).groupBy(videos.id, properties.id, developments.id).orderBy(desc9(videos.createdAt)).limit(input.limit);
    return videosData;
  }),
  // Delete video (agent can delete their own videos)
  deleteVideo: protectedProcedure.input(z8.object({ videoId: z8.number() })).mutation(async ({ ctx, input }) => {
    const video = await ctx.db.select().from(videos).where(eq11(videos.id, input.videoId)).limit(1);
    if (!video[0]) {
      throw new Error("Video not found");
    }
    const agent = await ctx.db.select().from(agents).where(eq11(agents.userId, ctx.user.id)).limit(1);
    if (!agent[0] || video[0].agentId !== agent[0].id) {
      throw new Error("Unauthorized to delete this video");
    }
    await ctx.db.delete(videos).where(eq11(videos.id, input.videoId));
    return { success: true };
  })
});

// server/billingRouter.ts
import { TRPCError as TRPCError4 } from "@trpc/server";
import { z as z9 } from "zod";
init_db();

// server/_core/stripe.ts
init_env();
import Stripe from "stripe";
var stripe = ENV.stripeSecretKey ? new Stripe(ENV.stripeSecretKey, {
  apiVersion: "2025-10-29.clover",
  typescript: true
}) : null;
function verifyStripeWebhook(rawBody, signature) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY in .env");
  }
  try {
    return stripe.webhooks.constructEvent(rawBody, signature, ENV.stripeWebhookSecret);
  } catch (error) {
    throw new Error(`Webhook signature verification failed: ${error}`);
  }
}

// server/billingRouter.ts
init_schema();
import { eq as eq12, and as and12, sql as sql11, or as or9, desc as desc10 } from "drizzle-orm";
var createCheckoutSessionSchema = z9.object({
  planId: z9.number(),
  successUrl: z9.string().url(),
  cancelUrl: z9.string().url()
});
var createSetupIntentSchema = z9.object({
  paymentMethodType: z9.enum(["card"]).default("card")
});
var billingRouter = {
  // Public endpoints
  plans: publicProcedure.query(async () => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    return await db3.select().from(plans).where(eq12(plans.isActive, 1)).orderBy(plans.sortOrder);
  }),
  createCheckoutSession: agencyAdminProcedure.input(createCheckoutSessionSchema).mutation(async ({ input, ctx }) => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    if (!stripe) {
      throw new TRPCError4({
        code: "SERVICE_UNAVAILABLE",
        message: "Payment system is not configured. Please contact support."
      });
    }
    try {
      const [plan] = await db3.select().from(plans).where(eq12(plans.id, input.planId)).limit(1);
      if (!plan) {
        throw new TRPCError4({ code: "NOT_FOUND", message: "Plan not found" });
      }
      if (!plan.stripePriceId) {
        throw new TRPCError4({
          code: "BAD_REQUEST",
          message: "Plan is not configured for Stripe billing"
        });
      }
      if (!ctx.user.agencyId) {
        throw new TRPCError4({ code: "FORBIDDEN", message: "User must belong to an agency" });
      }
      const [agency] = await db3.select().from(agencies).where(eq12(agencies.id, ctx.user.agencyId)).limit(1);
      if (!agency) {
        throw new TRPCError4({ code: "NOT_FOUND", message: "Agency not found" });
      }
      let customerId;
      const existingSubscription = await db3.select().from(agencySubscriptions).where(eq12(agencySubscriptions.agencyId, ctx.user.agencyId)).limit(1);
      if (existingSubscription.length > 0) {
        customerId = existingSubscription[0].stripeCustomerId;
      } else {
        const customer = await stripe.customers.create({
          email: agency.email,
          name: agency.name,
          metadata: {
            agencyId: ctx.user.agencyId.toString()
          }
        });
        customerId = customer.id;
        await db3.insert(agencySubscriptions).values({
          agencyId: ctx.user.agencyId,
          planId: input.planId,
          stripeCustomerId: customerId,
          stripePriceId: plan.stripePriceId,
          status: "incomplete"
        });
      }
      const session = await stripe.checkout.sessions.create({
        customer: customerId,
        payment_method_types: ["card"],
        line_items: [
          {
            price: plan.stripePriceId,
            quantity: 1
          }
        ],
        mode: "subscription",
        success_url: input.successUrl,
        cancel_url: input.cancelUrl,
        metadata: {
          agencyId: ctx.user.agencyId.toString(),
          planId: input.planId.toString()
        }
      });
      return { sessionId: session.id, url: session.url };
    } catch (error) {
      console.error("Error creating checkout session:", error);
      throw new TRPCError4({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to create checkout session"
      });
    }
  }),
  // Agency billing endpoints
  subscription: agencyAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    const [subscription] = await db3.select({
      id: agencySubscriptions.id,
      planId: agencySubscriptions.planId,
      status: agencySubscriptions.status,
      currentPeriodStart: agencySubscriptions.currentPeriodStart,
      currentPeriodEnd: agencySubscriptions.currentPeriodEnd,
      cancelAtPeriodEnd: agencySubscriptions.cancelAtPeriodEnd,
      stripeSubscriptionId: agencySubscriptions.stripeSubscriptionId,
      plan: plans
    }).from(agencySubscriptions).leftJoin(plans, eq12(agencySubscriptions.planId, plans.id)).where(eq12(agencySubscriptions.agencyId, ctx.user.agencyId)).limit(1);
    return subscription || null;
  }),
  paymentMethods: agencyAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    return await db3.select().from(paymentMethods).where(eq12(paymentMethods.agencyId, ctx.user.agencyId)).orderBy(paymentMethods.isDefault);
  }),
  createSetupIntent: agencyAdminProcedure.input(createSetupIntentSchema).mutation(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    try {
      const [subscription] = await db3.select().from(agencySubscriptions).where(eq12(agencySubscriptions.agencyId, ctx.user.agencyId)).limit(1);
      if (!subscription) {
        throw new TRPCError4({ code: "NOT_FOUND", message: "No subscription found for agency" });
      }
      const setupIntent = await stripe.setupIntents.create({
        customer: subscription.stripeCustomerId,
        payment_method_types: ["card"],
        metadata: {
          agencyId: ctx.user.agencyId.toString()
        }
      });
      return {
        clientSecret: setupIntent.client_secret,
        setupIntentId: setupIntent.id
      };
    } catch (error) {
      console.error("Error creating setup intent:", error);
      throw new TRPCError4({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to create payment method setup"
      });
    }
  }),
  invoices: agencyAdminProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    return await db3.select().from(invoices).where(eq12(invoices.agencyId, ctx.user.agencyId)).orderBy(invoices.createdAt);
  }),
  cancelSubscription: agencyAdminProcedure.mutation(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    try {
      const [subscription] = await db3.select().from(agencySubscriptions).where(eq12(agencySubscriptions.agencyId, ctx.user.agencyId)).limit(1);
      if (!subscription || !subscription.stripeSubscriptionId) {
        throw new TRPCError4({ code: "NOT_FOUND", message: "No active subscription found" });
      }
      await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
        cancel_at_period_end: true
      });
      await db3.update(agencySubscriptions).set({
        cancelAtPeriodEnd: 1,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(agencySubscriptions.id, subscription.id));
      return { success: true };
    } catch (error) {
      console.error("Error canceling subscription:", error);
      throw new TRPCError4({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to cancel subscription"
      });
    }
  }),
  reactivateSubscription: agencyAdminProcedure.mutation(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3)
      throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    try {
      const [subscription] = await db3.select().from(agencySubscriptions).where(eq12(agencySubscriptions.agencyId, ctx.user.agencyId)).limit(1);
      if (!subscription || !subscription.stripeSubscriptionId) {
        throw new TRPCError4({ code: "NOT_FOUND", message: "No subscription found" });
      }
      await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
        cancel_at_period_end: false
      });
      await db3.update(agencySubscriptions).set({
        cancelAtPeriodEnd: 0,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(agencySubscriptions.id, subscription.id));
      return { success: true };
    } catch (error) {
      console.error("Error reactivating subscription:", error);
      throw new TRPCError4({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to reactivate subscription"
      });
    }
  }),
  // Admin-only endpoints
  admin: {
    plans: superAdminProcedure.query(async () => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      return await db3.select().from(plans).orderBy(plans.sortOrder);
    }),
    updatePlan: superAdminProcedure.input(
      z9.object({
        id: z9.number(),
        updates: z9.object({
          name: z9.string().optional(),
          displayName: z9.string().optional(),
          price: z9.number().optional(),
          stripePriceId: z9.string().optional(),
          isActive: z9.number().optional(),
          isPopular: z9.number().optional()
        })
      })
    ).mutation(async ({ input }) => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      await db3.update(plans).set(input.updates).where(eq12(plans.id, input.id));
      return { success: true };
    }),
    billingOverview: superAdminProcedure.query(async () => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      const [totalRevenue] = await db3.select({ total: sql11`sum(${invoices.amount})` }).from(invoices).where(eq12(invoices.status, "paid"));
      const [monthlyRevenue] = await db3.select({ total: sql11`sum(${invoices.amount})` }).from(invoices).where(
        and12(
          eq12(invoices.status, "paid"),
          sql11`${invoices.createdAt} >= DATE_SUB(NOW(), INTERVAL 30 DAY)`
        )
      );
      const [activeSubscriptions] = await db3.select({ count: sql11`count(*)` }).from(agencySubscriptions).where(eq12(agencySubscriptions.status, "active"));
      const [totalSubscriptions] = await db3.select({ count: sql11`count(*)` }).from(agencySubscriptions);
      const [trialSubscriptions] = await db3.select({ count: sql11`count(*)` }).from(agencySubscriptions).where(eq12(agencySubscriptions.status, "trialing"));
      const [churnedSubscriptions] = await db3.select({ count: sql11`count(*)` }).from(agencySubscriptions).where(
        or9(eq12(agencySubscriptions.status, "canceled"), eq12(agencySubscriptions.status, "unpaid"))
      );
      const [totalAgencies] = await db3.select({ count: sql11`count(*)` }).from(agencies);
      const [paidAgencies] = await db3.select({ count: sql11`count(distinct ${agencies.id})` }).from(agencies).innerJoin(agencySubscriptions, eq12(agencies.id, agencySubscriptions.agencyId)).where(eq12(agencySubscriptions.status, "active"));
      const planDistribution = await db3.select({
        planName: plans.name,
        planDisplayName: plans.displayName,
        count: sql11`count(*)`
      }).from(agencySubscriptions).innerJoin(plans, eq12(agencySubscriptions.planId, plans.id)).where(eq12(agencySubscriptions.status, "active")).groupBy(plans.id, plans.name, plans.displayName);
      const recentTransactions = await db3.select({
        id: invoices.id,
        amount: invoices.amount,
        currency: invoices.currency,
        status: invoices.status,
        createdAt: invoices.createdAt,
        agencyName: agencies.name
      }).from(invoices).innerJoin(agencySubscriptions, eq12(invoices.subscriptionId, agencySubscriptions.id)).innerJoin(agencies, eq12(agencySubscriptions.agencyId, agencies.id)).where(sql11`${invoices.createdAt} >= DATE_SUB(NOW(), INTERVAL 30 DAY)`).orderBy(desc10(invoices.createdAt)).limit(10);
      const activeSubsWithPlans = await db3.select({
        amount: plans.price,
        interval: plans.interval
      }).from(agencySubscriptions).innerJoin(plans, eq12(agencySubscriptions.planId, plans.id)).where(eq12(agencySubscriptions.status, "active"));
      let mrr = 0;
      for (const sub of activeSubsWithPlans) {
        const monthlyAmount = sub.interval === "year" ? sub.amount / 12 : sub.amount;
        mrr += monthlyAmount;
      }
      return {
        revenue: {
          total: Number(totalRevenue?.total || 0) / 100,
          monthly: Number(monthlyRevenue?.total || 0) / 100,
          mrr: mrr / 100
        },
        subscriptions: {
          active: Number(activeSubscriptions?.count || 0),
          total: Number(totalSubscriptions?.count || 0),
          trial: Number(trialSubscriptions?.count || 0),
          churned: Number(churnedSubscriptions?.count || 0)
        },
        agencies: {
          total: Number(totalAgencies?.count || 0),
          paid: Number(paidAgencies?.count || 0),
          free: Number(totalAgencies?.count || 0) - Number(paidAgencies?.count || 0)
        },
        planDistribution: planDistribution.map((p) => ({
          name: p.planName,
          displayName: p.planDisplayName,
          count: Number(p.count)
        })),
        recentTransactions: recentTransactions.map((t2) => ({
          id: t2.id,
          amount: Number(t2.amount) / 100,
          currency: t2.currency,
          status: t2.status,
          createdAt: t2.createdAt,
          agencyName: t2.agencyName
        }))
      };
    }),
    // Coupon management
    coupons: superAdminProcedure.query(async () => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      return await db3.select().from(coupons).orderBy(coupons.createdAt);
    }),
    createCoupon: superAdminProcedure.input(
      z9.object({
        code: z9.string().min(3).max(20).toUpperCase(),
        name: z9.string().min(1),
        description: z9.string().optional(),
        discountType: z9.enum(["amount", "percent"]),
        discountAmount: z9.number().positive(),
        maxRedemptions: z9.number().int().positive().optional(),
        validFrom: z9.date().optional(),
        validUntil: z9.date().optional(),
        appliesToPlans: z9.array(z9.number()).optional()
      })
    ).mutation(async ({ input }) => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      const [existing] = await db3.select().from(coupons).where(eq12(coupons.code, input.code)).limit(1);
      if (existing) {
        throw new TRPCError4({ code: "CONFLICT", message: "Coupon code already exists" });
      }
      const couponData = {
        ...input,
        appliesToPlans: input.appliesToPlans ? JSON.stringify(input.appliesToPlans) : null
      };
      await db3.insert(coupons).values(couponData);
      return { success: true };
    }),
    updateCoupon: superAdminProcedure.input(
      z9.object({
        id: z9.number(),
        updates: z9.object({
          name: z9.string().optional(),
          description: z9.string().optional(),
          discountAmount: z9.number().optional(),
          maxRedemptions: z9.number().optional(),
          validFrom: z9.date().optional(),
          validUntil: z9.date().optional(),
          isActive: z9.number().optional()
        })
      })
    ).mutation(async ({ input }) => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      await db3.update(coupons).set(input.updates).where(eq12(coupons.id, input.id));
      return { success: true };
    }),
    deleteCoupon: superAdminProcedure.input(z9.object({ id: z9.number() })).mutation(async ({ input }) => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      await db3.delete(coupons).where(eq12(coupons.id, input.id));
      return { success: true };
    }),
    // Validate coupon for checkout
    validateCoupon: publicProcedure.input(
      z9.object({
        code: z9.string(),
        planId: z9.number()
      })
    ).query(async ({ input }) => {
      const db3 = await getDb();
      if (!db3)
        throw new TRPCError4({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
      const [coupon] = await db3.select().from(coupons).where(eq12(coupons.code, input.code.toUpperCase())).limit(1);
      if (!coupon || !coupon.isActive) {
        throw new TRPCError4({ code: "NOT_FOUND", message: "Invalid or expired coupon" });
      }
      const now = /* @__PURE__ */ new Date();
      if (coupon.validFrom && now < coupon.validFrom) {
        throw new TRPCError4({ code: "BAD_REQUEST", message: "Coupon not yet valid" });
      }
      if (coupon.validUntil && now > coupon.validUntil) {
        throw new TRPCError4({ code: "BAD_REQUEST", message: "Coupon has expired" });
      }
      if (coupon.maxRedemptions && coupon.redemptionsUsed >= coupon.maxRedemptions) {
        throw new TRPCError4({ code: "BAD_REQUEST", message: "Coupon usage limit exceeded" });
      }
      if (coupon.appliesToPlans) {
        const allowedPlans = JSON.parse(coupon.appliesToPlans);
        if (!allowedPlans.includes(input.planId)) {
          throw new TRPCError4({ code: "BAD_REQUEST", message: "Coupon not valid for this plan" });
        }
      }
      return {
        id: coupon.id,
        code: coupon.code,
        name: coupon.name,
        description: coupon.description,
        discountType: coupon.discountType,
        discountAmount: coupon.discountAmount
      };
    })
  }
};

// server/locationRouter.ts
init_db();
init_schema();
import { z as z10 } from "zod";
import { eq as eq13, and as and13, or as or10, like as like8, sql as sql13, count as count4 } from "drizzle-orm";
var locationRouter = router({
  /**
   * Search for locations (provinces, cities, suburbs, addresses)
   */
  searchLocations: publicProcedure.input(
    z10.object({
      query: z10.string().min(1).max(255),
      type: z10.enum(["province", "city", "suburb", "address", "all"]).default("all"),
      limit: z10.number().min(1).max(50).default(10)
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const searchQuery = `%${input.query.toLowerCase()}%`;
    const results = [];
    const cacheKey = `${input.query}_${input.type}_${input.limit}`;
    const [cached] = await db3.select().from(locationSearchCache).where(
      and13(
        eq13(locationSearchCache.searchQuery, cacheKey),
        eq13(locationSearchCache.searchType, input.type),
        sql13`${locationSearchCache.expiresAt} > NOW()`
      )
    ).limit(1);
    if (cached) {
      return JSON.parse(cached.resultsJSON);
    }
    if (input.type === "province" || input.type === "all") {
      const provinceResults = await db3.select({
        id: provinces.id,
        name: provinces.name,
        code: provinces.code,
        type: sql13`'province'`,
        latitude: provinces.latitude,
        longitude: provinces.longitude
      }).from(provinces).where(or10(like8(provinces.name, searchQuery), like8(provinces.code, searchQuery))).limit(input.type === "province" ? input.limit : Math.ceil(input.limit / 3));
      results.push(...provinceResults);
    }
    if (input.type === "city" || input.type === "all") {
      const cityResults = await db3.select({
        id: cities.id,
        name: cities.name,
        provinceName: provinces.name,
        provinceCode: provinces.code,
        type: sql13`'city'`,
        latitude: cities.latitude,
        longitude: cities.longitude,
        isMetro: cities.isMetro
      }).from(cities).leftJoin(provinces, eq13(cities.provinceId, provinces.id)).where(like8(cities.name, searchQuery)).limit(input.type === "city" ? input.limit : Math.ceil(input.limit / 3));
      results.push(...cityResults);
    }
    if (input.type === "suburb" || input.type === "all") {
      const suburbResults = await db3.select({
        id: suburbs.id,
        name: suburbs.name,
        cityName: cities.name,
        provinceName: provinces.name,
        provinceCode: provinces.code,
        type: sql13`'suburb'`,
        latitude: suburbs.latitude,
        longitude: suburbs.longitude,
        postalCode: suburbs.postalCode
      }).from(suburbs).leftJoin(cities, eq13(suburbs.cityId, cities.id)).leftJoin(provinces, eq13(cities.provinceId, provinces.id)).where(like8(suburbs.name, searchQuery)).limit(input.type === "suburb" ? input.limit : Math.ceil(input.limit / 3));
      results.push(...suburbResults);
    }
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setHours(expiresAt.getHours() + 1);
    await db3.insert(locationSearchCache).values({
      searchQuery: cacheKey,
      searchType: input.type,
      resultsJSON: JSON.stringify(results),
      expiresAt
    });
    return results;
  }),
  /**
   * Get featured listings for a location
   */
  getFeaturedListings: publicProcedure.input(
    z10.object({
      limit: z10.number().default(6),
      locationId: z10.number().optional(),
      locationType: z10.string().optional()
    })
  ).query(async ({ input }) => {
    const { getFeaturedListings: getFeaturedListings2 } = await Promise.resolve().then(() => (init_db(), db_exports));
    try {
      return await getFeaturedListings2(input.limit);
    } catch (error) {
      console.error("Error fetching featured listings:", error);
      return [];
    }
  }),
  /**
   * Get location hierarchy (provinces with their cities and suburbs)
   */
  getLocationHierarchy: publicProcedure.input(
    z10.object({
      provinceId: z10.number().optional(),
      cityId: z10.number().optional(),
      depth: z10.enum(["province", "city", "suburb", "full"]).default("full")
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    if (input.depth === "province") {
      const provincesList = await db3.select({
        id: provinces.id,
        name: provinces.name,
        code: provinces.code,
        latitude: provinces.latitude,
        longitude: provinces.longitude
      }).from(provinces).orderBy(provinces.name);
      return provincesList;
    }
    if (input.depth === "city" && input.provinceId) {
      const citiesList = await db3.select({
        id: cities.id,
        name: cities.name,
        provinceId: cities.provinceId,
        provinceName: provinces.name,
        latitude: cities.latitude,
        longitude: cities.longitude,
        isMetro: cities.isMetro
      }).from(cities).leftJoin(provinces, eq13(cities.provinceId, provinces.id)).where(eq13(cities.provinceId, input.provinceId)).orderBy(cities.name);
      return citiesList;
    }
    if (input.depth === "suburb" && input.cityId) {
      const suburbsList = await db3.select({
        id: suburbs.id,
        name: suburbs.name,
        cityId: suburbs.cityId,
        cityName: cities.name,
        provinceName: provinces.name,
        latitude: suburbs.latitude,
        longitude: suburbs.longitude,
        postalCode: suburbs.postalCode
      }).from(suburbs).leftJoin(cities, eq13(suburbs.cityId, cities.id)).leftJoin(provinces, eq13(cities.provinceId, provinces.id)).where(eq13(suburbs.cityId, input.cityId)).orderBy(suburbs.name);
      return suburbsList;
    }
    const hierarchy = await db3.select({
      province: {
        id: provinces.id,
        name: provinces.name,
        code: provinces.code,
        latitude: provinces.latitude,
        longitude: provinces.longitude
      },
      cities: sql13`JSON_ARRAYAGG(
            JSON_OBJECT(
              'id', ${cities.id},
              'name', ${cities.name},
              'latitude', ${cities.latitude},
              'longitude', ${cities.longitude},
              'isMetro', ${cities.isMetro},
              'suburbs', (
                SELECT JSON_ARRAYAGG(
                  JSON_OBJECT(
                    'id', ${suburbs.id},
                    'name', ${suburbs.name},
                    'latitude', ${suburbs.latitude},
                    'longitude', ${suburbs.longitude},
                    'postalCode', ${suburbs.postalCode}
                  )
                )
                FROM ${suburbs}
                WHERE ${suburbs.cityId} = ${cities.id}
              )
            )
          )`
    }).from(provinces).leftJoin(cities, eq13(cities.provinceId, provinces.id)).leftJoin(suburbs, eq13(suburbs.cityId, cities.id)).groupBy(
      provinces.id,
      provinces.name,
      provinces.code,
      provinces.latitude,
      provinces.longitude
    ).orderBy(provinces.name);
    return hierarchy;
  }),
  /**
   * Get nearby amenities
   */
  getNearbyAmenities: publicProcedure.input(
    z10.object({
      latitude: z10.number(),
      longitude: z10.number(),
      radius: z10.number(),
      types: z10.array(z10.string()),
      limit: z10.number().optional()
    })
  ).query(async ({ input }) => {
    const { googlePlacesService: googlePlacesService2 } = await Promise.resolve().then(() => (init_googlePlacesService(), googlePlacesService_exports));
    const { latitude, longitude, radius, types, limit } = input;
    try {
      const promises = types.map(
        (type) => googlePlacesService2.getNearbyPlaces(latitude, longitude, radius, type)
      );
      const results = await Promise.all(promises);
      const flattened = results.flat();
      const processed = flattened.map((place) => {
        const R = 6371;
        const dLat = (place.latitude - latitude) * Math.PI / 180;
        const dLon = (place.longitude - longitude) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(latitude * Math.PI / 180) * Math.cos(place.latitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const distance = Math.round(R * c * 10) / 10;
        return {
          ...place,
          distance: `${distance} km`,
          distanceValue: distance
        };
      });
      const unique2 = Array.from(new Map(processed.map((item) => [item.id, item])).values());
      return unique2.sort((a, b) => a.distanceValue - b.distanceValue).slice(0, limit || 20);
    } catch (error) {
      console.error("Error fetching nearby amenities:", error);
      return [];
    }
  }),
  /**
   * Get properties on map within bounds
   */
  getPropertiesOnMap: publicProcedure.input(
    z10.object({
      bounds: z10.object({
        north: z10.number(),
        south: z10.number(),
        east: z10.number(),
        west: z10.number()
      }),
      filters: z10.object({
        propertyType: z10.array(z10.string()).optional(),
        listingType: z10.array(z10.string()).optional(),
        minPrice: z10.number().optional(),
        maxPrice: z10.number().optional(),
        bedrooms: z10.number().optional(),
        bathrooms: z10.number().optional()
      }).optional(),
      limit: z10.number().min(1).max(1e3).default(100)
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const conditions = [
      sql13`${properties.latitude} BETWEEN ${input.bounds.south} AND ${input.bounds.north}`,
      sql13`${properties.longitude} BETWEEN ${input.bounds.west} AND ${input.bounds.east}`,
      eq13(properties.status, "published")
    ];
    if (input.filters?.propertyType?.length) {
      conditions.push(
        sql13`${properties.propertyType} IN (${input.filters.propertyType.map(() => "?").join(",")})`
      );
    }
    if (input.filters?.listingType?.length) {
      conditions.push(
        sql13`${properties.listingType} IN (${input.filters.listingType.map(() => "?").join(",")})`
      );
    }
    if (input.filters?.minPrice) {
      conditions.push(sql13`${properties.price} >= ${input.filters.minPrice}`);
    }
    if (input.filters?.maxPrice) {
      conditions.push(sql13`${properties.price} <= ${input.filters.maxPrice}`);
    }
    if (input.filters?.bedrooms) {
      conditions.push(eq13(properties.bedrooms, input.filters.bedrooms));
    }
    if (input.filters?.bathrooms) {
      conditions.push(eq13(properties.bathrooms, input.filters.bathrooms));
    }
    const propertiesList = await db3.select({
      id: properties.id,
      title: properties.title,
      price: properties.price,
      propertyType: properties.propertyType,
      listingType: properties.listingType,
      bedrooms: properties.bedrooms,
      bathrooms: properties.bathrooms,
      latitude: properties.latitude,
      longitude: properties.longitude,
      mainImage: properties.mainImage,
      city: properties.city,
      province: properties.province
    }).from(properties).where(and13(...conditions)).limit(input.limit);
    return propertiesList;
  }),
  /**
   * Reverse geocoding - get address from coordinates
   */
  reverseGeocode: publicProcedure.input(
    z10.object({
      latitude: z10.number().min(-90).max(90),
      longitude: z10.number().min(-180).max(180)
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const nearbyLocations = await db3.select({
      type: sql13`'province'`,
      id: provinces.id,
      name: provinces.name,
      code: provinces.code,
      distance: sql13`
            (
              6371 * acos(
                cos(radians(${input.latitude})) * 
                cos(radians(${provinces.latitude})) * 
                cos(radians(${provinces.longitude}) - radians(${input.longitude})) + 
                sin(radians(${input.latitude})) * 
                sin(radians(${provinces.latitude}))
              )
            )
          `
    }).from(provinces).where(and13(sql13`${provinces.latitude} IS NOT NULL`, sql13`${provinces.longitude} IS NOT NULL`)).limit(1).orderBy(sql13`distance`);
    const [nearestProvince] = nearbyLocations;
    let nearestCity = null;
    let nearestSuburb = null;
    if (nearestProvince) {
      const citiesNearby = await db3.select({
        id: cities.id,
        name: cities.name,
        distance: sql13`
              (
                6371 * acos(
                  cos(radians(${input.latitude})) * 
                  cos(radians(${cities.latitude})) * 
                  cos(radians(${cities.longitude}) - radians(${input.longitude})) + 
                  sin(radians(${input.latitude})) * 
                  sin(radians(${cities.latitude}))
                )
              )
            `
      }).from(cities).where(
        and13(
          eq13(cities.provinceId, nearestProvince.id),
          sql13`${cities.latitude} IS NOT NULL`,
          sql13`${cities.longitude} IS NOT NULL`
        )
      ).limit(1).orderBy(sql13`distance`);
      [nearestCity] = citiesNearby;
      if (nearestCity) {
        const suburbsNearby = await db3.select({
          id: suburbs.id,
          name: suburbs.name,
          postalCode: suburbs.postalCode,
          distance: sql13`
                (
                  6371 * acos(
                    cos(radians(${input.latitude})) * 
                    cos(radians(${suburbs.latitude})) * 
                    cos(radians(${suburbs.longitude}) - radians(${input.longitude})) + 
                    sin(radians(${input.latitude})) * 
                    sin(radians(${suburbs.latitude}))
                  )
                )
              `
        }).from(suburbs).where(
          and13(
            eq13(suburbs.cityId, nearestCity.id),
            sql13`${suburbs.latitude} IS NOT NULL`,
            sql13`${suburbs.longitude} IS NOT NULL`
          )
        ).limit(1).orderBy(sql13`distance`);
        [nearestSuburb] = suburbsNearby;
      }
    }
    return {
      coordinates: {
        latitude: input.latitude,
        longitude: input.longitude
      },
      province: nearestProvince,
      city: nearestCity,
      suburb: nearestSuburb,
      formattedAddress: [nearestSuburb?.name, nearestCity?.name, nearestProvince?.name].filter(Boolean).join(", ")
    };
  }),
  /**
   * Get agent coverage areas
   */
  getAgentCoverageAreas: agentProcedure.input(
    z10.object({
      agentId: z10.number().optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    let agentId = input.agentId;
    if (!agentId) {
      const { agents: agents2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const [agentRecord] = await db3.select().from(agents2).where(eq13(agents2.userId, ctx.user.id)).limit(1);
      if (!agentRecord) {
        throw new Error("Agent profile not found");
      }
      agentId = agentRecord.id;
    }
    const coverageAreas = await db3.select().from(agentCoverageAreas).where(eq13(agentCoverageAreas.agentId, agentId)).orderBy(agentCoverageAreas.areaName);
    return coverageAreas;
  }),
  /**
   * Calculate distance between two points
   */
  calculateDistance: publicProcedure.input(
    z10.object({
      from: z10.object({
        latitude: z10.number(),
        longitude: z10.number()
      }),
      to: z10.object({
        latitude: z10.number(),
        longitude: z10.number()
      }),
      unit: z10.enum(["km", "miles"]).default("km")
    })
  ).query(async ({ input }) => {
    const R = input.unit === "km" ? 6371 : 3959;
    const dLat = (input.to.latitude - input.from.latitude) * Math.PI / 180;
    const dLon = (input.to.longitude - input.from.longitude) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(input.from.latitude * Math.PI / 180) * Math.cos(input.to.latitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;
    return {
      distance: Math.round(distance * 100) / 100,
      // Round to 2 decimal places
      unit: input.unit
    };
  }),
  /**
   * Get property density heatmap data
   */
  getPropertyHeatmap: publicProcedure.input(
    z10.object({
      bounds: z10.object({
        north: z10.number(),
        south: z10.number(),
        east: z10.number(),
        west: z10.number()
      }),
      gridSize: z10.number().min(5).max(50).default(10)
      // Grid cells per axis
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const latStep = (input.bounds.north - input.bounds.south) / input.gridSize;
    const lngStep = (input.bounds.east - input.bounds.west) / input.gridSize;
    const heatmapData = [];
    for (let i = 0; i < input.gridSize; i++) {
      for (let j = 0; j < input.gridSize; j++) {
        const gridLat = input.bounds.south + i * latStep;
        const gridLng = input.bounds.west + j * lngStep;
        const [countResult] = await db3.select({ count: count4() }).from(properties).where(
          and13(
            sql13`${properties.latitude} BETWEEN ${gridLat} AND ${gridLat + latStep}`,
            sql13`${properties.longitude} BETWEEN ${gridLng} AND ${gridLng + lngStep}`,
            eq13(properties.status, "published")
          )
        );
        if (countResult?.count > 0) {
          heatmapData.push({
            latitude: gridLat + latStep / 2,
            longitude: gridLng + lngStep / 2,
            count: countResult.count,
            weight: Math.min(countResult.count / 10, 1)
            // Normalize to 0-1
          });
        }
      }
    }
    return heatmapData;
  }),
  /**
   * Save a location from Google Places API to database
   * This auto-populates our locations table when agents/developers submit properties
   */
  saveGooglePlaceLocation: publicProcedure.input(
    z10.object({
      placeId: z10.string(),
      name: z10.string(),
      fullAddress: z10.string(),
      types: z10.array(z10.string()),
      latitude: z10.number().optional(),
      longitude: z10.number().optional()
    })
  ).mutation(async ({ input }) => {
    const db3 = await getDb();
    let locationType = "location";
    if (input.types.includes("locality") || input.types.includes("administrative_area_level_2")) {
      locationType = "city";
    } else if (input.types.includes("sublocality") || input.types.includes("neighborhood")) {
      locationType = "suburb";
    }
    const addressParts = input.fullAddress.split(",").map((p) => p.trim());
    const province2 = addressParts.length > 1 ? addressParts[addressParts.length - 2] : null;
    try {
      const [existing] = await db3.execute(sql13`
          SELECT id FROM locations WHERE place_id = ${input.placeId}
        `);
      if (Array.isArray(existing) && existing.length > 0) {
        const locationId = existing[0].id;
        await db3.execute(sql13`
            UPDATE locations 
            SET name = ${input.name},
                full_address = ${input.fullAddress},
                location_type = ${locationType},
                province = ${province2},
                latitude = ${input.latitude || null},
                longitude = ${input.longitude || null},
                updated_at = CURRENT_TIMESTAMP
            WHERE place_id = ${input.placeId}
          `);
        return {
          success: true,
          locationId,
          message: "Location updated successfully"
        };
      } else {
        const [result] = await db3.execute(sql13`
            INSERT INTO locations (place_id, name, full_address, location_type, province, latitude, longitude)
            VALUES (${input.placeId}, ${input.name}, ${input.fullAddress}, ${locationType}, ${province2 || null}, ${input.latitude || null}, ${input.longitude || null})
          `);
        return {
          success: true,
          locationId: result.insertId,
          message: "Location saved successfully"
        };
      }
    } catch (error) {
      console.error("Failed to save Google Place location:", error);
      throw new Error("Failed to save location to database");
    }
  }),
  /**
   * Geocode a manual address entry
   * Requirements 7.3, 7.4: Geocode manual entries and populate coordinates
   * Requirements 7.5: Handle geocoding failures gracefully
   */
  geocodeAddress: publicProcedure.input(
    z10.object({
      address: z10.string().min(1).max(500)
    })
  ).query(async ({ input }) => {
    const { googlePlacesService: googlePlacesService2 } = await Promise.resolve().then(() => (init_googlePlacesService(), googlePlacesService_exports));
    try {
      const result = await googlePlacesService2.geocodeAddress(input.address);
      if (!result) {
        return {
          success: false,
          error: "Could not geocode address",
          message: "No results found for the provided address"
        };
      }
      return {
        success: true,
        result: {
          placeId: result.placeId,
          formattedAddress: result.formattedAddress,
          addressComponents: result.addressComponents,
          geometry: result.geometry
        }
      };
    } catch (error) {
      console.error("Geocoding error:", error);
      return {
        success: false,
        error: "Geocoding failed",
        message: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  })
});

// server/enhancedLocationRouter.ts
init_db();
init_schema();
import { z as z11 } from "zod";
import { eq as eq14, and as and14, like as like9, sql as sql14, count as count5 } from "drizzle-orm";
var enhancedLocationRouter = router({
  /**
   * Advanced property search with multiple criteria
   */
  advancedPropertySearch: publicProcedure.input(
    z11.object({
      // Location criteria
      location: z11.object({
        type: z11.enum(["province", "city", "suburb", "coordinates"]),
        value: z11.string(),
        // Name or coordinates "lat,lng"
        radius: z11.number().min(0.1).max(100).default(10)
        // km
      }).optional(),
      // Property filters
      filters: z11.object({
        propertyType: z11.array(z11.string()).optional(),
        listingType: z11.array(z11.string()).optional(),
        minPrice: z11.number().optional(),
        maxPrice: z11.number().optional(),
        bedrooms: z11.object({
          min: z11.number().optional(),
          max: z11.number().optional()
        }).optional(),
        bathrooms: z11.object({
          min: z11.number().optional(),
          max: z11.number().optional()
        }).optional(),
        minArea: z11.number().optional(),
        maxArea: z11.number().optional(),
        amenities: z11.array(z11.string()).optional()
      }).optional(),
      // Nearby amenities
      amenities: z11.object({
        schools: z11.object({
          enabled: z11.boolean().default(false),
          maxDistance: z11.number().min(0.1).max(10).default(2)
          // km
        }).optional(),
        hospitals: z11.object({
          enabled: z11.boolean().default(false),
          maxDistance: z11.number().min(0.1).max(10).default(5)
        }).optional(),
        transport: z11.object({
          enabled: z11.boolean().default(false),
          maxDistance: z11.number().min(0.1).max(5).default(1)
        }).optional(),
        shopping: z11.object({
          enabled: z11.boolean().default(false),
          maxDistance: z11.number().min(0.1).max(10).default(2)
        }).optional()
      }).optional(),
      // Pagination and sorting
      limit: z11.number().min(1).max(100).default(20),
      offset: z11.number().min(0).default(0),
      sortBy: z11.enum(["price", "distance", "newest", "area"]).default("newest"),
      sortOrder: z11.enum(["asc", "desc"]).default("desc"),
      // Map bounds for spatial filtering
      bounds: z11.object({
        north: z11.number(),
        south: z11.number(),
        east: z11.number(),
        west: z11.number()
      }).optional()
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const conditions = [eq14(properties.status, "published")];
    if (input.location) {
      if (input.location.type === "province") {
        const [province2] = await db3.select({ id: provinces.id }).from(provinces).where(like9(provinces.name, `%${input.location.value}%`)).limit(1);
        if (province2) {
          conditions.push(eq14(properties.provinceId, province2.id));
        }
      } else if (input.location.type === "city") {
        const [city] = await db3.select({ id: cities.id }).from(cities).where(like9(cities.name, `%${input.location.value}%`)).limit(1);
        if (city) {
          conditions.push(eq14(properties.cityId, city.id));
        }
      } else if (input.location.type === "suburb") {
        const [suburb] = await db3.select({ id: suburbs.id }).from(suburbs).where(like9(suburbs.name, `%${input.location.value}%`)).limit(1);
        if (suburb) {
          conditions.push(eq14(properties.suburbId, suburb.id));
        }
      } else if (input.location.type === "coordinates") {
        const [lat, lng] = input.location.value.split(",").map(Number);
        if (!isNaN(lat) && !isNaN(lng)) {
          const radiusKm = input.location.radius;
          conditions.push(
            sql14`(
                6371 * acos(
                  cos(radians(${lat})) * 
                  cos(radians(${properties.latitude})) * 
                  cos(radians(${properties.longitude}) - radians(${lng})) + 
                  sin(radians(${lat})) * 
                  sin(radians(${properties.latitude}))
                )
              ) <= ${radiusKm}`
          );
        }
      }
    }
    if (input.bounds) {
      conditions.push(
        sql14`${properties.latitude} BETWEEN ${input.bounds.south} AND ${input.bounds.north}`,
        sql14`${properties.longitude} BETWEEN ${input.bounds.west} AND ${input.bounds.east}`
      );
    }
    if (input.filters) {
      const { propertyType, listingType, minPrice, maxPrice, minArea, maxArea, amenities: amenities3 } = input.filters;
      if (propertyType?.length) {
        conditions.push(
          sql14`${properties.propertyType} IN (${propertyType.map(() => "?").join(",")})`
        );
      }
      if (listingType?.length) {
        conditions.push(
          sql14`${properties.listingType} IN (${listingType.map(() => "?").join(",")})`
        );
      }
      if (minPrice) conditions.push(sql14`${properties.price} >= ${minPrice}`);
      if (maxPrice) conditions.push(sql14`${properties.price} <= ${maxPrice}`);
      if (minArea) conditions.push(sql14`${properties.area} >= ${minArea}`);
      if (maxArea) conditions.push(sql14`${properties.area} <= ${maxArea}`);
      if (input.filters.bedrooms) {
        if (input.filters.bedrooms.min) {
          conditions.push(sql14`${properties.bedrooms} >= ${input.filters.bedrooms.min}`);
        }
        if (input.filters.bedrooms.max) {
          conditions.push(sql14`${properties.bedrooms} <= ${input.filters.bedrooms.max}`);
        }
      }
      if (input.filters.bathrooms) {
        if (input.filters.bathrooms.min) {
          conditions.push(sql14`${properties.bathrooms} >= ${input.filters.bathrooms.min}`);
        }
        if (input.filters.bathrooms.max) {
          conditions.push(sql14`${properties.bathrooms} <= ${input.filters.bathrooms.max}`);
        }
      }
    }
    const baseQuery = db3.select({
      id: properties.id,
      title: properties.title,
      description: properties.description,
      price: properties.price,
      propertyType: properties.propertyType,
      listingType: properties.listingType,
      bedrooms: properties.bedrooms,
      bathrooms: properties.bathrooms,
      area: properties.area,
      latitude: properties.latitude,
      longitude: properties.longitude,
      mainImage: properties.mainImage,
      address: properties.address,
      city: properties.city,
      province: properties.province,
      createdAt: properties.createdAt,
      distance: sql14`
            CASE 
              WHEN ${input.location?.type === "coordinates"} THEN
                (6371 * acos(
                  cos(radians(${input.location?.value.split(",").map(Number)[0] || 0})) * 
                  cos(radians(${properties.latitude})) * 
                  cos(radians(${properties.longitude}) - radians(${input.location?.value.split(",").map(Number)[1] || 0})) + 
                  sin(radians(${input.location?.value.split(",").map(Number)[0] || 0})) * 
                  sin(radians(${properties.latitude}))
                ))
              ELSE NULL
            END
          `.as("distance_km")
    }).from(properties).where(and14(...conditions));
    let orderedQuery = baseQuery;
    if (input.sortBy === "distance" && input.location?.type === "coordinates") {
      orderedQuery = baseQuery.orderBy(sql14`distance_km ${input.sortOrder}`);
    } else if (input.sortBy === "price") {
      orderedQuery = baseQuery.orderBy(
        input.sortOrder === "asc" ? sql14`${properties.price} ASC` : sql14`${properties.price} DESC`
      );
    } else if (input.sortBy === "area") {
      orderedQuery = baseQuery.orderBy(
        input.sortOrder === "asc" ? sql14`${properties.area} ASC` : sql14`${properties.area} DESC`
      );
    } else {
      orderedQuery = baseQuery.orderBy(
        input.sortOrder === "asc" ? sql14`${properties.createdAt} ASC` : sql14`${properties.createdAt} DESC`
      );
    }
    const results = await orderedQuery.limit(input.limit).offset(input.offset);
    const enhancedResults = await Promise.all(
      results.map(async (property) => {
        const enhanced = { ...property };
        if (input.amenities) {
          enhanced.nearbyAmenities = {
            schools: 0,
            hospitals: 0,
            transport: 0,
            shopping: 0
          };
        }
        return enhanced;
      })
    );
    return {
      properties: enhancedResults,
      total: enhancedResults.length,
      hasMore: enhancedResults.length === input.limit
    };
  }),
  /**
   * Get nearby amenities for a location
   */
  getNearbyAmenities: publicProcedure.input(
    z11.object({
      latitude: z11.number().min(-90).max(90),
      longitude: z11.number().min(-180).max(180),
      radius: z11.number().min(0.1).max(10).default(2),
      // km
      types: z11.array(
        z11.enum([
          "school",
          "hospital",
          "shopping",
          "restaurant",
          "transport",
          "bank",
          "park",
          "university"
        ])
      ).optional(),
      limit: z11.number().min(1).max(50).default(20)
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const { googlePlacesService: googlePlacesService2 } = await Promise.resolve().then(() => (init_googlePlacesService(), googlePlacesService_exports));
    const allPromises = (input.types || []).map(async (type) => {
      let googleType = type;
      if (type === "transport") googleType = "train_station|bus_station|subway_station|transit_station";
      if (type === "shopping") googleType = "shopping_mall|supermarket";
      if (type === "education") googleType = "school|university";
      const searchType = googleType.split("|")[0];
      return googlePlacesService2.getNearbyPlaces(
        input.latitude,
        input.longitude,
        input.radius * 1e3,
        // convert km to meters
        searchType
      );
    });
    const resultsNested = await Promise.all(allPromises);
    const allResults = resultsNested.flat();
    const uniqueResults = Array.from(new Map(allResults.map((item) => [item.place_id, item])).values());
    const amenitiesWithDistance = uniqueResults.map((amenity) => {
      const distance = calculateHaversineDistance(
        input.latitude,
        input.longitude,
        amenity.latitude,
        amenity.longitude
      );
      return {
        id: amenity.id || Math.random(),
        // Ensure ID
        name: amenity.name,
        type: amenity.type,
        // This might need mapping back to enum if strict
        address: amenity.address,
        latitude: amenity.latitude,
        longitude: amenity.longitude,
        distance: Math.round(distance * 10) / 10,
        rating: amenity.rating
      };
    }).filter((amenity) => amenity.distance <= input.radius).sort((a, b) => a.distance - b.distance).slice(0, input.limit);
    return amenitiesWithDistance;
  }),
  /**
   * Get property density heatmap data
   */
  getPropertyHeatmap: publicProcedure.input(
    z11.object({
      bounds: z11.object({
        north: z11.number(),
        south: z11.number(),
        east: z11.number(),
        west: z11.number()
      }),
      gridSize: z11.number().min(5).max(50).default(15),
      filters: z11.object({
        propertyType: z11.array(z11.string()).optional(),
        minPrice: z11.number().optional(),
        maxPrice: z11.number().optional()
      }).optional()
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const latStep = (input.bounds.north - input.bounds.south) / input.gridSize;
    const lngStep = (input.bounds.east - input.bounds.west) / input.gridSize;
    const heatmapData = [];
    const conditions = [eq14(properties.status, "published")];
    if (input.filters?.propertyType?.length) {
      conditions.push(
        sql14`${properties.propertyType} IN (${input.filters.propertyType.map(() => "?").join(",")})`
      );
    }
    if (input.filters?.minPrice) {
      conditions.push(sql14`${properties.price} >= ${input.filters.minPrice}`);
    }
    if (input.filters?.maxPrice) {
      conditions.push(sql14`${properties.price} <= ${input.filters.maxPrice}`);
    }
    for (let i = 0; i < input.gridSize; i++) {
      for (let j = 0; j < input.gridSize; j++) {
        const gridLat = input.bounds.south + i * latStep;
        const gridLng = input.bounds.west + j * lngStep;
        const cellConditions = [
          ...conditions,
          sql14`${properties.latitude} BETWEEN ${gridLat} AND ${gridLat + latStep}`,
          sql14`${properties.longitude} BETWEEN ${gridLng} AND ${gridLng + lngStep}`
        ];
        const [countResult] = await db3.select({ count: count5() }).from(properties).where(and14(...cellConditions));
        if (countResult?.count > 0) {
          heatmapData.push({
            latitude: gridLat + latStep / 2,
            longitude: gridLng + lngStep / 2,
            count: countResult.count,
            weight: Math.min(countResult.count / 10, 1),
            intensity: Math.min(countResult.count / 5, 0.8)
          });
        }
      }
    }
    return heatmapData;
  }),
  /**
   * Get similar properties based on location and features
   */
  getSimilarProperties: publicProcedure.input(
    z11.object({
      propertyId: z11.number(),
      radius: z11.number().min(0.5).max(10).default(2),
      // km
      limit: z11.number().min(1).max(20).default(10),
      includePriceRange: z11.boolean().default(true)
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    const [referenceProperty] = await db3.select().from(properties).where(eq14(properties.id, input.propertyId)).limit(1);
    if (!referenceProperty) {
      throw new Error("Property not found");
    }
    const conditions = [
      eq14(properties.status, "published"),
      sql14`${properties.id} != ${input.propertyId}`,
      // Location similarity
      sql14`(
          6371 * acos(
            cos(radians(${referenceProperty.latitude || 0})) * 
            cos(radians(${properties.latitude || 0})) * 
            cos(radians(${properties.longitude || 0}) - radians(${referenceProperty.longitude || 0})) + 
            sin(radians(${referenceProperty.latitude || 0})) * 
            sin(radians(${properties.latitude || 0}))
          )
        ) <= ${input.radius}`
    ];
    if (referenceProperty.propertyType) {
      conditions.push(eq14(properties.propertyType, referenceProperty.propertyType));
    }
    if (input.includePriceRange && referenceProperty.price) {
      const priceRange = referenceProperty.price * 0.3;
      conditions.push(
        sql14`${properties.price} BETWEEN ${referenceProperty.price - priceRange} AND ${referenceProperty.price + priceRange}`
      );
    }
    const similarProperties = await db3.select({
      id: properties.id,
      title: properties.title,
      price: properties.price,
      propertyType: properties.propertyType,
      listingType: properties.listingType,
      bedrooms: properties.bedrooms,
      bathrooms: properties.bathrooms,
      area: properties.area,
      latitude: properties.latitude,
      longitude: properties.longitude,
      mainImage: properties.mainImage,
      city: properties.city,
      province: properties.province,
      distance: sql14`
            (6371 * acos(
              cos(radians(${referenceProperty.latitude || 0})) * 
              cos(radians(${properties.latitude || 0})) * 
              cos(radians(${properties.longitude || 0}) - radians(${referenceProperty.longitude || 0})) + 
              sin(radians(${referenceProperty.latitude || 0})) * 
              sin(radians(${properties.latitude || 0}))
            ))
          `.as("distance_km")
    }).from(properties).where(and14(...conditions)).orderBy(sql14`distance_km ASC`).limit(input.limit);
    return similarProperties;
  }),
  /**
   * Get location insights and statistics
   */
  getLocationInsights: publicProcedure.input(
    z11.object({
      location: z11.object({
        type: z11.enum(["province", "city", "suburb"]),
        value: z11.string()
      }),
      propertyType: z11.string().optional(),
      listingType: z11.string().optional()
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    let locationFilter = "";
    let locationValue = input.location.value;
    if (input.location.type === "province") {
      locationFilter = properties.province;
      const [province2] = await db3.select({ name: provinces.name }).from(provinces).where(like9(provinces.name, `%${locationValue}%`)).limit(1);
      if (province2) {
        locationValue = province2.name;
      }
    } else if (input.location.type === "city") {
      locationFilter = properties.city;
    } else if (input.location.type === "suburb") {
      locationFilter = properties.address;
      locationValue = `%${locationValue}%`;
    }
    const conditions = [eq14(properties.status, "published")];
    if (locationValue && locationFilter) {
      if (input.location.type === "suburb") {
        conditions.push(like9(properties.address, locationValue));
      } else {
        conditions.push(eq14(locationFilter, locationValue));
      }
    }
    if (input.propertyType) {
      conditions.push(eq14(properties.propertyType, input.propertyType));
    }
    if (input.listingType) {
      conditions.push(eq14(properties.listingType, input.listingType));
    }
    const [priceStats] = await db3.select({
      avgPrice: sql14`AVG(${properties.price})`.as("avg_price"),
      minPrice: sql14`MIN(${properties.price})`.as("min_price"),
      maxPrice: sql14`MAX(${properties.price})`.as("max_price"),
      medianPrice: sql14`(
            SELECT AVG(price) FROM (
              SELECT price FROM properties 
              WHERE ${and14(...conditions)}
              ORDER BY price 
              LIMIT (SELECT COUNT(*) FROM properties WHERE ${and14(...conditions)} + 1) / 2, 1
            ) as median_price
          )`.as("median_price"),
      totalProperties: count5()
    }).from(properties).where(and14(...conditions));
    const propertyTypes = await db3.select({
      type: properties.propertyType,
      count: count5()
    }).from(properties).where(and14(...conditions)).groupBy(properties.propertyType).orderBy(count5());
    const listingTypes = await db3.select({
      type: properties.listingType,
      count: count5()
    }).from(properties).where(and14(...conditions)).groupBy(properties.listingType).orderBy(count5());
    return {
      priceStats: {
        average: Math.round(priceStats?.avgPrice || 0),
        minimum: priceStats?.minPrice || 0,
        maximum: priceStats?.maxPrice || 0,
        median: Math.round(priceStats?.medianPrice || 0),
        totalProperties: priceStats?.totalProperties || 0
      },
      distribution: {
        propertyTypes: propertyTypes.map((pt) => ({
          type: pt.type,
          count: pt.count,
          percentage: Math.round(pt.count / (priceStats?.totalProperties || 1) * 100)
        })),
        listingTypes: listingTypes.map((lt) => ({
          type: lt.type,
          count: lt.count,
          percentage: Math.round(lt.count / (priceStats?.totalProperties || 1) * 100)
        }))
      }
    };
  }),
  /**
   * Save search for user notifications
   */
  saveSearch: protectedProcedure.input(
    z11.object({
      name: z11.string().min(1).max(255),
      searchParams: z11.object({
        location: z11.any().optional(),
        filters: z11.any().optional(),
        amenities: z11.any().optional()
      }),
      notificationEnabled: z11.boolean().default(true)
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    const [existingSearch] = await db3.select().from(locationSearchCache).where(
      and14(
        eq14(locationSearchCache.searchQuery, `${ctx.user.id}_${input.name}`),
        eq14(locationSearchCache.searchType, "saved_search")
      )
    ).limit(1);
    if (existingSearch) {
      await db3.update(locationSearchCache).set({
        resultsJSON: JSON.stringify({
          params: input.searchParams,
          notificationEnabled: input.notificationEnabled,
          updatedAt: /* @__PURE__ */ new Date()
        }),
        expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3)
        // 1 year
      }).where(eq14(locationSearchCache.id, existingSearch.id));
      return { success: true, updated: true };
    } else {
      await db3.insert(locationSearchCache).values({
        searchQuery: `${ctx.user.id}_${input.name}`,
        searchType: "saved_search",
        resultsJSON: JSON.stringify({
          params: input.searchParams,
          notificationEnabled: input.notificationEnabled,
          createdAt: /* @__PURE__ */ new Date()
        }),
        expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3)
        // 1 year
      });
      return { success: true, created: true };
    }
  })
});
function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// server/googleMapsRouter.ts
init_env();
import { z as z12 } from "zod";
import axios2 from "axios";
var googleMapsRouter = router({
  /**
   * Google Places API - Enhanced place search with autocomplete
   */
  googlePlaceSearch: publicProcedure.input(
    z12.object({
      query: z12.string().min(1),
      location: z12.object({
        latitude: z12.number(),
        longitude: z12.number()
      }).optional(),
      radius: z12.number().min(1).max(5e4).default(25e3),
      // meters
      type: z12.array(z12.string()).optional()
    })
  ).query(async ({ input }) => {
    if (!ENV.googlePlacesApiKey) {
      throw new Error("Google Places API key not configured");
    }
    try {
      const params = {
        key: ENV.googlePlacesApiKey,
        input: input.query,
        types: input.type?.join(",")
      };
      if (input.location) {
        params.location = `${input.location.latitude},${input.location.longitude}`;
        params.radius = input.radius;
      }
      const response = await axios2.get(
        "https://maps.googleapis.com/maps/api/place/autocomplete/json",
        { params }
      );
      return {
        predictions: response.data.predictions?.map((prediction) => ({
          place_id: prediction.place_id,
          description: prediction.description,
          structured_formatting: prediction.structured_formatting,
          types: prediction.types,
          matched_substrings: prediction.matched_substrings
        })) || []
      };
    } catch (error) {
      console.error("Google Places API error:", error);
      throw new Error("Failed to search places");
    }
  }),
  /**
   * Google Places API - Get detailed place information
   */
  googlePlaceDetails: publicProcedure.input(
    z12.object({
      placeId: z12.string(),
      fields: z12.array(z12.string()).default([
        "place_id",
        "name",
        "formatted_address",
        "geometry",
        "photos",
        "rating",
        "user_ratings_total",
        "price_level",
        "opening_hours",
        "website",
        "formatted_phone_number"
      ])
    })
  ).query(async ({ input }) => {
    if (!ENV.googlePlacesApiKey) {
      throw new Error("Google Places API key not configured");
    }
    try {
      const response = await axios2.get(
        "https://maps.googleapis.com/maps/api/place/details/json",
        {
          params: {
            key: ENV.googlePlacesApiKey,
            place_id: input.placeId,
            fields: input.fields.join(",")
          }
        }
      );
      if (response.data.status !== "OK") {
        throw new Error(`Places API error: ${response.data.status}`);
      }
      const place = response.data.result;
      return {
        place_id: place.place_id,
        name: place.name,
        formatted_address: place.formatted_address,
        location: place.geometry?.location,
        viewport: place.geometry?.viewport,
        photos: place.photos?.map((photo) => ({
          photo_reference: photo.photo_reference,
          width: photo.width,
          height: photo.height,
          url: `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photoreference=${photo.photo_reference}&key=${ENV.googlePlacesApiKey}`
        })) || [],
        rating: place.rating,
        user_ratings_total: place.user_ratings_total,
        price_level: place.price_level,
        opening_hours: place.opening_hours,
        website: place.website,
        formatted_phone_number: place.formatted_phone_number,
        types: place.types
      };
    } catch (error) {
      console.error("Google Place Details API error:", error);
      throw new Error("Failed to get place details");
    }
  }),
  /**
   * Google Geocoding API - Enhanced address resolution
   */
  googleGeocoding: publicProcedure.input(
    z12.object({
      address: z12.string().optional(),
      latlng: z12.object({
        latitude: z12.number(),
        longitude: z12.number()
      }).optional(),
      components: z12.object({
        country: z12.string().optional(),
        locality: z12.string().optional(),
        postal_code: z12.string().optional(),
        route: z12.string().optional()
      }).optional()
    })
  ).query(async ({ input }) => {
    if (!ENV.googleGeocodingApiKey) {
      throw new Error("Google Geocoding API key not configured");
    }
    try {
      const params = {
        key: ENV.googleGeocodingApiKey
      };
      if (input.address) {
        params.address = input.address;
      } else if (input.latlng) {
        params.latlng = `${input.latlng.latitude},${input.latlng.longitude}`;
      }
      if (input.components) {
        params.components = Object.entries(input.components).map(([key, value]) => `${key}:${value}`).join("|");
      }
      const response = await axios2.get("https://maps.googleapis.com/maps/api/geocode/json", {
        params
      });
      if (response.data.status !== "OK") {
        throw new Error(`Geocoding API error: ${response.data.status}`);
      }
      return {
        results: response.data.results.map((result) => ({
          place_id: result.place_id,
          formatted_address: result.formatted_address,
          address_components: result.address_components,
          geometry: result.geometry,
          types: result.types,
          postcode_localities: result.postcode_localities
        }))
      };
    } catch (error) {
      console.error("Google Geocoding API error:", error);
      throw new Error("Failed to geocode address");
    }
  }),
  /**
   * Google Places Nearby Search - Enhanced POI discovery
   */
  googleNearbySearch: publicProcedure.input(
    z12.object({
      location: z12.object({
        latitude: z12.number(),
        longitude: z12.number()
      }),
      radius: z12.number().min(1).max(5e4).default(2e3),
      // meters
      type: z12.array(z12.string()).optional(),
      keyword: z12.string().optional()
    })
  ).query(async ({ input }) => {
    if (!ENV.googlePlacesApiKey) {
      throw new Error("Google Places API key not configured");
    }
    try {
      const params = {
        key: ENV.googlePlacesApiKey,
        location: `${input.location.latitude},${input.location.longitude}`,
        radius: input.radius
      };
      if (input.type?.length) {
        params.type = input.type[0];
      }
      if (input.keyword) {
        params.keyword = input.keyword;
      }
      const response = await axios2.get(
        "https://maps.googleapis.com/maps/api/place/nearbysearch/json",
        { params }
      );
      if (response.data.status !== "OK") {
        throw new Error(`Nearby Search API error: ${response.data.status}`);
      }
      const results = response.data.results.map((place) => {
        const distance = calculateHaversineDistance2(
          input.location.latitude,
          input.location.longitude,
          place.geometry.location.lat,
          place.geometry.location.lng
        );
        return {
          place_id: place.place_id,
          name: place.name,
          vicinity: place.vicinity,
          location: place.geometry.location,
          rating: place.rating,
          user_ratings_total: place.user_ratings_total,
          price_level: place.price_level,
          types: place.types,
          photos: place.photos?.map((photo) => ({
            photo_reference: photo.photo_reference,
            width: photo.width,
            height: photo.height,
            url: `https://maps.googleapis.com/maps/api/place/photo?maxwidth=300&photoreference=${photo.photo_reference}&key=${ENV.googlePlacesApiKey}`
          })) || [],
          distance: Math.round(distance * 100) / 100,
          // Round to 2 decimal places
          opening_hours: place.opening_hours,
          business_status: place.business_status
        };
      });
      results.sort((a, b) => a.distance - b.distance);
      return { results };
    } catch (error) {
      console.error("Google Nearby Search API error:", error);
      throw new Error("Failed to search nearby places");
    }
  }),
  /**
   * Google Street View API - Get Street View imagery
   */
  googleStreetView: publicProcedure.input(
    z12.object({
      location: z12.object({
        latitude: z12.number(),
        longitude: z12.number()
      }),
      heading: z12.number().min(0).max(360).optional(),
      fov: z12.number().min(10).max(120).default(90),
      pitch: z12.number().min(-90).max(90).optional(),
      size: z12.object({
        width: z12.number().min(1).max(640).default(640),
        height: z12.number().min(1).max(640).default(640)
      })
    })
  ).query(async ({ input }) => {
    if (!ENV.googleStreetViewApiKey) {
      throw new Error("Google Street View API key not configured");
    }
    try {
      const response = await axios2.get("https://maps.googleapis.com/maps/api/streetview", {
        params: {
          key: ENV.googleStreetViewApiKey,
          location: `${input.location.latitude},${input.location.longitude}`,
          heading: input.heading,
          fov: input.fov,
          pitch: input.pitch,
          size: `${input.size.width}x${input.size.height}`
        },
        responseType: "blob"
      });
      const reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onload = () => {
          resolve({
            imageUrl: reader.result,
            metadata: {
              location: input.location,
              heading: input.heading,
              fov: input.fov,
              pitch: input.pitch
            }
          });
        };
        reader.onerror = reject;
        reader.readAsDataURL(response.data);
      });
    } catch (error) {
      console.error("Google Street View API error:", error);
      throw new Error("Failed to get Street View imagery");
    }
  }),
  /**
   * Google Directions API - Get routing and directions
   */
  googleDirections: publicProcedure.input(
    z12.object({
      origin: z12.union([
        z12.object({
          latitude: z12.number(),
          longitude: z12.number()
        }),
        z12.string()
      ]),
      destination: z12.union([
        z12.object({
          latitude: z12.number(),
          longitude: z12.number()
        }),
        z12.string()
      ]),
      mode: z12.enum(["driving", "walking", "bicycling", "transit"]).default("driving"),
      departure_time: z12.number().optional(),
      traffic_model: z12.enum(["best_guess", "pessimistic", "optimistic"]).default("best_guess")
    })
  ).query(async ({ input }) => {
    if (!ENV.googleMapsApiKey) {
      throw new Error("Google Maps API key not configured");
    }
    try {
      const params = {
        key: ENV.googleMapsApiKey,
        mode: input.mode,
        departure_time: input.departure_time,
        traffic_model: input.traffic_model
      };
      if (typeof input.origin === "string") {
        params.origin = input.origin;
      } else {
        params.origin = `${input.origin.latitude},${input.origin.longitude}`;
      }
      if (typeof input.destination === "string") {
        params.destination = input.destination;
      } else {
        params.destination = `${input.destination.latitude},${input.destination.longitude}`;
      }
      const response = await axios2.get("https://maps.googleapis.com/maps/api/directions/json", {
        params
      });
      if (response.data.status !== "OK") {
        throw new Error(`Directions API error: ${response.data.status}`);
      }
      const route = response.data.routes[0];
      if (!route) {
        throw new Error("No routes found");
      }
      const leg = route.legs[0];
      return {
        summary: route.summary,
        distance: {
          text: leg.distance.text,
          value: leg.distance.value
        },
        duration: {
          text: leg.duration.text,
          value: leg.duration.value
        },
        duration_in_traffic: leg.duration_in_traffic ? {
          text: leg.duration_in_traffic.text,
          value: leg.duration_in_traffic.value
        } : null,
        steps: leg.steps.map((step) => ({
          instruction: step.html_instructions,
          distance: step.distance,
          duration: step.duration,
          polyline: step.polyline,
          travel_mode: step.travel_mode
        })),
        overview_polyline: route.overview_polyline.points,
        bounds: route.bounds,
        copyrights: route.copyrights,
        warnings: route.warnings
      };
    } catch (error) {
      console.error("Google Directions API error:", error);
      throw new Error("Failed to get directions");
    }
  }),
  /**
   * Google Distance Matrix API - Calculate distance and time between multiple points
   */
  googleDistanceMatrix: publicProcedure.input(
    z12.object({
      origins: z12.array(
        z12.union([
          z12.object({
            latitude: z12.number(),
            longitude: z12.number()
          }),
          z12.string()
        ])
      ),
      destinations: z12.array(
        z12.union([
          z12.object({
            latitude: z12.number(),
            longitude: z12.number()
          }),
          z12.string()
        ])
      ),
      mode: z12.enum(["driving", "walking", "bicycling", "transit"]).default("driving"),
      units: z12.enum(["metric", "imperial"]).default("metric")
    })
  ).query(async ({ input }) => {
    if (!ENV.googleMapsApiKey) {
      throw new Error("Google Maps API key not configured");
    }
    try {
      const params = {
        key: ENV.googleMapsApiKey,
        mode: input.mode,
        units: input.units
      };
      const originStrings = input.origins.map(
        (origin) => typeof origin === "string" ? origin : `${origin.latitude},${origin.longitude}`
      );
      params.origins = originStrings.join("|");
      const destinationStrings = input.destinations.map(
        (destination) => typeof destination === "string" ? destination : `${destination.latitude},${destination.longitude}`
      );
      params.destinations = destinationStrings.join("|");
      const response = await axios2.get(
        "https://maps.googleapis.com/maps/api/distancematrix/json",
        { params }
      );
      if (response.data.status !== "OK") {
        throw new Error(`Distance Matrix API error: ${response.data.status}`);
      }
      return {
        origin_addresses: response.data.origin_addresses,
        destination_addresses: response.data.destination_addresses,
        rows: response.data.rows.map((row, index2) => ({
          origin: originStrings[index2],
          elements: row.elements.map((element) => ({
            distance: element.distance,
            duration: element.duration,
            status: element.status,
            duration_in_traffic: element.duration_in_traffic
          }))
        }))
      };
    } catch (error) {
      console.error("Google Distance Matrix API error:", error);
      throw new Error("Failed to calculate distances");
    }
  }),
  /**
   * Google Places Text Search - Search for places by text query
   */
  googleTextSearch: publicProcedure.input(
    z12.object({
      query: z12.string(),
      location: z12.object({
        latitude: z12.number(),
        longitude: z12.number()
      }).optional(),
      radius: z12.number().min(1).max(5e4).default(25e3),
      type: z12.string().optional(),
      openNow: z12.boolean().default(false)
    })
  ).query(async ({ input }) => {
    if (!ENV.googlePlacesApiKey) {
      throw new Error("Google Places API key not configured");
    }
    try {
      const params = {
        key: ENV.googlePlacesApiKey,
        query: input.query,
        open_now: input.openNow
      };
      if (input.location) {
        params.location = `${input.location.latitude},${input.location.longitude}`;
        params.radius = input.radius;
      }
      if (input.type) {
        params.type = input.type;
      }
      const response = await axios2.get(
        "https://maps.googleapis.com/maps/api/place/textsearch/json",
        { params }
      );
      if (response.data.status !== "OK") {
        throw new Error(`Text Search API error: ${response.data.status}`);
      }
      return {
        results: response.data.results.map((place) => ({
          place_id: place.place_id,
          name: place.name,
          formatted_address: place.formatted_address,
          location: place.geometry.location,
          rating: place.rating,
          user_ratings_total: place.user_ratings_total,
          price_level: place.price_level,
          types: place.types,
          photos: place.photos?.map((photo) => ({
            photo_reference: photo.photo_reference,
            width: photo.width,
            height: photo.height,
            url: `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photoreference=${photo.photo_reference}&key=${ENV.googlePlacesApiKey}`
          })) || [],
          opening_hours: place.opening_hours,
          business_status: place.business_status
        })),
        next_page_token: response.data.next_page_token
      };
    } catch (error) {
      console.error("Google Text Search API error:", error);
      throw new Error("Failed to search places by text");
    }
  })
});
function calculateHaversineDistance2(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// server/services/priceInsightsService.ts
init_db();
init_schema();
import { eq as eq15, and as and15, inArray as inArray5, sql as sql15, desc as desc13, count as count6 } from "drizzle-orm";
var ACTIVE_STATUSES = ["available", "published", "pending"];
var PRICE_BUCKETS = [
  { range: "Below R1M", min: 0, max: 1e6 },
  { range: "R1M-R2M", min: 1e6, max: 2e6 },
  { range: "R2M-R3M", min: 2e6, max: 3e6 },
  { range: "R3M-R5M", min: 3e6, max: 5e6 },
  { range: "R5M-R10M", min: 5e6, max: 1e7 },
  { range: "Above R10M", min: 1e7, max: Infinity }
];
var PriceInsightsService = class {
  cache;
  CACHE_TTL = 15 * 60 * 1e3;
  // 15 minutes
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get price insights for all cities with sufficient listings
   */
  async getAllCityInsights() {
    const cacheKey = "all-cities";
    if (this.isCacheValid(cacheKey)) {
      return this.cache.get(cacheKey).data;
    }
    try {
      const dbInstance = await db;
      const citiesWithListings = await dbInstance.select({
        cityId: properties.cityId,
        cityName: properties.city,
        listingCount: count6(properties.id)
      }).from(properties).where(
        and15(
          inArray5(properties.status, ACTIVE_STATUSES),
          sql15`${properties.cityId} IS NOT NULL`
        )
      ).groupBy(properties.cityId, properties.city).having(sql15`COUNT(${properties.id}) >= 10`).orderBy(desc13(count6(properties.id)));
      const insights = {};
      for (const cityData of citiesWithListings) {
        if (!cityData.cityId) continue;
        const cityInsights = await this.getCityInsights(cityData.cityId);
        insights[cityData.cityName] = cityInsights;
      }
      this.cache.set(cacheKey, {
        data: insights,
        timestamp: Date.now()
      });
      return insights;
    } catch (error) {
      console.error("Error fetching all city insights:", error);
      throw error;
    }
  }
  /**
   * Get price insights for a specific city
   */
  async getCityInsights(cityId) {
    try {
      const dbInstance = await db;
      const cityProperties = await dbInstance.select().from(properties).where(
        and15(
          eq15(properties.cityId, cityId),
          inArray5(properties.status, ACTIVE_STATUSES)
        )
      );
      if (cityProperties.length === 0) {
        throw new Error(`No active listings found for city ID ${cityId}`);
      }
      const cityName = cityProperties[0].city;
      const prices = cityProperties.map((p) => p.price);
      const medianPrice = this.calculateMedianPrice(prices);
      const priceRanges = this.calculatePriceRanges(prices);
      const avgPricePerSqm = this.calculateAvgPricePerSqm(cityProperties);
      const micromarkets = await this.getTopMicromarkets(cityId);
      return {
        cityName,
        medianPrice,
        listings: cityProperties.length,
        avgPricePerSqm,
        priceRanges,
        micromarkets
      };
    } catch (error) {
      console.error(`Error fetching insights for city ${cityId}:`, error);
      throw error;
    }
  }
  /**
   * Calculate median price from array of prices
   */
  calculateMedianPrice(prices) {
    if (prices.length === 0) return 0;
    const sorted = [...prices].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return Math.round((sorted[mid - 1] + sorted[mid]) / 2);
    } else {
      return sorted[mid];
    }
  }
  /**
   * Calculate price range distribution
   * Returns all 6 buckets, even if count is zero
   */
  calculatePriceRanges(prices) {
    const bucketCounts = /* @__PURE__ */ new Map();
    PRICE_BUCKETS.forEach((bucket) => {
      bucketCounts.set(bucket.range, 0);
    });
    prices.forEach((price) => {
      for (const bucket of PRICE_BUCKETS) {
        if (price >= bucket.min && price < bucket.max) {
          bucketCounts.set(bucket.range, (bucketCounts.get(bucket.range) || 0) + 1);
          break;
        }
      }
    });
    return PRICE_BUCKETS.map((bucket) => ({
      range: bucket.range,
      count: bucketCounts.get(bucket.range) || 0
    }));
  }
  /**
   * Calculate average price per square meter
   * Excludes properties with null or zero area
   */
  calculateAvgPricePerSqm(props) {
    const validProperties = props.filter((p) => p.area && p.area > 0);
    if (validProperties.length === 0) return 0;
    const totalPricePerSqm = validProperties.reduce((sum3, p) => {
      return sum3 + p.price / p.area;
    }, 0);
    return Math.round(totalPricePerSqm / validProperties.length);
  }
  /**
   * Get top 4 micromarkets (suburbs) by listing count
   * Returns suburbs with at least 3 listings
   */
  async getTopMicromarkets(cityId) {
    try {
      const dbInstance = await db;
      const result = await dbInstance.execute(sql15`
        SELECT 
          s.name as area,
          AVG(p.price / NULLIF(p.area, 0)) as pricePerSqm,
          COUNT(p.id) as listingCount
        FROM suburbs s
        INNER JOIN properties p ON p.suburbId = s.id
        WHERE p.cityId = ${cityId}
          AND p.status IN ('available', 'published', 'pending')
          AND p.area > 0
        GROUP BY s.id, s.name
        HAVING listingCount >= 3
        ORDER BY listingCount DESC
        LIMIT 4
      `);
      return result.rows.map((row) => ({
        area: row.area,
        pricePerSqm: Math.round(row.pricePerSqm)
      }));
    } catch (error) {
      console.error(`Error fetching micromarkets for city ${cityId}:`, error);
      return [];
    }
  }
  /**
   * Check if cached data is still valid
   */
  isCacheValid(key) {
    const cached = this.cache.get(key);
    if (!cached) return false;
    const age = Date.now() - cached.timestamp;
    return age < this.CACHE_TTL;
  }
  /**
   * Clear cache (for testing or manual refresh)
   */
  clearCache() {
    this.cache.clear();
  }
};
var priceInsightsService = new PriceInsightsService();

// server/priceInsightsRouter.ts
var priceInsightsRouter = router({
  /**
   * Get price insights for all cities with sufficient listings
   * Returns aggregated statistics including median prices, price distributions,
   * average price per mÂ², and micromarket comparisons
   */
  getAllCityInsights: publicProcedure.query(async () => {
    try {
      const insights = await priceInsightsService.getAllCityInsights();
      return insights;
    } catch (error) {
      console.error("Error fetching price insights:", error);
      throw new Error("Failed to fetch price insights");
    }
  })
});

// server/devRouter.ts
import { z as z13 } from "zod";
init_db();
init_schema();
import { eq as eq16, and as and16 } from "drizzle-orm";

// server/_core/email/mockEmailService.ts
var MockEmailService = class {
  /**
   * Mock sendEmail - logs to console instead of sending
   */
  static async sendEmail(params) {
    console.log("\n\u{1F4E7} ========== MOCK EMAIL ==========");
    console.log(`From: ${params.from || "noreply@localhost.dev"}`);
    console.log(`To: ${params.to}`);
    console.log(`Subject: ${params.subject}`);
    console.log("\n--- HTML CONTENT ---");
    console.log(params.html);
    console.log("==================================\n");
    await new Promise((resolve) => setTimeout(resolve, 100));
    if (Math.random() > 0.95) {
      throw new Error("Mock email service: Random failure for testing");
    }
    return Promise.resolve();
  }
  /**
   * Send team invitation email (mocked)
   */
  static async sendTeamInvitationEmail(params) {
    const { to, agencyName, inviterName, invitationUrl, expiresAt } = params;
    await this.sendEmail({
      to,
      subject: `You've been invited to join ${agencyName}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1>You're Invited! \u{1F389}</h1>
          <p>
            <strong>${inviterName}</strong> has invited you to join 
            <strong>${agencyName}</strong> on SA Property Portal.
          </p>
          
          <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <p style="margin: 0 0 10px 0;"><strong>What's next?</strong></p>
            <ol style="margin: 0; padding-left: 20px;">
              <li>Click the button below to accept your invitation</li>
              <li>Create your account or sign in</li>
              <li>Start collaborating with your team!</li>
            </ol>
          </div>

          <a href="${invitationUrl}" 
             style="display: inline-block; background: #2563eb; color: white; 
                    padding: 12px 24px; text-decoration: none; border-radius: 6px; 
                    font-weight: bold; margin: 20px 0;">
            Accept Invitation
          </a>

          <p style="color: #666; font-size: 14px;">
            This invitation expires on ${expiresAt.toLocaleDateString()}.
          </p>

          <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
          
          <p style="color: #999; font-size: 12px;">
            If you didn't expect this invitation, you can safely ignore this email.
          </p>
        </div>
      `
    });
  }
  /**
   * Send welcome email to agency owner (mocked)
   */
  static async sendAgencyWelcomeEmail(params) {
    const { to, agencyName, dashboardUrl, planName, teamInvitesSent } = params;
    await this.sendEmail({
      to,
      subject: `Welcome to SA Property Portal, ${agencyName}!`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1>Welcome aboard, ${agencyName}! \u{1F3E0}</h1>
          
          <p>
            Congratulations! Your agency is now active on our platform with the 
            <strong>${planName}</strong> plan.
          </p>

          <div style="background: #f0fdf4; border-left: 4px solid #22c55e; 
                      padding: 15px; margin: 20px 0;">
            <p style="margin: 0;"><strong>\u2705 Your account is fully activated</strong></p>
            <p style="margin: 10px 0 0 0;">
              ${teamInvitesSent > 0 ? `We've sent invitations to ${teamInvitesSent} team member${teamInvitesSent > 1 ? "s" : ""}.` : "You can invite team members from your dashboard."}
            </p>
          </div>

          <h3>Next Steps:</h3>
          <ol>
            <li>Complete your agency profile</li>
            <li>Add your first property listing</li>
            <li>Invite additional team members</li>
            <li>Configure your branding preferences</li>
          </ol>

          <a href="${dashboardUrl}" 
             style="display: inline-block; background: #2563eb; color: white; 
                    padding: 12px 24px; text-decoration: none; border-radius: 6px; 
                    font-weight: bold; margin: 20px 0;">
            Go to Dashboard
          </a>

          <p style="color: #666; margin-top: 30px;">
            Need help getting started? Contact our support team for assistance.
          </p>
        </div>
      `
    });
  }
};

// server/devRouter.ts
var devRouter = router({
  /**
   * Manually trigger webhook for local testing
   * Simulates what Stripe webhook would do after successful payment
   */
  triggerWebhookManual: publicProcedure.input(
    z13.object({
      agencyId: z13.number(),
      planId: z13.number(),
      sessionId: z13.string().optional()
    })
  ).mutation(async ({ input }) => {
    const { agencyId, planId } = input;
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    console.log("\u{1F527} [DEV] Manual webhook trigger", { agencyId, planId });
    try {
      await db3.update(agencies).set({
        subscriptionStatus: "active",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq16(agencies.id, agencyId));
      console.log("\u2705 Agency activated");
      const [agency] = await db3.select({
        id: agencies.id,
        name: agencies.name,
        email: agencies.email,
        ownerEmail: users.email,
        ownerName: users.name,
        ownerFirstName: users.firstName
      }).from(agencies).leftJoin(users, eq16(users.agencyId, agencies.id)).where(eq16(agencies.id, agencyId)).limit(1);
      if (!agency) {
        throw new Error(`Agency ${agencyId} not found`);
      }
      const [plan] = await db3.select().from(plans).where(eq16(plans.id, planId)).limit(1);
      console.log(`\u{1F4CA} Agency: ${agency.name}, Plan: ${plan?.displayName || planId}`);
      const teamInvitations = await db3.select().from(invitations).where(and16(eq16(invitations.agencyId, agencyId), eq16(invitations.status, "pending"))).limit(50);
      console.log(`\u{1F4E8} Found ${teamInvitations.length} pending invitations`);
      let successCount = 0;
      const appUrl = process.env.VITE_APP_URL || "http://localhost:5173";
      for (const invitation of teamInvitations) {
        try {
          const inviteUrl = `${appUrl}/invite/accept?token=${invitation.token}`;
          const inviterName = agency.ownerName || agency.ownerFirstName || agency.ownerEmail?.split("@")[0] || "Your colleague";
          await MockEmailService.sendTeamInvitationEmail({
            to: invitation.email,
            agencyName: agency.name,
            inviterName,
            invitationUrl: inviteUrl,
            expiresAt: new Date(invitation.expiresAt)
          });
          successCount++;
          console.log(`\u2705 Invitation sent to ${invitation.email}`);
        } catch (error) {
          console.error(`\u274C Failed invitation to ${invitation.email}:`, error);
        }
      }
      console.log(`\u{1F4E7} Sent ${successCount}/${teamInvitations.length} team invitations`);
      if (agency.email) {
        try {
          await MockEmailService.sendAgencyWelcomeEmail({
            to: agency.email,
            agencyName: agency.name,
            dashboardUrl: `${appUrl}/agency/dashboard`,
            planName: plan?.displayName || `Plan ${planId}`,
            teamInvitesSent: successCount
          });
          console.log(`\u2705 Welcome email sent to ${agency.email}`);
        } catch (error) {
          console.error(`\u274C Failed to send welcome email:`, error);
        }
      }
      console.log(`\u2705 [DEV] Webhook simulation complete`);
      return {
        success: true,
        agencyActivated: true,
        invitationsSent: successCount,
        invitationsTotal: teamInvitations.length,
        message: `Agency activated! ${successCount}/${teamInvitations.length} invitations sent. Check console for email logs.`
      };
    } catch (error) {
      console.error("\u274C [DEV] Webhook simulation failed:", error);
      throw error;
    }
  })
});

// server/listingRouter.ts
import { z as z14 } from "zod";
init_db();
import { TRPCError as TRPCError5 } from "@trpc/server";

// server/services/locationAutoPopulation.ts
init_db();
init_schema();
import { eq as eq17, and as and17, sql as sql16 } from "drizzle-orm";
async function autoCreateLocationHierarchy(locationData) {
  console.log("[AutoLocation] Processing:", locationData.formattedAddress);
  const db3 = await getDb();
  const { components, latitude, longitude, placeId } = locationData;
  let provinceId = null;
  const provinceName = components.administrative_area_level_1;
  if (provinceName) {
    console.log("[AutoLocation] Looking for province:", provinceName);
    const [existingProvince] = await db3.select().from(provinces).where(
      sql16`LOWER(${provinces.name}) LIKE LOWER(${`%${provinceName}%`})`
    ).limit(1);
    if (existingProvince) {
      provinceId = existingProvince.id;
      console.log("[AutoLocation] Province found:", existingProvince.name, `(id: ${provinceId})`);
    } else {
      console.warn("[AutoLocation] Province not found for:", provinceName);
    }
  }
  let cityId = null;
  const cityName = components.locality || components.administrative_area_level_2;
  if (cityName && provinceId) {
    console.log("[AutoLocation] Looking for city:", cityName);
    const [existingCity] = await db3.select().from(cities).where(
      and17(
        eq17(cities.provinceId, provinceId),
        sql16`LOWER(${cities.name}) = LOWER(${cityName})`
      )
    ).limit(1);
    if (existingCity) {
      cityId = existingCity.id;
      console.log("[AutoLocation] City found:", existingCity.name, `(id: ${cityId})`);
    } else {
      console.log("[AutoLocation] Auto-creating city:", cityName);
      const citySlug = cityName.toLowerCase().replace(/\s+/g, "-");
      const [result] = await db3.insert(cities).values({
        provinceId,
        name: cityName,
        slug: citySlug,
        latitude: latitude.toString(),
        longitude: longitude.toString(),
        isMetro: 0
      });
      cityId = result.insertId;
      console.log("[AutoLocation] \u2705 City created:", cityName, `(id: ${cityId})`);
    }
  }
  let suburbId = null;
  const suburbName = components.sublocality;
  if (suburbName && cityId) {
    console.log("[AutoLocation] Looking for suburb:", suburbName);
    const [existingSuburb] = await db3.select().from(suburbs).where(
      and17(
        eq17(suburbs.cityId, cityId),
        sql16`LOWER(${suburbs.name}) = LOWER(${suburbName})`
      )
    ).limit(1);
    if (existingSuburb) {
      suburbId = existingSuburb.id;
      console.log("[AutoLocation] Suburb found:", existingSuburb.name, `(id: ${suburbId})`);
    } else {
      console.log("[AutoLocation] Auto-creating suburb:", suburbName);
      const suburbSlug = suburbName.toLowerCase().replace(/\s+/g, "-");
      const [result] = await db3.insert(suburbs).values({
        cityId,
        name: suburbName,
        slug: suburbSlug,
        latitude: latitude.toString(),
        longitude: longitude.toString(),
        postalCode: components.postal_code || null
      });
      suburbId = result.insertId;
      console.log("[AutoLocation] \u2705 Suburb created:", suburbName, `(id: ${suburbId})`);
    }
  }
  console.log("[AutoLocation] Result:", { provinceId, cityId, suburbId });
  return {
    provinceId,
    cityId,
    suburbId
  };
}
function extractPlaceComponents(addressComponents) {
  const components = {};
  for (const component of addressComponents) {
    const types = component.types;
    if (types.includes("locality")) {
      components.locality = component.long_name;
    }
    if (types.includes("sublocality") || types.includes("sublocality_level_1")) {
      components.sublocality = component.long_name;
    }
    if (types.includes("administrative_area_level_1")) {
      components.administrative_area_level_1 = component.long_name;
    }
    if (types.includes("administrative_area_level_2")) {
      components.administrative_area_level_2 = component.long_name;
    }
    if (types.includes("postal_code")) {
      components.postal_code = component.long_name;
    }
  }
  return components;
}

// server/lib/readiness.ts
var calculateListingReadiness = (listing) => {
  const missing = {
    location: [],
    pricing: [],
    media: [],
    description: [],
    specs: []
  };
  let score = 0;
  if (listing.address && listing.latitude && listing.longitude) {
    score += 20;
  } else {
    if (!listing.address) missing.location.push("Address");
    if (!listing.latitude || !listing.longitude) missing.location.push("Map Location");
  }
  if (listing.askingPrice && Number(listing.askingPrice) > 0 || listing.monthlyRent && Number(listing.monthlyRent) > 0) {
    score += 20;
  } else {
    missing.pricing.push("Price");
  }
  let imageCount = 0;
  if (Array.isArray(listing.images)) {
    imageCount = listing.images.length;
  } else if (typeof listing.images === "string") {
    try {
      const parsed = JSON.parse(listing.images);
      if (Array.isArray(parsed)) imageCount = parsed.length;
    } catch (e) {
    }
  }
  if (imageCount >= 5) {
    score += 25;
  } else {
    missing.media.push(`Upload at least 5 images (Current: ${imageCount})`);
  }
  if (listing.description && listing.description.length >= 100) {
    score += 15;
  } else {
    if (!listing.description) missing.description.push("Description");
    else if (listing.description.length < 100) missing.description.push("Description too short (<100 chars)");
  }
  if (listing.propertyType) {
    let details = listing.propertyDetails || {};
    if (typeof details === "string") {
      try {
        details = JSON.parse(details);
      } catch (e) {
      }
    }
    if (details.bedrooms || listing.propertyType === "land" || listing.propertyType === "commercial") {
      score += 20;
    } else {
      missing.specs.push("Bedrooms");
    }
  } else {
    missing.specs.push("Property Type");
  }
  return { score, missing };
};

// server/lib/quality.ts
function calculateListingQualityScore(listing) {
  const images = listing.images || listing.media?.filter((m) => m.type === "image" || m.mediaType === "image") || [];
  const videos2 = listing.videos || listing.media?.filter((m) => m.type === "video" || m.mediaType === "video") || [];
  const description = listing.description || "";
  const descLength = description.length;
  const features = listing.features || listing.propertyHighlights || listing.amenities || [];
  const featureCount = Array.isArray(features) ? features.length : 0;
  const hasFloorSize = !!(listing.floorSize || listing.propertySize || listing.erfSize);
  const priceClarity = listing.price > 0 || listing.askingPrice > 0 || listing.monthlyRent > 0;
  const locationAccuracy = !!(listing.latitude && listing.longitude);
  const isVerifiedAgent = listing.isVerifiedAgent === true || listing.agent?.verificationStatus === "verified";
  const isExclusive = listing.isExclusive === true || listing.mandateType === "exclusive";
  const hasVirtualTour = !!listing.virtualTourUrl || videos2.some((v) => v.isVirtualTour);
  const hasVideo = videos2.length > 0;
  const imageCount = images.length;
  let score = 0;
  const tips = [];
  if (imageCount >= 5) score += 15;
  if (imageCount >= 10) score += 10;
  if (imageCount < 5) tips.push(`Add ${5 - imageCount} more photos to reach the minimum recommended standard.`);
  else if (imageCount < 10) tips.push(`Add ${10 - imageCount} more photos to improve your gallery score.`);
  const hasMix = imageCount >= 5;
  if (hasMix) score += 10;
  if (hasVideo || hasVirtualTour) {
    score += 5;
  } else {
    tips.push("Add a video or virtual tour to engage more buyers.");
  }
  if (descLength >= 300) score += 10;
  if (descLength >= 500) score += 10;
  if (descLength < 300) tips.push("Expand your description to at least 300 characters.");
  else if (descLength < 500) tips.push("Add more detail to your description (500+ characters recommended).");
  if (featureCount >= 5) {
    score += 5;
  } else {
    tips.push("List at least 5 key features or amenities.");
  }
  if (hasFloorSize) score += 5;
  else tips.push("Add property floor size or erf size.");
  if (priceClarity) score += 10;
  else tips.push("Ensure price is clearly listed.");
  if (locationAccuracy) score += 5;
  else tips.push("Pinpoint exact location on the map.");
  if (isVerifiedAgent) score += 5;
  if (isExclusive) score += 5;
  const trustSignals = [];
  if (isVerifiedAgent) trustSignals.push("Verified Agent");
  if (isExclusive) trustSignals.push("Exclusive Mandate");
  score = Math.min(100, score);
  return {
    score,
    breakdown: {
      imageCount,
      hasVideo,
      descriptionLength: descLength,
      featureCount,
      hasVirtualTour,
      trustSignals,
      priceClarity,
      locationAccuracy,
      floorSizePresent: hasFloorSize
    },
    tips
  };
}

// server/listingRouter.ts
var listingActionSchema = z14.enum(["sell", "rent", "auction"]);
var propertyTypeSchema = z14.enum([
  "apartment",
  "house",
  "farm",
  "land",
  "commercial",
  "shared_living"
]);
var createListingSchema = z14.object({
  action: listingActionSchema,
  propertyType: propertyTypeSchema,
  title: z14.string().min(10).max(255),
  description: z14.string().min(50).max(5e3),
  pricing: z14.object({
    // Sell fields
    askingPrice: z14.number().optional(),
    negotiable: z14.boolean().optional(),
    transferCostEstimate: z14.number().nullable().optional(),
    // Rent fields
    monthlyRent: z14.number().optional(),
    deposit: z14.number().optional(),
    leaseTerms: z14.string().optional(),
    availableFrom: z14.date().optional(),
    utilitiesIncluded: z14.boolean().optional(),
    // Auction fields
    startingBid: z14.number().optional(),
    reservePrice: z14.number().optional(),
    auctionDateTime: z14.date().optional(),
    auctionTermsDocumentUrl: z14.string().optional()
  }),
  propertyDetails: z14.record(z14.string(), z14.any()),
  location: z14.object({
    address: z14.string(),
    latitude: z14.number(),
    longitude: z14.number(),
    city: z14.string(),
    suburb: z14.string().optional(),
    province: z14.string(),
    postalCode: z14.string().optional(),
    placeId: z14.string().optional(),
    // Google Places address components for auto-population
    addressComponents: z14.array(z14.object({
      long_name: z14.string(),
      short_name: z14.string(),
      types: z14.array(z14.string())
    })).optional()
  }),
  // Use string IDs only
  mediaIds: z14.array(z14.string()),
  // Use string ID or undefined
  mainMediaId: z14.string().optional().nullable(),
  status: z14.enum(["draft", "pending_review"]).optional()
});
var listingRouter = router({
  /**
   * Create new listing
   */
  create: protectedProcedure.input(createListingSchema).mutation(async ({ ctx, input }) => {
    const userId = ctx.user?.id;
    if (!userId) {
      throw new TRPCError5({ code: "UNAUTHORIZED" });
    }
    try {
      const timestamp2 = Date.now().toString(36);
      const slug = input.title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") + `-${timestamp2}`;
      const media = input.mediaIds.map((id, index2) => {
        const stringId = id;
        return {
          id: stringId,
          // S3 key
          url: stringId,
          // For now, use the ID as the URL (it's already the S3 key)
          type: "image",
          // Default to image; adjust if you have type info
          displayOrder: index2,
          isPrimary: input.mainMediaId ? stringId === input.mainMediaId : index2 === 0,
          processingStatus: "completed",
          // Initialize optional fields for db.createListing
          thumbnailUrl: null,
          fileName: null,
          fileSize: null,
          width: null,
          height: null,
          duration: null,
          orientation: null
        };
      });
      let provinceId = null;
      let cityId = null;
      let suburbId = null;
      let locationId;
      if (input.location.placeId && input.location.addressComponents) {
        try {
          console.log("[ListingRouter] Auto-populating location from Google Places...");
          const components = extractPlaceComponents(input.location.addressComponents);
          const locationIds = await autoCreateLocationHierarchy({
            placeId: input.location.placeId,
            formattedAddress: input.location.address,
            latitude: input.location.latitude,
            longitude: input.location.longitude,
            components
          });
          provinceId = locationIds.provinceId;
          cityId = locationIds.cityId;
          suburbId = locationIds.suburbId;
          console.log("[ListingRouter] \u2705 Auto-populated:", {
            provinceId,
            cityId,
            suburbId
          });
        } catch (error) {
          console.error("[ListingRouter] Auto-population failed:", error);
        }
      }
      if (!cityId) {
        try {
          const { locationPagesServiceEnhanced: locationPagesServiceEnhanced2 } = await Promise.resolve().then(() => (init_locationPagesServiceEnhanced(), locationPagesServiceEnhanced_exports));
          const location = await locationPagesServiceEnhanced2.resolveLocation(input.location);
          locationId = location.id;
          console.log("[ListingRouter] Fallback: Resolved location:", location.name, `(ID: ${locationId})`);
        } catch (error) {
          console.warn("[ListingRouter] Location resolution failed, proceeding without location_id:", error);
        }
      }
      const listingId = await createListing({
        userId,
        action: input.action,
        propertyType: input.propertyType,
        title: input.title,
        description: input.description,
        pricing: input.pricing,
        propertyDetails: input.propertyDetails,
        address: input.location.address,
        latitude: input.location.latitude,
        longitude: input.location.longitude,
        city: input.location.city,
        suburb: input.location.suburb,
        province: input.location.province,
        postalCode: input.location.postalCode,
        placeId: input.location.placeId,
        locationId,
        // Legacy: Link to locations table (if resolved)
        provinceId,
        // New: Auto-populated province ID
        cityId,
        // New: Auto-populated city ID  
        suburbId,
        // New: Auto-populated suburb ID
        slug,
        media
      });
      const listingData = { ...input, media };
      const readiness = calculateListingReadiness(listingData);
      await updateListing(listingId, { readinessScore: readiness.score });
      const canonicalUrl = `/listings/${slug}`;
      return {
        id: listingId,
        slug,
        status: "draft",
        canonicalUrl,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      console.error("Error creating listing:", error);
      if (error instanceof TRPCError5) {
        throw error;
      }
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      console.error("Detailed error message:", errorMessage);
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: `Failed to create listing: ${errorMessage}`,
        cause: error
      });
    }
  }),
  /**
   * Update existing listing
   */
  update: protectedProcedure.input(
    z14.object({
      id: z14.number(),
      ...createListingSchema.partial().shape
    })
  ).mutation(async ({ ctx, input }) => {
    const userId = ctx.user?.id;
    if (!userId) {
      throw new TRPCError5({ code: "UNAUTHORIZED" });
    }
    try {
      const listing = await getListingById(input.id);
      if (!listing || listing.userId !== userId) {
        throw new TRPCError5({
          code: "FORBIDDEN",
          message: "Not authorized to update this listing"
        });
      }
      await updateListing(input.id, {
        ...input,
        updatedAt: /* @__PURE__ */ new Date()
      });
      const fullListing = await getListingById(input.id);
      const media = await getListingMedia(input.id);
      const listingData = { ...fullListing, ...input, media };
      const readiness = calculateListingReadiness(listingData);
      const quality = calculateListingQualityScore(listingData);
      await updateListing(input.id, {
        readinessScore: readiness.score,
        qualityScore: quality.score,
        qualityBreakdown: quality.breakdown
      });
      return { success: true };
    } catch (error) {
      console.error("Error updating listing:", error);
      throw new TRPCError5({ code: "INTERNAL_SERVER_ERROR", message: "Failed to update listing" });
    }
  }),
  /**
   * Get listing by ID
   */
  getById: publicProcedure.input(z14.object({ id: z14.number() })).query(async ({ input }) => {
    try {
      const listing = await getListingById(input.id);
      if (!listing) {
        throw new TRPCError5({ code: "NOT_FOUND", message: "Listing not found" });
      }
      const media = await getListingMedia(input.id);
      const analytics = await getListingAnalytics(input.id);
      return {
        ...listing,
        media,
        analytics
      };
    } catch (error) {
      console.error("Error fetching listing:", error);
      if (error instanceof TRPCError5) throw error;
      throw new TRPCError5({ code: "INTERNAL_SERVER_ERROR", message: "Failed to fetch listing" });
    }
  }),
  /**
   * Get user's listings
   */
  myListings: protectedProcedure.input(
    z14.object({
      status: z14.enum(["draft", "pending_review", "approved", "published", "rejected", "archived"]).optional(),
      limit: z14.number().default(20),
      offset: z14.number().default(0)
    })
  ).query(async ({ ctx, input }) => {
    const userId = ctx.user?.id;
    if (!userId) {
      throw new TRPCError5({ code: "UNAUTHORIZED" });
    }
    try {
      const listings2 = await getUserListings(userId, input.status, input.limit, input.offset);
      return listings2;
    } catch (error) {
      console.error("Error fetching user listings:", error);
      throw new TRPCError5({ code: "INTERNAL_SERVER_ERROR", message: "Failed to fetch listings" });
    }
  }),
  /**
   * Archive listing
   */
  archive: protectedProcedure.input(z14.object({ id: z14.number() })).mutation(async ({ ctx, input }) => {
    const userId = ctx.user?.id;
    if (!userId) {
      throw new TRPCError5({ code: "UNAUTHORIZED" });
    }
    try {
      const listing = await getListingById(input.id);
      if (!listing || listing.userId !== userId) {
        throw new TRPCError5({
          code: "FORBIDDEN",
          message: "Not authorized to archive this listing"
        });
      }
      await archiveListing(input.id);
      return { success: true };
    } catch (error) {
      console.error("Error archiving listing:", error);
      throw new TRPCError5({ code: "INTERNAL_SERVER_ERROR", message: "Failed to archive listing" });
    }
  }),
  /**
   * Delete listing
   */
  delete: protectedProcedure.input(z14.object({ id: z14.number() })).mutation(async ({ ctx, input }) => {
    const userId = ctx.user?.id;
    if (!userId) {
      throw new TRPCError5({ code: "UNAUTHORIZED" });
    }
    try {
      const listing = await getListingById(input.id);
      if (!listing) {
        throw new TRPCError5({ code: "NOT_FOUND", message: "Listing not found" });
      }
      const isOwner = listing.userId === userId;
      const isSuperAdmin = ctx.user.role === "super_admin";
      if (!isOwner && !isSuperAdmin) {
        throw new TRPCError5({
          code: "FORBIDDEN",
          message: "Not authorized to delete this listing"
        });
      }
      await deleteListing(input.id);
      return { success: true };
    } catch (error) {
      console.error("Error deleting listing:", error);
      if (error instanceof TRPCError5) {
        throw error;
      }
      const errorMessage = error instanceof Error ? error.message : "Failed to delete listing";
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: errorMessage,
        cause: error
      });
    }
  }),
  /**
   * Upload media for listing
   */
  uploadMedia: protectedProcedure.input(
    z14.object({
      listingId: z14.number().optional(),
      type: z14.enum(["image", "video", "floorplan", "pdf"]),
      filename: z14.string(),
      contentType: z14.string()
    })
  ).mutation(async ({ ctx, input }) => {
    try {
      const { generatePresignedUploadUrl: generatePresignedUploadUrl2 } = await Promise.resolve().then(() => (init_imageUpload(), imageUpload_exports));
      const result = await generatePresignedUploadUrl2(
        input.filename,
        input.contentType,
        input.listingId?.toString() || "draft"
      );
      const { ENV: ENV2 } = await Promise.resolve().then(() => (init_env(), env_exports));
      const cdnUrl = ENV2.cloudFrontUrl || `https://${ENV2.s3BucketName}.s3.${ENV2.awsRegion}.amazonaws.com`;
      const publicUrl = `${cdnUrl}/${result.key}`;
      return {
        uploadUrl: result.uploadUrl,
        mediaId: result.key,
        // Use the S3 key as media ID
        publicUrl
      };
    } catch (error) {
      console.error("Error generating media upload URL:", error);
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to generate upload URL"
      });
    }
  }),
  /**
   * Get listing analytics
   */
  getAnalytics: protectedProcedure.input(z14.object({ listingId: z14.number() })).query(async ({ ctx, input }) => {
    try {
      const listing = await getListingById(input.listingId);
      if (!listing) {
        throw new TRPCError5({ code: "NOT_FOUND", message: "Listing not found" });
      }
      const analytics = await getListingAnalytics(input.listingId);
      if (!analytics) {
        return {
          totalViews: 0,
          uniqueVisitors: 0,
          totalLeads: 0,
          contactFormLeads: 0,
          whatsappClicks: 0,
          phoneReveals: 0,
          bookingViewingRequests: 0,
          totalFavorites: 0,
          totalShares: 0,
          conversionRate: 0,
          viewsByDay: {},
          trafficSources: {
            direct: 0,
            organic: 0,
            social: 0,
            referral: 0,
            email: 0,
            paid: 0
          }
        };
      }
      return analytics;
    } catch (error) {
      console.error("Error fetching analytics:", error);
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to fetch analytics"
      });
    }
  }),
  /**
   * Get listing leads
   */
  getLeads: protectedProcedure.input(
    z14.object({
      listingId: z14.number(),
      limit: z14.number().default(50),
      offset: z14.number().default(0)
    })
  ).query(async ({ ctx, input }) => {
    try {
      const listing = await getListingById(input.listingId);
      if (!listing) {
        throw new TRPCError5({ code: "NOT_FOUND", message: "Listing not found" });
      }
      return {
        leads: [],
        total: 0
      };
    } catch (error) {
      console.error("Error fetching leads:", error);
      throw new TRPCError5({ code: "INTERNAL_SERVER_ERROR", message: "Failed to fetch leads" });
    }
  }),
  /**
   * Submit listing for review (manual approval)
   */
  submitForReview: protectedProcedure.input(z14.object({ listingId: z14.number() })).mutation(async ({ ctx, input }) => {
    try {
      const listing = await getListingById(input.listingId);
      if (!listing || listing.userId !== ctx.user?.id) {
        throw new TRPCError5({
          code: "FORBIDDEN",
          message: "Not authorized to submit this listing"
        });
      }
      const fullListing = await getListingById(input.listingId);
      const media = await getListingMedia(input.listingId);
      const readiness = calculateListingReadiness({ ...fullListing, media });
      if (readiness.score < 75) {
        throw new TRPCError5({
          code: "PRECONDITION_FAILED",
          message: `Listing is not ready for submission (${readiness.score}%). Please complete missing fields.`
        });
      }
      const quality = calculateListingQualityScore({ ...fullListing, media });
      const agent = await getAgentByUserId(ctx.user.id);
      const isTrusted = agent?.isVerified === 1;
      if (readiness.score === 100 && quality.score >= 85 && isTrusted) {
        await approveListing(input.listingId, ctx.user.id, "Fast-Track Auto Approval (High Quality & Trusted)");
        return { success: true, status: "approved", fastTracked: true };
      }
      await submitListingForReview(input.listingId);
      return { success: true, status: "pending_review" };
    } catch (error) {
      console.error("Error submitting for review:", error);
      if (error instanceof TRPCError5) throw error;
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to submit for review"
      });
    }
  }),
  /**
   * Promote/Feature a listing (Soft Monetization Hook)
   * Requires Quality Score >= 85
   */
  promote: protectedProcedure.input(z14.object({
    listingId: z14.number(),
    featured: z14.boolean()
  })).mutation(async ({ ctx, input }) => {
    try {
      const listing = await getListingById(input.listingId);
      if (!listing) throw new TRPCError5({ code: "NOT_FOUND", message: "Listing not found" });
      const isOwner = listing.userId === ctx.user?.id;
      const isSuperAdmin = ctx.user?.role === "super_admin";
      if (!isOwner && !isSuperAdmin) {
        throw new TRPCError5({ code: "FORBIDDEN", message: "Not authorized" });
      }
      if (input.featured) {
        const qualityScore = listing.qualityScore || 0;
        if (qualityScore < 85 && !isSuperAdmin) {
          throw new TRPCError5({
            code: "PRECONDITION_FAILED",
            message: `Listing Quality Score must be at least 85 to be Featured. Current score: ${qualityScore}.`
          });
        }
      }
      await updateListing(input.listingId, { featured: input.featured ? 1 : 0 });
      return { success: true };
    } catch (error) {
      console.error("Error promoting listing:", error);
      if (error instanceof TRPCError5) throw error;
      throw new TRPCError5({ code: "INTERNAL_SERVER_ERROR", message: "Failed to update promotion status" });
    }
  }),
  /**
   * Approve listing (Super Admin only)
   */
  approve: protectedProcedure.input(
    z14.object({
      listingId: z14.number(),
      notes: z14.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    if (ctx.user?.role !== "super_admin") {
      throw new TRPCError5({ code: "FORBIDDEN" });
    }
    try {
      await approveListing(input.listingId, ctx.user.id, input.notes);
      return { success: true };
    } catch (error) {
      console.error("Error approving listing:", error);
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to approve listing"
      });
    }
  }),
  /**
   * Reject listing (Super Admin only)
   */
  reject: protectedProcedure.input(
    z14.object({
      listingId: z14.number(),
      reason: z14.string().optional(),
      // Now optional as we use reasons array primarily
      reasons: z14.array(z14.string()).optional(),
      note: z14.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    if (ctx.user?.role !== "super_admin") {
      throw new TRPCError5({ code: "FORBIDDEN" });
    }
    try {
      await rejectListing(input.listingId, ctx.user.id, input.reason || "See rejection reasons", input.reasons, input.note);
      return { success: true };
    } catch (error) {
      console.error("Error rejecting listing:", error);
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to reject listing"
      });
    }
  }),
  /**
   * Get approval queue (Super Admin only)
   */
  getApprovalQueue: protectedProcedure.input(
    z14.object({
      status: z14.enum(["pending", "reviewing", "approved", "rejected"]).optional(),
      limit: z14.number().default(50),
      offset: z14.number().default(0)
    })
  ).query(async ({ ctx, input }) => {
    if (ctx.user?.role !== "super_admin") {
      throw new TRPCError5({ code: "FORBIDDEN" });
    }
    try {
      const queueItems = await getApprovalQueue(input.status);
      return queueItems.slice(input.offset, input.offset + input.limit);
    } catch (error) {
      console.error("Error fetching approval queue:", error);
      throw new TRPCError5({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to fetch approval queue"
      });
    }
  })
});

// server/uploadRouter.ts
import { z as z15 } from "zod";
init_imageUpload();
init_env();
import crypto5 from "crypto";
var uploadRouter = router({
  /**
   * Generate presigned URL for direct S3 upload
   * This allows the client to upload directly to S3 without going through the server
   */
  presign: protectedProcedure.input(
    z15.object({
      filename: z15.string(),
      contentType: z15.string(),
      propertyId: z15.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    try {
      const propertyId = input.propertyId || crypto5.randomUUID();
      const result = await generatePresignedUploadUrl(
        input.filename,
        input.contentType,
        propertyId
      );
      const cdnUrl = ENV.cloudFrontUrl || `https://${ENV.s3BucketName}.s3.${ENV.awsRegion}.amazonaws.com`;
      const publicUrl = `${cdnUrl}/${result.key}`;
      return {
        url: result.uploadUrl,
        key: result.key,
        publicUrl
      };
    } catch (error) {
      console.error("Failed to generate presigned URL:", error);
      throw new Error("Failed to generate upload URL. Please check your AWS configuration.");
    }
  })
});

// server/savedSearchRouter.ts
import { z as z16 } from "zod";
init_db();
init_schema();
import { TRPCError as TRPCError6 } from "@trpc/server";
import { eq as eq19, desc as desc14, and as and19 } from "drizzle-orm";
var savedSearchRouter = router({
  create: protectedProcedure.input(
    z16.object({
      name: z16.string().min(1).max(255),
      criteria: z16.record(z16.any()),
      // JSON object for filters
      notificationFrequency: z16.string().refine((val) => ["never", "daily", "weekly"].includes(val)).default("never")
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError6({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    await db3.insert(savedSearches).values({
      userId: ctx.user.id,
      name: input.name,
      criteria: input.criteria,
      notificationFrequency: input.notificationFrequency
    });
    return { success: true };
  }),
  getAll: protectedProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError6({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    const searches = await db3.select().from(savedSearches).where(eq19(savedSearches.userId, ctx.user.id)).orderBy(desc14(savedSearches.createdAt));
    return searches;
  }),
  delete: protectedProcedure.input(z16.object({ id: z16.number() })).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError6({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
    const search = await db3.select().from(savedSearches).where(and19(eq19(savedSearches.id, input.id), eq19(savedSearches.userId, ctx.user.id))).limit(1);
    if (search.length === 0) {
      throw new TRPCError6({ code: "NOT_FOUND", message: "Saved search not found" });
    }
    await db3.delete(savedSearches).where(eq19(savedSearches.id, input.id));
    return { success: true };
  })
});

// server/guestMigrationRouter.ts
import { z as z17 } from "zod";
init_db();
init_schema();
import { TRPCError as TRPCError7 } from "@trpc/server";
var guestMigrationRouter = router({
  // Migrate guest activity data to user account
  migrateGuestData: protectedProcedure.input(
    z17.object({
      viewedProperties: z17.array(z17.number()).optional(),
      favoriteProperties: z17.array(z17.number()).optional()
    })
  ).mutation(async ({ input, ctx }) => {
    const userId = ctx.user.id;
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    try {
      if (input.viewedProperties && input.viewedProperties.length > 0) {
        const viewedRecords = input.viewedProperties.map((propertyId) => ({
          userId,
          propertyId,
          viewedAt: /* @__PURE__ */ new Date()
        }));
        for (const record of viewedRecords) {
          try {
            await db3.insert(recentlyViewed).values(record);
          } catch (error) {
            console.log(`Property ${record.propertyId} already in recently viewed`);
          }
        }
      }
      if (input.favoriteProperties && input.favoriteProperties.length > 0) {
        const favoriteRecords = input.favoriteProperties.map((propertyId) => ({
          userId,
          propertyId,
          createdAt: /* @__PURE__ */ new Date()
        }));
        for (const record of favoriteRecords) {
          try {
            await db3.insert(favorites).values(record);
          } catch (error) {
            console.log(`Property ${record.propertyId} already in favorites`);
          }
        }
      }
      return {
        success: true,
        migratedViews: input.viewedProperties?.length || 0,
        migratedFavorites: input.favoriteProperties?.length || 0
      };
    } catch (error) {
      console.error("Guest migration error:", error);
      throw new TRPCError7({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to migrate guest data"
      });
    }
  })
});

// server/settingsRouter.ts
init_db();
init_schema();
import { eq as eq20 } from "drizzle-orm";
var settingsRouter = router({
  /**
   * Get public platform settings
   * Returns key-value pairs for public settings
   */
  getPublic: publicProcedure.query(async () => {
    const db3 = await getDb();
    if (!db3) {
      return {
        sarb_prime_rate: "10.50",
        sarb_repo_rate: "7.00"
      };
    }
    try {
      const settings = await db3.select().from(platformSettings).where(eq20(platformSettings.isPublic, 1));
      const settingsObj = {};
      settings.forEach((setting) => {
        settingsObj[setting.settingKey] = setting.settingValue || "";
      });
      return {
        sarb_prime_rate: settingsObj.sarb_prime_rate || "10.50",
        sarb_repo_rate: settingsObj.sarb_repo_rate || "7.00",
        ...settingsObj
      };
    } catch (error) {
      console.error("[Settings] Error fetching public settings:", error);
      return {
        sarb_prime_rate: "10.50",
        sarb_repo_rate: "7.00"
      };
    }
  }),
  /**
   * Get SARB Prime Rate
   * Convenience endpoint for getting just the prime rate
   */
  getSARBPrimeRate: publicProcedure.query(async () => {
    const db3 = await getDb();
    if (!db3) {
      return { rate: 10.5, lastUpdated: null };
    }
    try {
      const result = await db3.select().from(platformSettings).where(eq20(platformSettings.settingKey, "sarb_prime_rate")).limit(1);
      if (result.length > 0) {
        return {
          rate: parseFloat(result[0].settingValue || "10.50"),
          lastUpdated: result[0].updatedAt
        };
      }
      return { rate: 10.5, lastUpdated: null };
    } catch (error) {
      console.error("[Settings] Error fetching SARB prime rate:", error);
      return { rate: 10.5, lastUpdated: null };
    }
  })
});

// server/marketingRouter.ts
import { z as z18 } from "zod";
init_db();
import { eq as eq22, desc as desc15, and as and21 } from "drizzle-orm";
var marketingCampaigns3 = {};
var campaignTargeting = {};
var campaignBudgets3 = {};
var campaignSchedules = {};
var campaignChannels2 = {};
var campaignCreatives = {};
var campaignPerformance = {};
var marketingRouter = router({
  /**
   * Create a new campaign (Draft)
   */
  createCampaign: protectedProcedure.input(
    z18.object({
      campaignName: z18.string(),
      campaignType: z18.enum(["listing_boost", "lead_generation", "brand_awareness", "development_launch", "agent_promotion"]),
      ownerType: z18.enum(["agent", "developer", "agency"]),
      ownerId: z18.number(),
      targetType: z18.enum(["listing", "development", "agent_profile", "agency_page"]),
      targetId: z18.number(),
      description: z18.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const [result] = await db3.insert(marketingCampaigns3).values({
      ...input,
      status: "draft"
    });
    const campaignId = result.insertId;
    await Promise.all([
      db3.insert(campaignTargeting).values({ campaignId }),
      db3.insert(campaignBudgets3).values({
        campaignId,
        budgetType: "daily",
        budgetAmount: "0.00",
        billingMethod: "ppc"
      }),
      db3.insert(campaignSchedules).values({
        campaignId,
        startDate: (/* @__PURE__ */ new Date()).toISOString(),
        frequency: "one_time"
      }),
      db3.insert(campaignChannels2).values({
        campaignId,
        type: "feed",
        enabled: false
      }),
      db3.insert(campaignCreatives).values({ campaignId })
    ]);
    return { campaignId };
  }),
  /**
   * Get full campaign details
   */
  getCampaign: protectedProcedure.input(z18.object({ campaignId: z18.number() })).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const campaign = await db3.query.marketingCampaigns.findFirst({
      where: eq22(marketingCampaigns3.id, input.campaignId)
    });
    if (!campaign) throw new Error("Campaign not found");
    const [targeting, budget, schedule, channels, creative, performance] = await Promise.all([
      db3.query.campaignTargeting.findFirst({ where: eq22(campaignTargeting.campaignId, input.campaignId) }),
      db3.query.campaignBudgets.findFirst({ where: eq22(campaignBudgets3.campaignId, input.campaignId) }),
      db3.query.campaignSchedules.findFirst({ where: eq22(campaignSchedules.campaignId, input.campaignId) }),
      db3.query.campaignChannels.findMany({ where: eq22(campaignChannels2.campaignId, input.campaignId) }),
      db3.query.campaignCreatives.findFirst({ where: eq22(campaignCreatives.campaignId, input.campaignId) }),
      db3.query.campaignPerformance.findMany({ where: eq22(campaignPerformance.campaignId, input.campaignId) })
    ]);
    return {
      campaign,
      targeting,
      budget,
      schedule,
      channels,
      creative,
      performance
    };
  }),
  /**
   * List campaigns for an owner (or all for admin)
   */
  listCampaigns: protectedProcedure.input(
    z18.object({
      ownerType: z18.enum(["agent", "developer", "agency"]).optional(),
      ownerId: z18.number().optional(),
      status: z18.enum(["draft", "active", "paused", "completed", "scheduled"]).optional()
    })
  ).query(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const conditions = [];
    if (input.ownerType && input.ownerId) {
      conditions.push(eq22(marketingCampaigns3.ownerType, input.ownerType));
      conditions.push(eq22(marketingCampaigns3.ownerId, input.ownerId));
    }
    if (input.status) {
      conditions.push(eq22(marketingCampaigns3.status, input.status));
    }
    const campaigns = await db3.select().from(marketingCampaigns3).where(and21(...conditions)).orderBy(desc15(marketingCampaigns3.createdAt));
    return campaigns;
  }),
  /**
   * Update campaign details
   */
  updateCampaign: protectedProcedure.input(
    z18.object({
      campaignId: z18.number(),
      data: z18.object({
        campaignName: z18.string().optional(),
        description: z18.string().optional(),
        status: z18.enum(["draft", "active", "paused", "completed", "scheduled"]).optional()
      })
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await db3.update(marketingCampaigns3).set(input.data).where(eq22(marketingCampaigns3.id, input.campaignId));
    return { success: true };
  }),
  /**
   * Update Targeting
   */
  updateTargeting: protectedProcedure.input(
    z18.object({
      campaignId: z18.number(),
      targeting: z18.object({
        locationTargeting: z18.array(z18.string()).optional(),
        buyerProfile: z18.array(z18.string()).optional(),
        priceRange: z18.object({ min: z18.number(), max: z18.number() }).optional(),
        propertyType: z18.array(z18.string()).optional(),
        customTags: z18.array(z18.string()).optional()
      })
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await db3.update(campaignTargeting).set(input.targeting).where(eq22(campaignTargeting.campaignId, input.campaignId));
    return { success: true };
  }),
  /**
   * Update Budget
   */
  updateBudget: protectedProcedure.input(
    z18.object({
      campaignId: z18.number(),
      budget: z18.object({
        budgetType: z18.enum(["daily", "lifetime", "subscription"]).optional(),
        budgetAmount: z18.number().optional(),
        billingMethod: z18.enum(["ppc", "ppv", "per_lead", "per_boost", "flat_fee"]).optional()
      })
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const updateData = { ...input.budget };
    if (input.budget.budgetAmount !== void 0) {
      updateData.budgetAmount = input.budget.budgetAmount.toString();
    }
    await db3.update(campaignBudgets3).set(updateData).where(eq22(campaignBudgets3.campaignId, input.campaignId));
    return { success: true };
  }),
  /**
   * Update Schedule
   */
  updateSchedule: protectedProcedure.input(
    z18.object({
      campaignId: z18.number(),
      schedule: z18.object({
        startDate: z18.string().optional(),
        endDate: z18.string().optional().nullable(),
        autoPace: z18.boolean().optional(),
        frequency: z18.enum(["one_time", "weekly", "monthly"]).optional()
      })
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await db3.update(campaignSchedules).set(input.schedule).where(eq22(campaignSchedules.campaignId, input.campaignId));
    return { success: true };
  }),
  /**
   * Update Channels
   */
  updateChannels: protectedProcedure.input(
    z18.object({
      campaignId: z18.number(),
      channels: z18.array(z18.object({
        type: z18.enum(["feed", "search", "carousel", "email", "push", "showcase", "retargeting"]),
        enabled: z18.boolean()
      }))
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    for (const channel of input.channels) {
      const existing = await db3.query.campaignChannels.findFirst({
        where: and21(
          eq22(campaignChannels2.campaignId, input.campaignId),
          eq22(campaignChannels2.type, channel.type)
        )
      });
      if (existing) {
        await db3.update(campaignChannels2).set({ enabled: channel.enabled }).where(eq22(campaignChannels2.id, existing.id));
      } else {
        await db3.insert(campaignChannels2).values({
          campaignId: input.campaignId,
          type: channel.type,
          enabled: channel.enabled
        });
      }
    }
    return { success: true };
  }),
  /**
   * Update Creative
   */
  updateCreative: protectedProcedure.input(
    z18.object({
      campaignId: z18.number(),
      creative: z18.object({
        images: z18.array(z18.string()).optional(),
        videos: z18.array(z18.string()).optional(),
        headlines: z18.array(z18.string()).optional(),
        descriptions: z18.array(z18.string()).optional(),
        cta: z18.enum(["view_listing", "book_viewing", "contact_agent", "download_brochure", "pre_qualify"]).optional()
      })
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    await db3.update(campaignCreatives).set(input.creative).where(eq22(campaignCreatives.campaignId, input.campaignId));
    return { success: true };
  }),
  /**
   * Launch Campaign (Process Payment & Activate)
   */
  launchCampaign: protectedProcedure.input(
    z18.object({
      campaignId: z18.number(),
      paymentMethodId: z18.string().optional()
    })
  ).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new Error("Database not available");
    const campaign = await db3.query.marketingCampaigns.findFirst({
      where: eq22(marketingCampaigns3.id, input.campaignId)
    });
    if (!campaign) throw new Error("Campaign not found");
    const schedule = await db3.query.campaignSchedules.findFirst({
      where: eq22(campaignSchedules.campaignId, input.campaignId)
    });
    let newStatus = "active";
    if (schedule?.startDate && new Date(schedule.startDate) > /* @__PURE__ */ new Date()) {
      newStatus = "scheduled";
    }
    await db3.update(marketingCampaigns3).set({ status: newStatus }).where(eq22(marketingCampaigns3.id, input.campaignId));
    try {
      const { recordCampaignTransaction: recordCampaignTransaction2 } = await Promise.resolve().then(() => (init_revenueCenterSync(), revenueCenterSync_exports));
      const budget = await db3.query.campaignBudgets.findFirst({
        where: eq22(campaignBudgets3.campaignId, input.campaignId)
      });
      if (budget && Number(budget.budgetAmount) > 0) {
        let agencyId = 0;
        if (campaign.ownerType === "agency") agencyId = campaign.ownerId;
        await recordCampaignTransaction2({
          campaignId: campaign.id,
          agencyId,
          amount: Number(budget.budgetAmount) * 100,
          // Convert to cents if budget is in currency
          description: `Campaign Launch: ${campaign.campaignName}`,
          metadata: { mockPayment: true, paymentMethodId: input.paymentMethodId }
        });
      }
    } catch (err) {
      console.error("Failed to sync campaign launch to Revenue Center:", err);
    }
    return { success: true, status: newStatus };
  })
});

// server/subscriptionRouter.ts
import { z as z19 } from "zod";
import { TRPCError as TRPCError8 } from "@trpc/server";

// server/services/subscriptionService.ts
init_db();
async function getAllPlans(category) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  let query = "SELECT * FROM subscription_plans WHERE is_active = 1";
  const params = [];
  if (category) {
    query += " AND category = ?";
    params.push(category);
  }
  query += " ORDER BY sort_order ASC";
  const [rows] = await db3.execute(query, params);
  return rows.map(parseSubscriptionPlan);
}
async function getPlanByPlanId(planId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [rows] = await db3.execute("SELECT * FROM subscription_plans WHERE plan_id = ?", [planId]);
  const plans2 = rows;
  return plans2.length > 0 ? parseSubscriptionPlan(plans2[0]) : null;
}
async function getTrialPlan(category) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [rows] = await db3.execute(
    "SELECT * FROM subscription_plans WHERE category = ? AND is_trial_plan = 1 AND is_active = 1",
    [category]
  );
  const plans2 = rows;
  return plans2.length > 0 ? parseSubscriptionPlan(plans2[0]) : null;
}
async function getUserSubscription(userId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const [rows] = await db3.execute("SELECT * FROM user_subscriptions WHERE user_id = ?", [userId]);
  const subscriptions = rows;
  return subscriptions.length > 0 ? parseUserSubscription(subscriptions[0]) : null;
}
async function getUserSubscriptionWithPlan(userId) {
  const subscription = await getUserSubscription(userId);
  if (!subscription) return null;
  const plan = await getPlanByPlanId(subscription.plan_id);
  return { subscription, plan };
}
async function startTrial(userId, category) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const existing = await getUserSubscription(userId);
  if (existing?.trial_used) {
    throw new Error("Trial already used");
  }
  const trialPlan = await getTrialPlan(category);
  if (!trialPlan) {
    throw new Error("No trial plan available for this category");
  }
  const trialStartsAt = /* @__PURE__ */ new Date();
  const trialEndsAt = new Date(trialStartsAt.getTime() + trialPlan.trial_days * 24 * 60 * 60 * 1e3);
  if (existing) {
    await db3.execute(
      `UPDATE user_subscriptions 
       SET plan_id = ?, status = 'trial_active', trial_started_at = ?, trial_ends_at = ?, trial_used = 1, updated_at = NOW()
       WHERE user_id = ?`,
      [trialPlan.plan_id, trialStartsAt, trialEndsAt, userId]
    );
  } else {
    await db3.execute(
      `INSERT INTO user_subscriptions 
       (user_id, plan_id, status, trial_started_at, trial_ends_at, trial_used)
       VALUES (?, ?, 'trial_active', ?, ?, 1)`,
      [userId, trialPlan.plan_id, trialStartsAt, trialEndsAt]
    );
  }
  await logSubscriptionEvent(userId, "trial_started", {
    plan_id: trialPlan.plan_id,
    trial_ends_at: trialEndsAt
  });
  if (trialPlan.permissions.boost_credits && trialPlan.permissions.boost_credits > 0) {
    await initializeBoostCredits(userId, trialPlan.permissions.boost_credits);
  }
  const subscription = await getUserSubscription(userId);
  if (!subscription) throw new Error("Failed to create subscription");
  return subscription;
}
async function expireTrial(userId) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const subscription = await getUserSubscription(userId);
  if (!subscription) return;
  const plan = await getPlanByPlanId(subscription.plan_id);
  if (!plan || !plan.downgrade_to_plan_id) {
    throw new Error("No downgrade plan defined");
  }
  await db3.execute(
    `UPDATE user_subscriptions 
     SET plan_id = ?, status = 'trial_expired', previous_plan_id = ?, updated_at = NOW()
     WHERE user_id = ?`,
    [plan.downgrade_to_plan_id, subscription.plan_id, userId]
  );
  await logSubscriptionEvent(userId, "trial_expired", {
    previous_plan: subscription.plan_id,
    new_plan: plan.downgrade_to_plan_id
  });
  await lockPremiumFeatures(userId);
}
async function upgradeSubscription(userId, newPlanId, immediate = true) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const subscription = await getUserSubscription(userId);
  if (!subscription) throw new Error("No active subscription");
  const newPlan = await getPlanByPlanId(newPlanId);
  if (!newPlan) throw new Error("Plan not found");
  if (immediate) {
    await db3.execute(
      `UPDATE user_subscriptions 
       SET plan_id = ?, status = 'active_paid', previous_plan_id = ?, updated_at = NOW()
       WHERE user_id = ?`,
      [newPlanId, subscription.plan_id, userId]
    );
    await logSubscriptionEvent(userId, "subscription_upgraded", {
      from_plan: subscription.plan_id,
      to_plan: newPlanId
    });
    if (newPlan.permissions.boost_credits) {
      await updateBoostCredits(userId, newPlan.permissions.boost_credits);
    }
  } else {
    await db3.execute(
      `UPDATE user_subscriptions 
       SET downgrade_scheduled = 0, updated_at = NOW()
       WHERE user_id = ?`,
      [userId]
    );
  }
}
async function downgradeSubscription(userId, newPlanId, immediate = false) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const subscription = await getUserSubscription(userId);
  if (!subscription) throw new Error("No active subscription");
  if (immediate) {
    await db3.execute(
      `UPDATE user_subscriptions 
       SET plan_id = ?, status = 'downgraded', previous_plan_id = ?, updated_at = NOW()
       WHERE user_id = ?`,
      [newPlanId, subscription.plan_id, userId]
    );
    await logSubscriptionEvent(userId, "subscription_downgraded", {
      from_plan: subscription.plan_id,
      to_plan: newPlanId
    });
  } else {
    const effectiveDate = subscription.current_period_end || /* @__PURE__ */ new Date();
    await db3.execute(
      `UPDATE user_subscriptions 
       SET downgrade_scheduled = 1, downgrade_to_plan_id = ?, downgrade_effective_date = ?, updated_at = NOW()
       WHERE user_id = ?`,
      [newPlanId, effectiveDate, userId]
    );
  }
}
async function checkFeatureAccess(userId, permission) {
  const subData = await getUserSubscriptionWithPlan(userId);
  if (!subData || !subData.plan) {
    return {
      has_access: false,
      reason: "No active subscription",
      upgrade_required: true
    };
  }
  const { plan } = subData;
  const hasPermission = plan.permissions[permission];
  if (!hasPermission) {
    const upgradePlan = plan.upgrade_to_plan_id ? await getPlanByPlanId(plan.upgrade_to_plan_id) : null;
    return {
      has_access: false,
      reason: `Feature requires ${upgradePlan?.display_name || "upgrade"}`,
      upgrade_required: true,
      recommended_plan: upgradePlan?.plan_id
    };
  }
  return { has_access: true };
}
async function checkLimit(userId, limitType, currentCount) {
  const subData = await getUserSubscriptionWithPlan(userId);
  if (!subData || !subData.plan) {
    return {
      is_allowed: false,
      current_count: currentCount,
      limit: 0,
      remaining: 0,
      is_unlimited: false
    };
  }
  const limit = subData.plan.limits[limitType] || 0;
  if (limit === -1) {
    return {
      is_allowed: true,
      current_count: currentCount,
      limit: -1,
      remaining: -1,
      is_unlimited: true
    };
  }
  const remaining = Math.max(0, limit - currentCount);
  return {
    is_allowed: currentCount < limit,
    current_count: currentCount,
    limit,
    remaining,
    is_unlimited: false
  };
}
async function getUpgradePrompt(userId, blockedFeature) {
  const subData = await getUserSubscriptionWithPlan(userId);
  if (!subData || !subData.plan) return null;
  const { plan } = subData;
  const upgradePlanId = plan.upgrade_to_plan_id;
  if (!upgradePlanId) return null;
  const upgradePlan = await getPlanByPlanId(upgradePlanId);
  if (!upgradePlan) return null;
  const priceDiff = upgradePlan.price_zar - plan.price_zar;
  return {
    title: `Upgrade to ${upgradePlan.display_name}`,
    message: `Unlock ${blockedFeature} and more premium features`,
    feature_blocked: blockedFeature,
    current_plan: plan.display_name,
    recommended_plan: upgradePlan.display_name,
    price_difference: priceDiff,
    benefits: upgradePlan.features,
    cta: `Upgrade for R${(priceDiff / 100).toFixed(2)}/month`
  };
}
async function initializeBoostCredits(userId, credits) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const resetAt = /* @__PURE__ */ new Date();
  resetAt.setMonth(resetAt.getMonth() + 1);
  await db3.execute(
    `INSERT INTO boost_credits (user_id, total_credits, used_credits, reset_at)
     VALUES (?, ?, 0, ?)
     ON DUPLICATE KEY UPDATE total_credits = ?, used_credits = 0, reset_at = ?`,
    [userId, credits, resetAt, credits, resetAt]
  );
}
async function updateBoostCredits(userId, credits) {
  const db3 = await getDb();
  if (!db3) throw new Error("Database not available");
  const resetAt = /* @__PURE__ */ new Date();
  resetAt.setMonth(resetAt.getMonth() + 1);
  await db3.execute(
    `UPDATE boost_credits SET total_credits = ?, reset_at = ?, updated_at = NOW()
     WHERE user_id = ?`,
    [credits, resetAt, userId]
  );
}
async function lockPremiumFeatures(userId) {
  console.log(`Locking premium features for user ${userId}`);
}
async function logSubscriptionEvent(userId, eventType, eventData) {
  const db3 = await getDb();
  if (!db3) return;
  const subscription = await getUserSubscription(userId);
  await db3.execute(
    `INSERT INTO subscription_events (user_id, subscription_id, event_type, event_data)
     VALUES (?, ?, ?, ?)`,
    [userId, subscription?.id || null, eventType, JSON.stringify(eventData || {})]
  );
}
function parseSubscriptionPlan(row) {
  return {
    ...row,
    is_trial_plan: Boolean(row.is_trial_plan),
    is_free_plan: Boolean(row.is_free_plan),
    is_active: Boolean(row.is_active),
    features: typeof row.features === "string" ? JSON.parse(row.features) : row.features,
    limits: typeof row.limits === "string" ? JSON.parse(row.limits) : row.limits,
    permissions: typeof row.permissions === "string" ? JSON.parse(row.permissions) : row.permissions
  };
}
function parseUserSubscription(row) {
  return {
    ...row,
    trial_used: Boolean(row.trial_used),
    downgrade_scheduled: Boolean(row.downgrade_scheduled)
  };
}

// server/subscriptionRouter.ts
init_db();
var createSubscriptionSchema = z19.object({
  plan_id: z19.string(),
  billing_interval: z19.enum(["monthly", "yearly"]),
  payment_method_id: z19.string().optional(),
  payment_gateway: z19.enum(["stripe", "paystack", "manual"])
});
var upgradeSchema = z19.object({
  new_plan_id: z19.string(),
  immediate: z19.boolean().default(true)
});
var downgradeSchema = z19.object({
  new_plan_id: z19.string(),
  immediate: z19.boolean().default(false),
  reason: z19.string().optional()
});
var startTrialSchema = z19.object({
  category: z19.enum(["agent", "agency", "developer"])
});
var checkFeatureSchema = z19.object({
  permission: z19.string()
});
var checkLimitSchema = z19.object({
  limit_type: z19.enum(["listings", "projects", "agents", "boosts", "crm_contacts"]),
  current_count: z19.number()
});
var subscriptionRouter = router({
  // =====================================================
  // PUBLIC ENDPOINTS
  // =====================================================
  /**
   * Get all available plans
   */
  getPlans: publicProcedure.input(
    z19.object({
      category: z19.enum(["agent", "agency", "developer"]).optional()
    }).optional()
  ).query(async ({ input }) => {
    const plans2 = await getAllPlans(input?.category);
    return plans2;
  }),
  /**
   * Get specific plan details
   */
  getPlan: publicProcedure.input(z19.object({ plan_id: z19.string() })).query(async ({ input }) => {
    const plan = await getPlanByPlanId(input.plan_id);
    if (!plan) {
      throw new TRPCError8({ code: "NOT_FOUND", message: "Plan not found" });
    }
    return plan;
  }),
  // =====================================================
  // USER SUBSCRIPTION ENDPOINTS
  // =====================================================
  /**
   * Get current user's subscription
   */
  getMySubscription: protectedProcedure.query(async ({ ctx }) => {
    const subscription = await getUserSubscriptionWithPlan(ctx.user.id);
    return subscription;
  }),
  /**
   * Start free trial
   */
  startTrial: protectedProcedure.input(startTrialSchema).mutation(async ({ ctx, input }) => {
    try {
      const subscription = await startTrial(ctx.user.id, input.category);
      const plan = await getPlanByPlanId(subscription.plan_id);
      return {
        subscription,
        plan,
        trial_ends_at: subscription.trial_ends_at
      };
    } catch (error) {
      throw new TRPCError8({
        code: "BAD_REQUEST",
        message: error.message || "Failed to start trial"
      });
    }
  }),
  /**
   * Create paid subscription
   */
  createSubscription: protectedProcedure.input(createSubscriptionSchema).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError8({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });
    const plan = await getPlanByPlanId(input.plan_id);
    if (!plan) {
      throw new TRPCError8({ code: "NOT_FOUND", message: "Plan not found" });
    }
    const now = /* @__PURE__ */ new Date();
    const periodEnd = new Date(now);
    if (input.billing_interval === "yearly") {
      periodEnd.setFullYear(periodEnd.getFullYear() + 1);
    } else {
      periodEnd.setMonth(periodEnd.getMonth() + 1);
    }
    const existing = await getUserSubscription(ctx.user.id);
    if (existing) {
      await db3.execute(
        `UPDATE user_subscriptions 
           SET plan_id = ?, status = 'active_paid', amount_zar = ?, billing_interval = ?,
               current_period_start = ?, current_period_end = ?, next_billing_date = ?, updated_at = NOW()
           WHERE user_id = ?`,
        [input.plan_id, plan.price_zar, input.billing_interval, now, periodEnd, periodEnd, ctx.user.id]
      );
    } else {
      await db3.execute(
        `INSERT INTO user_subscriptions 
           (user_id, plan_id, status, amount_zar, billing_interval, current_period_start, current_period_end, next_billing_date)
           VALUES (?, ?, 'active_paid', ?, ?, ?, ?, ?)`,
        [ctx.user.id, input.plan_id, plan.price_zar, input.billing_interval, now, periodEnd, periodEnd]
      );
    }
    await logSubscriptionEvent(ctx.user.id, "subscription_created", {
      plan_id: input.plan_id,
      amount: plan.price_zar
    });
    const subscription = await getUserSubscription(ctx.user.id);
    return { subscription, plan };
  }),
  /**
   * Upgrade subscription
   */
  upgrade: protectedProcedure.input(upgradeSchema).mutation(async ({ ctx, input }) => {
    try {
      await upgradeSubscription(ctx.user.id, input.new_plan_id, input.immediate);
      const updated = await getUserSubscriptionWithPlan(ctx.user.id);
      return updated;
    } catch (error) {
      throw new TRPCError8({
        code: "BAD_REQUEST",
        message: error.message || "Failed to upgrade subscription"
      });
    }
  }),
  /**
   * Downgrade subscription
   */
  downgrade: protectedProcedure.input(downgradeSchema).mutation(async ({ ctx, input }) => {
    try {
      await downgradeSubscription(ctx.user.id, input.new_plan_id, input.immediate);
      const updated = await getUserSubscriptionWithPlan(ctx.user.id);
      return updated;
    } catch (error) {
      throw new TRPCError8({
        code: "BAD_REQUEST",
        message: error.message || "Failed to downgrade subscription"
      });
    }
  }),
  /**
   * Cancel subscription
   */
  cancel: protectedProcedure.input(z19.object({ immediate: z19.boolean().default(false) })).mutation(async ({ ctx, input }) => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError8({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });
    const subscription = await getUserSubscription(ctx.user.id);
    if (!subscription) {
      throw new TRPCError8({ code: "NOT_FOUND", message: "No active subscription" });
    }
    const now = /* @__PURE__ */ new Date();
    const endsAt = input.immediate ? now : subscription.current_period_end || now;
    await db3.execute(
      `UPDATE user_subscriptions 
         SET status = 'cancelled', cancelled_at = ?, ends_at = ?, updated_at = NOW()
         WHERE user_id = ?`,
      [now, endsAt, ctx.user.id]
    );
    await logSubscriptionEvent(ctx.user.id, "subscription_cancelled", {
      cancelled_at: now,
      ends_at: endsAt
    });
    return { success: true, ends_at: endsAt };
  }),
  // =====================================================
  // FEATURE ACCESS & LIMITS
  // =====================================================
  /**
   * Check feature access
   */
  checkFeature: protectedProcedure.input(checkFeatureSchema).query(async ({ ctx, input }) => {
    const access = await checkFeatureAccess(ctx.user.id, input.permission);
    return access;
  }),
  /**
   * Check usage limit
   */
  checkLimit: protectedProcedure.input(checkLimitSchema).query(async ({ ctx, input }) => {
    const limitCheck = await checkLimit(
      ctx.user.id,
      input.limit_type,
      input.current_count
    );
    return limitCheck;
  }),
  /**
   * Get upgrade prompt for blocked feature
   */
  getUpgradePrompt: protectedProcedure.input(z19.object({ blocked_feature: z19.string() })).query(async ({ ctx, input }) => {
    const prompt = await getUpgradePrompt(ctx.user.id, input.blocked_feature);
    return prompt;
  }),
  // =====================================================
  // USAGE TRACKING
  // =====================================================
  /**
   * Get current usage
   */
  getUsage: protectedProcedure.query(async ({ ctx }) => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError8({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });
    const subscription = await getUserSubscription(ctx.user.id);
    if (!subscription) return null;
    const [rows] = await db3.execute(
      `SELECT * FROM subscription_usage 
       WHERE user_id = ? AND subscription_id = ?
       ORDER BY period_start DESC LIMIT 1`,
      [ctx.user.id, subscription.id]
    );
    const usage = rows[0] || null;
    return usage;
  }),
  // =====================================================
  // SUPER ADMIN ENDPOINTS
  // =====================================================
  /**
   * Get all subscriptions (Admin only)
   */
  getAllSubscriptions: superAdminProcedure.input(
    z19.object({
      status: z19.string().optional(),
      category: z19.enum(["agent", "agency", "developer"]).optional(),
      limit: z19.number().default(50),
      offset: z19.number().default(0)
    })
  ).query(async ({ input }) => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError8({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });
    let query = `
        SELECT us.*, sp.name as plan_name, sp.category, u.email, u.name as user_name
        FROM user_subscriptions us
        JOIN subscription_plans sp ON us.plan_id = sp.plan_id
        JOIN users u ON us.user_id = u.id
        WHERE 1=1
      `;
    const params = [];
    if (input.status) {
      query += " AND us.status = ?";
      params.push(input.status);
    }
    if (input.category) {
      query += " AND sp.category = ?";
      params.push(input.category);
    }
    query += " ORDER BY us.created_at DESC LIMIT ? OFFSET ?";
    params.push(input.limit, input.offset);
    const [rows] = await db3.execute(query, params);
    return rows;
  }),
  /**
   * Get subscription analytics (Admin only)
   */
  getAnalytics: superAdminProcedure.query(async () => {
    const db3 = await getDb();
    if (!db3) throw new TRPCError8({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });
    const [statusStats] = await db3.execute(`
      SELECT status, COUNT(*) as count
      FROM user_subscriptions
      GROUP BY status
    `);
    const [categoryRevenue] = await db3.execute(`
      SELECT sp.category, COUNT(*) as count, SUM(us.amount_zar) as total_revenue
      FROM user_subscriptions us
      JOIN subscription_plans sp ON us.plan_id = sp.plan_id
      WHERE us.status = 'active_paid'
      GROUP BY sp.category
    `);
    const [mrrData] = await db3.execute(`
      SELECT SUM(amount_zar) as total_mrr
      FROM user_subscriptions
      WHERE status = 'active_paid' AND billing_interval = 'monthly'
    `);
    const mrr = (mrrData[0]?.total_mrr || 0) / 100;
    return {
      statusStats,
      categoryRevenue,
      mrr
    };
  }),
  /**
   * Force expire trial (Admin only)
   */
  forceExpireTrial: superAdminProcedure.input(z19.object({ user_id: z19.number() })).mutation(async ({ input }) => {
    await expireTrial(input.user_id);
    return { success: true };
  })
});

// server/developerRouter.ts
import { z as z20 } from "zod";
import { TRPCError as TRPCError9 } from "@trpc/server";

// server/services/developerService.ts
init_db_connection();
init_schema();
import { eq as eq23 } from "drizzle-orm";
async function getDeveloperByUserId2(userId) {
  const db3 = await getDb();
  if (!db3) return null;
  const results = await db3.select().from(developers).where(eq23(developers.userId, userId)).limit(1);
  const devRow = results[0];
  if (!devRow) return null;
  let brandProfile = null;
  if (devRow.developerBrandProfileId) {
    const brandResults = await db3.select().from(developerBrandProfiles).where(eq23(developerBrandProfiles.id, devRow.developerBrandProfileId)).limit(1);
    if (brandResults.length > 0) {
      brandProfile = brandResults[0];
    }
  }
  return {
    ...devRow,
    brandProfile
  };
}

// server/developerRouter.ts
console.log("[DEV ROUTER LOADED] build stamp", (/* @__PURE__ */ new Date()).toISOString());
var ParkingTypeSchema = z20.enum(["none", "open", "covered", "carport", "garage"]);
var UnitTypeSchemaV2 = z20.object({
  id: z20.string().optional(),
  name: z20.string().min(1),
  bedrooms: z20.number().int().min(0),
  bathrooms: z20.number().min(0),
  // Wizard v2 prefers unitSize (range fields are legacy and should not be validated here)
  unitSize: z20.number().int().positive().optional(),
  // Wizard v2 canonical pricing
  basePriceFrom: z20.number().positive(),
  extras: z20.array(
    z20.object({
      price: z20.number().nonnegative()
    }).passthrough()
  ).optional(),
  // Wizard v2 canonical parking
  parkingType: ParkingTypeSchema,
  parkingBays: z20.number().int().min(0),
  totalUnits: z20.number().int().min(0).optional(),
  availableUnits: z20.number().int().min(0).optional(),
  // isActive exists but is not a publish blocker (defaulting happens server-side)
  isActive: z20.boolean().optional()
}).passthrough();
function normalizeUnitType(raw) {
  const u = raw ?? {};
  let parkingType = u.parkingType ?? u.parking_type ?? void 0;
  let parkingBaysRaw = u.parkingBays ?? u.parking_bays ?? void 0;
  if (!parkingType && u.parking != null) {
    const p = String(u.parking).trim().toLowerCase();
    if (p === "1") {
      parkingType = "open";
      parkingBaysRaw = 1;
    } else if (p === "2") {
      parkingType = "open";
      parkingBaysRaw = 2;
    } else if (p === "0" || p === "none" || p === "") {
      parkingType = "none";
      parkingBaysRaw = 0;
    } else if (p === "garage") {
      parkingType = "garage";
      parkingBaysRaw = typeof parkingBaysRaw === "number" ? parkingBaysRaw : 1;
    } else if (p === "carport") {
      parkingType = "carport";
      parkingBaysRaw = typeof parkingBaysRaw === "number" ? parkingBaysRaw : 1;
    } else {
      parkingType = "none";
      parkingBaysRaw = 0;
    }
  }
  let parkingBays = Number(parkingBaysRaw ?? 0);
  if (!Number.isFinite(parkingBays)) parkingBays = 0;
  parkingBays = Math.max(0, Math.floor(parkingBays));
  if (!parkingType) parkingType = "none";
  if (parkingType === "none") parkingBays = 0;
  const basePriceFrom = Number(
    u.basePriceFrom ?? u.base_price_from ?? u.priceFrom ?? u.price_from ?? 0
  );
  return {
    ...u,
    parkingType,
    parkingBays,
    basePriceFrom
  };
}
function assertPublishable(fullDev) {
  const errors = [];
  const name = fullDev?.name ?? fullDev?.developmentData?.name;
  if (!name || String(name).trim().length < 2) {
    errors.push({ field: "name", message: "Development name is required." });
  }
  const address = fullDev?.address ?? fullDev?.developmentData?.location?.address;
  const city = fullDev?.city ?? fullDev?.developmentData?.location?.city;
  const province2 = fullDev?.province ?? fullDev?.developmentData?.location?.province;
  if (!address) errors.push({ field: "location.address", message: "Address is required." });
  if (!city) errors.push({ field: "location.city", message: "City is required." });
  if (!province2) errors.push({ field: "location.province", message: "Province is required." });
  const nature = fullDev?.nature ?? fullDev?.developmentData?.nature;
  if (nature && nature !== "new" && nature !== "phase") {
    errors.push({
      field: "nature",
      message: `Invalid nature: ${nature}. Only 'new' or 'phase' allowed.`
    });
  }
  const heroFromMedia = fullDev?.media?.heroImage?.url ?? fullDev?.developmentData?.media?.heroImage?.url;
  const images = Array.isArray(fullDev?.images) ? fullDev.images : [];
  const heroFromImages = images?.[0]?.url ?? images?.[0];
  if (!heroFromMedia && !heroFromImages) {
    errors.push({ field: "media.heroImage", message: "A hero image is required." });
  }
  const devType = fullDev?.developmentType ?? fullDev?.developmentData?.developmentType;
  const isLand = devType === "land";
  const unitTypesRaw = Array.isArray(fullDev?.unitTypes) ? fullDev.unitTypes : [];
  if (!isLand) {
    if (!unitTypesRaw.length) {
      errors.push({
        field: "unitTypes",
        message: "No unit types found. Please ensure you have added and saved at least one unit type."
      });
    }
    unitTypesRaw.forEach((raw, idx) => {
      const u = normalizeUnitType(raw);
      const unitPrefix = `unitTypes[${idx}]`;
      const unitLabel = u?.name || "Unnamed";
      if (!u?.name) {
        errors.push({ field: `${unitPrefix}.name`, message: "Unit type is missing a name." });
      }
      if (u?.bedrooms == null) {
        errors.push({
          field: `${unitPrefix}.bedrooms`,
          message: `Unit "${unitLabel}" missing bedrooms.`
        });
      }
      if (u?.bathrooms == null) {
        errors.push({
          field: `${unitPrefix}.bathrooms`,
          message: `Unit "${unitLabel}" missing bathrooms.`
        });
      }
      const pt = String(u?.parkingType ?? "").trim();
      const pb = Number(u?.parkingBays ?? 0);
      const validParking = ["none", "open", "covered", "carport", "garage"].includes(pt);
      if (!validParking) {
        errors.push({
          field: `${unitPrefix}.parkingType`,
          message: `Unit "${unitLabel}" has invalid parking type.`
        });
      }
      if (!Number.isInteger(pb) || pb < 0) {
        errors.push({
          field: `${unitPrefix}.parkingBays`,
          message: `Unit "${unitLabel}" has invalid parking bays.`
        });
      }
      if (pt === "none" && pb !== 0) {
        errors.push({
          field: `${unitPrefix}.parkingBays`,
          message: `Unit "${unitLabel}": parking bays must be 0 when parkingType is none.`
        });
      }
      const bp = Number(u?.basePriceFrom ?? 0);
      if (!Number.isFinite(bp) || bp <= 0) {
        errors.push({
          field: `${unitPrefix}.basePriceFrom`,
          message: `Unit "${unitLabel}" must have a valid base price > 0.`
        });
      }
    });
  }
  if (errors.length) {
    throw new TRPCError9({
      code: "BAD_REQUEST",
      message: errors[0].message,
      cause: {
        errors: errors.map((e) => e.message),
        // legacy compatibility
        validationErrors: errors
        // structured for UI
      }
    });
  }
}
var developerRouter = router({
  createDevelopment: protectedProcedure.input(
    z20.object({
      name: z20.string(),
      developmentType: z20.enum(["residential", "commercial", "mixed_use", "land"]).optional()
    }).passthrough()
  ).mutation(async ({ ctx, input }) => {
    return await developmentService.createDevelopment(ctx.user.id, input);
  }),
  /**
   * Get Developer Profile (Dashboard)
   * Secured by role guard: property_developer or super_admin
   */
  getProfile: protectedProcedure.query(async ({ ctx }) => {
    const role = ctx.user?.role;
    if (role !== "property_developer" && role !== "super_admin") {
      throw new TRPCError9({
        code: "FORBIDDEN",
        message: "Insufficient role for developer profile."
      });
    }
    const profile = await getDeveloperByUserId2(ctx.user.id);
    if (!profile) {
      throw new TRPCError9({ code: "NOT_FOUND", message: "Developer profile not found." });
    }
    return profile;
  }),
  updateDevelopment: protectedProcedure.input(
    z20.object({
      id: z20.number(),
      data: z20.record(z20.any())
      // Accepts loose partial updates
    })
  ).mutation(async ({ ctx, input }) => {
    return await developmentService.updateDevelopment(input.id, ctx.user.id, input.data);
  }),
  getDevelopment: protectedProcedure.input(z20.object({ id: z20.number() })).query(async ({ ctx, input }) => {
    const dev = await developmentService.getDevelopmentWithPhases(input.id);
    if (!dev) throw new TRPCError9({ code: "NOT_FOUND" });
    if (dev.developerId !== ctx.user.id) {
      throw new TRPCError9({ code: "FORBIDDEN", message: "You do not own this development" });
    }
    return dev;
  }),
  getMyDevelopments: protectedProcedure.query(async ({ ctx }) => {
    return await developmentService.getDevelopmentsByDeveloperId(ctx.user.id);
  }),
  publishDevelopment: protectedProcedure.input(z20.object({ id: z20.number() })).mutation(async ({ ctx, input }) => {
    const dev = await developmentService.getDevelopmentWithPhases(input.id);
    if (!dev) throw new TRPCError9({ code: "NOT_FOUND" });
    if (dev.developerId !== ctx.user.id) {
      throw new TRPCError9({ code: "FORBIDDEN" });
    }
    assertPublishable(dev);
    return await developmentService.publishDevelopment(input.id);
  }),
  deleteDevelopment: protectedProcedure.input(z20.object({ id: z20.number() })).mutation(async ({ ctx, input }) => {
    return await developmentService.deleteDevelopment(input.id, ctx.user.id);
  })
});

// server/exploreRouter.ts
import { z as z21 } from "zod";

// server/services/exploreFeedService.ts
init_db();
init_schema();
import { eq as eq24, and as and22, desc as desc16, sql as sql19 } from "drizzle-orm";

// server/lib/cache.ts
var SimpleCache2 = class {
  cache = /* @__PURE__ */ new Map();
  cleanupInterval;
  constructor() {
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, 6e4);
  }
  /**
   * Get value from cache
   */
  async get(key) {
    const entry = this.cache.get(key);
    if (!entry) {
      return null;
    }
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }
    return entry.value;
  }
  /**
   * Set value in cache with TTL (in seconds)
   */
  async set(key, value, ttlSeconds = 300) {
    const expiresAt = Date.now() + ttlSeconds * 1e3;
    this.cache.set(key, { value, expiresAt });
  }
  /**
   * Delete value from cache
   */
  async del(key) {
    this.cache.delete(key);
  }
  /**
   * Clear all cache entries
   */
  async clear() {
    this.cache.clear();
  }
  /**
   * Clean up expired entries
   */
  cleanup() {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
      }
    }
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }
  /**
   * Destroy cache and cleanup
   */
  destroy() {
    clearInterval(this.cleanupInterval);
    this.cache.clear();
  }
};
var cache = new SimpleCache2();
var CacheKeys = {
  recommendedFeed: (userId, limit, offset) => `feed:recommended:${userId || "guest"}:${limit}:${offset}`,
  areaFeed: (location, limit, offset) => `feed:area:${location}:${limit}:${offset}`,
  categoryFeed: (category, limit, offset) => `feed:category:${category}:${limit}:${offset}`,
  agentFeed: (agentId, limit, offset) => `feed:agent:${agentId}:${limit}:${offset}`,
  developerFeed: (developerId, limit, offset) => `feed:developer:${developerId}:${limit}:${offset}`,
  agencyFeed: (agencyId, limit, offset, includeAgentContent = true) => `feed:agency:${agencyId}:${limit}:${offset}:${includeAgentContent}`,
  performanceScore: (shortId) => `score:${shortId}`,
  userPreferences: (userId) => `prefs:${userId}`
};
var CacheTTL3 = {
  FEED: 300,
  // 5 minutes
  PERFORMANCE_SCORE: 900,
  // 15 minutes
  USER_PREFERENCES: 3600
  // 1 hour
};

// server/services/exploreFeedService.ts
function transformShort(short) {
  const mediaIds = typeof short.mediaIds === "string" ? JSON.parse(short.mediaIds) : short.mediaIds;
  return {
    ...short,
    primaryMediaUrl: Array.isArray(mediaIds) && mediaIds.length > 0 ? mediaIds[0] : null,
    mediaUrls: Array.isArray(mediaIds) ? mediaIds : []
  };
}
var ExploreFeedService = class {
  /**
   * Get recommended feed for a user
   * Factors in: boost priority, performance score, user preferences
   */
  async getRecommendedFeed(options) {
    const { userId, limit = 20, offset = 0 } = options;
    try {
      const cacheKey = CacheKeys.recommendedFeed(userId, limit, offset);
      const cached = await cache.get(cacheKey);
      if (cached) {
        return cached;
      }
      let userPrefs = null;
      if (userId) {
        try {
          const prefsCacheKey = CacheKeys.userPreferences(userId);
          userPrefs = await cache.get(prefsCacheKey);
          if (!userPrefs) {
            const prefs = await db.select().from(exploreUserPreferences).where(eq24(exploreUserPreferences.userId, userId)).limit(1);
            userPrefs = prefs[0] || null;
            if (userPrefs) {
              await cache.set(prefsCacheKey, userPrefs, CacheTTL3.USER_PREFERENCES);
            }
          }
        } catch (error) {
          console.warn("Could not fetch user preferences:", error);
          userPrefs = null;
        }
      }
      let query = db.select({
        short: exploreShorts,
        qualityScore: listings.qualityScore
      }).from(exploreShorts).leftJoin(listings, eq24(exploreShorts.listingId, listings.id)).where(eq24(exploreShorts.isPublished, 1));
      if (userPrefs?.preferredLocations && userPrefs.preferredLocations.length > 0) {
      }
      const rows = await query.orderBy(
        desc16(exploreShorts.boostPriority),
        sql19`(${exploreShorts.performanceScore} * (1 + COALESCE(${listings.qualityScore}, 30) / 100)) DESC`,
        // Use 30 as baseline for non-listings (e.g. developments) or nulls
        desc16(exploreShorts.publishedAt)
      ).limit(limit).offset(offset);
      const shorts = rows.map((r) => r.short);
      const result = {
        shorts: shorts.map(transformShort),
        feedType: "recommended",
        hasMore: shorts.length === limit,
        offset: offset + shorts.length,
        metadata: {
          personalized: !!userPrefs
        }
      };
      await cache.set(cacheKey, result, CacheTTL3.FEED);
      return result;
    } catch (error) {
      console.error("Error generating recommended feed:", error);
      throw error;
    }
  }
  /**
   * Get area-based feed
   * Filters properties by location (city, suburb, or province)
   */
  async getAreaFeed(options) {
    const { location, limit = 20, offset = 0 } = options;
    if (!location) {
      throw new Error("Location parameter required for area feed");
    }
    try {
      const cacheKey = CacheKeys.areaFeed(location, limit, offset);
      const cached = await cache.get(cacheKey);
      if (cached) {
        return cached;
      }
      const result = await db.execute(sql19`
        SELECT es.* 
        FROM explore_shorts es
        LEFT JOIN listings l ON es.listing_id = l.id
        LEFT JOIN developments d ON es.development_id = d.id
        WHERE es.is_published = 1
        AND (
          l.city LIKE ${`%${location}%`} 
          OR l.suburb LIKE ${`%${location}%`}
          OR l.province LIKE ${`%${location}%`}
          OR d.city LIKE ${`%${location}%`}
          OR d.province LIKE ${`%${location}%`}
        )
        ORDER BY es.boost_priority DESC, (es.performance_score * (1 + COALESCE(l.quality_score, 30) / 100)) DESC, es.published_at DESC
        LIMIT ${limit} OFFSET ${offset}
      `);
      const feedResult = {
        shorts: result.rows.map(transformShort),
        feedType: "area",
        hasMore: result.rows.length === limit,
        offset: offset + result.rows.length,
        metadata: {
          location
        }
      };
      await cache.set(cacheKey, feedResult, CacheTTL3.FEED);
      return feedResult;
    } catch (error) {
      console.error("Error generating area feed:", error);
      throw error;
    }
  }
  /**
   * Get category-based feed
   * Filters properties by predefined categories
   */
  async getCategoryFeed(options) {
    const { category, limit = 20, offset = 0 } = options;
    if (!category) {
      throw new Error("Category parameter required for category feed");
    }
    try {
      const categoryMap = {
        "luxury_homes": ["luxury", "high_end", "premium", "modern_finishes"],
        "student_rentals": ["student", "university", "close_to_schools"],
        "apartments_under_1m": ["affordable", "budget", "negotiable"],
        "large_yard_homes": ["large_yard", "garden", "pool"],
        "new_developments": ["new_development", "under_construction"],
        "move_in_ready": ["ready_to_move", "move_in_ready"],
        "pet_friendly": ["pet_friendly"],
        "secure_estate": ["secure_estate"],
        "off_grid": ["off_grid_ready"]
      };
      const tags = categoryMap[category] || [];
      let query = db.select().from(exploreShorts).where(eq24(exploreShorts.isPublished, 1));
      if (tags.length > 0) {
        const result = await db.execute(sql19`
          SELECT * FROM explore_shorts
          WHERE is_published = 1
          AND highlights IS NOT NULL
          AND (
            ${sql19.join(
          tags.map((tag) => sql19`JSON_CONTAINS(highlights, JSON_QUOTE(${tag}))`),
          sql19` OR `
        )}
          )
          ORDER BY boost_priority DESC, (performance_score * (1 + COALESCE((SELECT quality_score FROM listings WHERE id = listing_id), 30) / 100)) DESC, published_at DESC
          LIMIT ${limit} OFFSET ${offset}
        `);
        return {
          shorts: result.rows.map(transformShort),
          feedType: "category",
          hasMore: result.rows.length === limit,
          offset: offset + result.rows.length,
          metadata: {
            category,
            tags
          }
        };
      }
      const rows = await query.leftJoin(listings, eq24(exploreShorts.listingId, listings.id)).orderBy(
        desc16(exploreShorts.boostPriority),
        sql19`(${exploreShorts.performanceScore} * (1 + COALESCE(${listings.qualityScore}, 30) / 100)) DESC`,
        desc16(exploreShorts.publishedAt)
      ).limit(limit).offset(offset);
      const shorts = rows.map((r) => r.explore_shorts);
      return {
        shorts: shorts.map(transformShort),
        feedType: "category",
        hasMore: shorts.length === limit,
        offset: offset + shorts.length,
        metadata: {
          category
        }
      };
    } catch (error) {
      console.error("Error generating category feed:", error);
      throw error;
    }
  }
  /**
   * Get agent-specific feed
   * Shows all properties from a specific agent
   */
  async getAgentFeed(options) {
    const { agentId, limit = 20, offset = 0 } = options;
    if (!agentId) {
      throw new Error("Agent ID required for agent feed");
    }
    try {
      const shorts = await db.select().from(exploreShorts).where(
        and22(
          eq24(exploreShorts.agentId, agentId),
          eq24(exploreShorts.isPublished, 1)
        )
      ).orderBy(
        desc16(exploreShorts.isFeatured),
        desc16(exploreShorts.publishedAt)
      ).limit(limit).offset(offset);
      return {
        shorts: shorts.map(transformShort),
        feedType: "agent",
        hasMore: shorts.length === limit,
        offset: offset + shorts.length,
        metadata: {
          agentId
        }
      };
    } catch (error) {
      console.error("Error generating agent feed:", error);
      throw error;
    }
  }
  /**
   * Get developer-specific feed
   * Shows all properties from a specific developer
   */
  async getDeveloperFeed(options) {
    const { developerId, limit = 20, offset = 0 } = options;
    if (!developerId) {
      throw new Error("Developer ID required for developer feed");
    }
    try {
      const shorts = await db.select().from(exploreShorts).where(
        and22(
          eq24(exploreShorts.developerId, developerId),
          eq24(exploreShorts.isPublished, 1)
        )
      ).orderBy(
        desc16(exploreShorts.isFeatured),
        desc16(exploreShorts.publishedAt)
      ).limit(limit).offset(offset);
      return {
        shorts: shorts.map(transformShort),
        feedType: "developer",
        hasMore: shorts.length === limit,
        offset: offset + shorts.length,
        metadata: {
          developerId
        }
      };
    } catch (error) {
      console.error("Error generating developer feed:", error);
      throw error;
    }
  }
  /**
   * Get agency-specific feed
   * Shows all content attributed to an agency
   * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5
   */
  async getAgencyFeed(options) {
    const { agencyId, limit = 20, offset = 0, includeAgentContent = true } = options;
    if (!agencyId) {
      throw new Error("Agency ID required for agency feed");
    }
    try {
      const cacheKey = CacheKeys.agencyFeed(agencyId, limit, offset, includeAgentContent);
      const cached = await cache.get(cacheKey);
      if (cached) {
        return cached;
      }
      let query = db.select().from(exploreShorts).where(eq24(exploreShorts.isPublished, 1));
      if (includeAgentContent) {
        const result = await db.execute(sql19`
          SELECT es.* 
          FROM explore_shorts es
          LEFT JOIN agents a ON es.agent_id = a.id
          WHERE es.is_published = 1
          AND (
            es.agency_id = ${agencyId}
            OR a.agency_id = ${agencyId}
          )
          ORDER BY es.is_featured DESC, es.published_at DESC
          LIMIT ${limit} OFFSET ${offset}
        `);
        const feedResult = {
          shorts: result.rows.map(transformShort),
          feedType: "agency",
          hasMore: result.rows.length === limit,
          offset: offset + result.rows.length,
          metadata: {
            agencyId,
            includeAgentContent
          }
        };
        await cache.set(cacheKey, feedResult, CacheTTL3.FEED);
        return feedResult;
      } else {
        const shorts = await db.select().from(exploreShorts).where(
          and22(
            eq24(exploreShorts.agencyId, agencyId),
            eq24(exploreShorts.isPublished, 1)
          )
        ).orderBy(
          desc16(exploreShorts.isFeatured),
          desc16(exploreShorts.publishedAt)
        ).limit(limit).offset(offset);
        const feedResult = {
          shorts: shorts.map(transformShort),
          feedType: "agency",
          hasMore: shorts.length === limit,
          offset: offset + shorts.length,
          metadata: {
            agencyId,
            includeAgentContent
          }
        };
        await cache.set(cacheKey, feedResult, CacheTTL3.FEED);
        return feedResult;
      }
    } catch (error) {
      console.error("Error generating agency feed:", error);
      throw error;
    }
  }
  /**
   * Get feed by type
   * Convenience method to route to appropriate feed generator
   * Updated to support 'agency' feed type (Requirement 2.1, 8.1)
   */
  async getFeed(feedType, options) {
    switch (feedType) {
      case "recommended":
        return this.getRecommendedFeed(options);
      case "area":
        return this.getAreaFeed(options);
      case "category":
        return this.getCategoryFeed(options);
      case "agent":
        return this.getAgentFeed(options);
      case "developer":
        return this.getDeveloperFeed(options);
      case "agency":
        if (!options.agencyId) {
          throw new Error("Agency ID required for agency feed");
        }
        return this.getAgencyFeed(options);
      default:
        throw new Error(`Unknown feed type: ${feedType}`);
    }
  }
  /**
   * Get all active categories for the selector
   */
  async getCategories() {
    return await db.select().from(exploreCategories).where(eq24(exploreCategories.isActive, 1)).orderBy(exploreCategories.displayOrder);
  }
  /**
   * Get all active topics for Deep Dive zone
   */
  async getTopics() {
    return await db.select().from(exploreTopics).where(eq24(exploreTopics.isActive, 1));
  }
};
var exploreFeedService = new ExploreFeedService();

// server/services/exploreInteractionService.ts
init_db();
init_schema();
import { eq as eq25, sql as sql20 } from "drizzle-orm";
var ExploreInteractionService = class {
  /**
   * Record a single interaction
   */
  async recordInteraction(options) {
    const {
      shortId,
      userId,
      sessionId,
      interactionType,
      duration,
      feedType,
      feedContext,
      deviceType,
      userAgent,
      ipAddress,
      metadata
    } = options;
    try {
      await db.insert(exploreInteractions).values({
        shortId,
        userId: userId || null,
        sessionId,
        interactionType,
        duration: duration || null,
        feedType,
        feedContext: feedContext ? JSON.stringify(feedContext) : null,
        deviceType,
        userAgent: userAgent || null,
        ipAddress: ipAddress || null,
        metadata: metadata ? JSON.stringify(metadata) : null
      });
      this.updateShortMetrics(shortId, interactionType, duration).catch((error) => {
        console.error("Error updating short metrics:", error);
      });
    } catch (error) {
      console.error("Error recording interaction:", error);
      throw error;
    }
  }
  /**
   * Record multiple interactions in batch
   * Optimized for high-volume interaction tracking
   */
  async recordBatchInteractions(options) {
    const { interactions } = options;
    if (interactions.length === 0) {
      return;
    }
    try {
      const values = interactions.map((interaction) => ({
        shortId: interaction.shortId,
        userId: interaction.userId || null,
        sessionId: interaction.sessionId,
        interactionType: interaction.interactionType,
        duration: interaction.duration || null,
        feedType: interaction.feedType,
        feedContext: interaction.feedContext ? JSON.stringify(interaction.feedContext) : null,
        deviceType: interaction.deviceType,
        userAgent: interaction.userAgent || null,
        ipAddress: interaction.ipAddress || null,
        metadata: interaction.metadata ? JSON.stringify(interaction.metadata) : null
      }));
      await db.insert(exploreInteractions).values(values);
      const shortIds = [...new Set(interactions.map((i) => i.shortId))];
      for (const shortId of shortIds) {
        const shortInteractions = interactions.filter((i) => i.shortId === shortId);
        for (const interaction of shortInteractions) {
          this.updateShortMetrics(
            shortId,
            interaction.interactionType,
            interaction.duration
          ).catch((error) => {
            console.error("Error updating short metrics:", error);
          });
        }
      }
    } catch (error) {
      console.error("Error recording batch interactions:", error);
      throw error;
    }
  }
  /**
   * Save property to favorites
   */
  async saveProperty(shortId, userId) {
    try {
      await this.recordInteraction({
        shortId,
        userId,
        sessionId: `user-${userId}`,
        interactionType: "save",
        feedType: "recommended",
        deviceType: "mobile"
      });
    } catch (error) {
      console.error("Error saving property:", error);
      throw error;
    }
  }
  /**
   * Record property share
   */
  async shareProperty(shortId, userId, sessionId, platform) {
    try {
      await this.recordInteraction({
        shortId,
        userId,
        sessionId,
        interactionType: "share",
        feedType: "recommended",
        deviceType: "mobile",
        metadata: { platform }
      });
    } catch (error) {
      console.error("Error recording share:", error);
      throw error;
    }
  }
  /**
   * Update short engagement metrics
   * Called asynchronously after recording interactions
   */
  async updateShortMetrics(shortId, interactionType, duration) {
    try {
      const metricUpdates = {
        impression: "view_count",
        view: "view_count",
        skip: "skip_count",
        save: "save_count",
        share: "share_count"
      };
      const field = metricUpdates[interactionType];
      if (field) {
        await db.execute(sql20`
          UPDATE explore_shorts 
          SET ${sql20.raw(field)} = ${sql20.raw(field)} + 1
          WHERE id = ${shortId}
        `);
      }
      if (interactionType === "view" && duration) {
        await db.execute(sql20`
          UPDATE explore_shorts 
          SET average_watch_time = (
            (average_watch_time * view_count + ${duration}) / (view_count + 1)
          )
          WHERE id = ${shortId}
        `);
      }
      if (interactionType === "impression") {
        await db.execute(sql20`
          UPDATE explore_shorts 
          SET unique_view_count = unique_view_count + 1
          WHERE id = ${shortId}
        `);
      }
    } catch (error) {
      console.error("Error updating short metrics:", error);
    }
  }
  /**
   * Get interaction statistics for a short
   */
  async getShortStats(shortId) {
    try {
      const short = await db.select().from(exploreShorts).where(eq25(exploreShorts.id, shortId)).limit(1);
      if (short.length === 0) {
        throw new Error("Short not found");
      }
      return {
        shortId,
        viewCount: short[0].viewCount,
        uniqueViewCount: short[0].uniqueViewCount,
        saveCount: short[0].saveCount,
        shareCount: short[0].shareCount,
        skipCount: short[0].skipCount,
        averageWatchTime: short[0].averageWatchTime,
        performanceScore: short[0].performanceScore
      };
    } catch (error) {
      console.error("Error getting short stats:", error);
      throw error;
    }
  }
  /**
   * Get user interaction history
   */
  async getUserInteractionHistory(userId, limit = 50) {
    try {
      const interactions = await db.select().from(exploreInteractions).where(eq25(exploreInteractions.userId, userId)).orderBy(sql20`timestamp DESC`).limit(limit);
      return interactions;
    } catch (error) {
      console.error("Error getting user interaction history:", error);
      throw error;
    }
  }
  /**
   * Get session interaction history (for guest users)
   */
  async getSessionInteractionHistory(sessionId, limit = 50) {
    try {
      const interactions = await db.select().from(exploreInteractions).where(eq25(exploreInteractions.sessionId, sessionId)).orderBy(sql20`timestamp DESC`).limit(limit);
      return interactions;
    } catch (error) {
      console.error("Error getting session interaction history:", error);
      throw error;
    }
  }
  /**
   * Calculate engagement rate for a short
   */
  async calculateEngagementRate(shortId) {
    try {
      const short = await db.select().from(exploreShorts).where(eq25(exploreShorts.id, shortId)).limit(1);
      if (short.length === 0) {
        return 0;
      }
      const { viewCount, saveCount, shareCount } = short[0];
      if (viewCount === 0) {
        return 0;
      }
      const engagementRate = (saveCount + shareCount) / viewCount * 100;
      return Math.round(engagementRate * 100) / 100;
    } catch (error) {
      console.error("Error calculating engagement rate:", error);
      return 0;
    }
  }
};
var exploreInteractionService = new ExploreInteractionService();

// server/exploreRouter.ts
var exploreRouter = router({
  // Get feed based on type
  getFeed: publicProcedure.input(
    z21.object({
      feedType: z21.enum(["recommended", "area", "category", "agent", "developer", "agency"]),
      limit: z21.number().min(1).max(50).default(20),
      offset: z21.number().min(0).default(0),
      location: z21.string().optional(),
      category: z21.string().optional(),
      agentId: z21.number().optional(),
      developerId: z21.number().optional(),
      agencyId: z21.number().optional(),
      includeAgentContent: z21.boolean().default(true),
      userId: z21.number().optional()
    })
  ).query(async ({ input, ctx }) => {
    const userId = ctx.user?.id || input.userId;
    switch (input.feedType) {
      case "recommended":
        return exploreFeedService.getRecommendedFeed({
          userId,
          limit: input.limit,
          offset: input.offset
        });
      case "area":
        if (!input.location) {
          throw new Error("Location is required for area feed");
        }
        return exploreFeedService.getAreaFeed({
          location: input.location,
          limit: input.limit,
          offset: input.offset
        });
      case "category":
        if (!input.category) {
          throw new Error("Category is required for category feed");
        }
        return exploreFeedService.getCategoryFeed({
          category: input.category,
          limit: input.limit,
          offset: input.offset
        });
      case "agent":
        if (!input.agentId) {
          throw new Error("Agent ID is required for agent feed");
        }
        return exploreFeedService.getAgentFeed({
          agentId: input.agentId,
          limit: input.limit,
          offset: input.offset
        });
      case "developer":
        if (!input.developerId) {
          throw new Error("Developer ID is required for developer feed");
        }
        return exploreFeedService.getDeveloperFeed({
          developerId: input.developerId,
          limit: input.limit,
          offset: input.offset
        });
      case "agency":
        if (!input.agencyId) {
          throw new Error("Agency ID is required for agency feed");
        }
        return exploreFeedService.getAgencyFeed({
          agencyId: input.agencyId,
          limit: input.limit,
          offset: input.offset,
          includeAgentContent: input.includeAgentContent
        });
      default:
        throw new Error("Invalid feed type");
    }
  }),
  // Record interaction
  recordInteraction: publicProcedure.input(
    z21.object({
      shortId: z21.number(),
      interactionType: z21.enum([
        "impression",
        "view",
        "skip",
        "save",
        "share",
        "contact",
        "whatsapp",
        "book_viewing"
      ]),
      duration: z21.number().optional(),
      feedType: z21.enum(["recommended", "area", "category", "agent", "developer", "agency"]),
      feedContext: z21.record(z21.string(), z21.any()).optional(),
      deviceType: z21.enum(["mobile", "tablet", "desktop"]).default("mobile")
    })
  ).mutation(async ({ input, ctx }) => {
    const userId = ctx.user?.id;
    const sessionId = `session-${Date.now()}`;
    await exploreInteractionService.recordInteraction({
      shortId: input.shortId,
      userId,
      sessionId,
      interactionType: input.interactionType,
      duration: input.duration,
      feedType: input.feedType,
      feedContext: input.feedContext || {},
      deviceType: input.deviceType,
      userAgent: ctx.req.headers["user-agent"] || "",
      ipAddress: ctx.req.ip || ""
    });
    return { success: true };
  }),
  // Save property
  saveProperty: protectedProcedure.input(
    z21.object({
      shortId: z21.number()
    })
  ).mutation(async ({ input, ctx }) => {
    await exploreInteractionService.saveProperty(input.shortId, ctx.user.id);
    return { success: true };
  }),
  // Share property
  shareProperty: publicProcedure.input(
    z21.object({
      shortId: z21.number(),
      platform: z21.string().optional()
    })
  ).mutation(async ({ input, ctx }) => {
    const userId = ctx.user?.id;
    const sessionId = `session-${Date.now()}`;
    await exploreInteractionService.shareProperty(
      input.shortId,
      userId,
      sessionId,
      input.platform
    );
    return { success: true };
  }),
  // Get highlight tags
  getHighlightTags: publicProcedure.query(async () => {
    const { db: db3 } = await Promise.resolve().then(() => (init_db(), db_exports));
    const { exploreHighlightTags: exploreHighlightTags2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const { eq: eq47, asc: asc5 } = await import("drizzle-orm");
    const tags = await db3.select().from(exploreHighlightTags2).where(eq47(exploreHighlightTags2.isActive, 1)).orderBy(asc5(exploreHighlightTags2.displayOrder));
    return tags;
  }),
  // Get categories
  getCategories: publicProcedure.query(async () => {
    return exploreFeedService.getCategories();
  }),
  // Get topics
  getTopics: publicProcedure.query(async () => {
    return exploreFeedService.getTopics();
  }),
  // Upload new explore short
  uploadShort: protectedProcedure.input(
    z21.object({
      title: z21.string().min(1).max(255),
      caption: z21.string().max(500).optional(),
      mediaUrls: z21.array(z21.string()).min(1).max(10),
      highlights: z21.array(z21.string()).max(4).optional(),
      listingId: z21.number().optional(),
      developmentId: z21.number().optional(),
      attributeToAgency: z21.boolean().default(true)
      // NEW: Agency attribution opt-out
    })
  ).mutation(async ({ input, ctx }) => {
    const { db: db3 } = await Promise.resolve().then(() => (init_db(), db_exports));
    const { exploreShorts: exploreShorts4, agents: agents2, developers: developers2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const { eq: eq47 } = await import("drizzle-orm");
    let agentId = null;
    let developerId = null;
    let agencyId = null;
    if (ctx.user.role === "agent") {
      const agent = await db3.select({
        id: agents2.id,
        agencyId: agents2.agencyId
      }).from(agents2).where(eq47(agents2.userId, ctx.user.id)).limit(1);
      if (agent[0]) {
        agentId = agent[0].id;
        if (input.attributeToAgency && agent[0].agencyId) {
          agencyId = agent[0].agencyId;
          console.log(`[ExploreUpload] Agent ${agentId} uploading with agency ${agencyId}`);
        } else {
          console.log(`[ExploreUpload] Agent ${agentId} uploading without agency attribution (opted out or no agency)`);
        }
      }
    } else if (ctx.user.role === "property_developer") {
      const developer = await db3.select().from(developers2).where(eq47(developers2.userId, ctx.user.id)).limit(1);
      developerId = developer[0]?.id || null;
      console.log(`[ExploreUpload] Developer ${developerId} uploading`);
    }
    if (agencyId) {
      const { agencies: agencies3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const agencyRecord = await db3.select().from(agencies3).where(eq47(agencies3.id, agencyId)).limit(1);
      if (!agencyRecord[0]) {
        throw new Error(`Agency with ID ${agencyId} does not exist`);
      }
      if (agentId) {
        const agentRecord = await db3.select({ agencyId: agents2.agencyId }).from(agents2).where(eq47(agents2.id, agentId)).limit(1);
        if (agentRecord[0]?.agencyId !== agencyId) {
          throw new Error(`Agent ${agentId} does not belong to agency ${agencyId}`);
        }
      }
    }
    console.log(`[ExploreUpload] Agency attribution decision:`, {
      userId: ctx.user.id,
      agentId,
      developerId,
      agencyId
    });
    const result = await db3.insert(exploreShorts4).values({
      listingId: input.listingId || null,
      developmentId: input.developmentId || null,
      agentId,
      developerId,
      agencyId,
      // NEW: Agency attribution
      title: input.title,
      caption: input.caption || null,
      primaryMediaId: 1,
      // Placeholder - would be actual media ID in production
      mediaIds: JSON.stringify(input.mediaUrls),
      highlights: input.highlights ? JSON.stringify(input.highlights.filter((h) => h.trim())) : null,
      performanceScore: 0,
      boostPriority: 0,
      isPublished: 1,
      isFeatured: 0,
      publishedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    return {
      success: true,
      shortId: Number(result.insertId)
    };
  })
});

// server/exploreVideoUploadRouter.ts
import { z as z22 } from "zod";

// server/services/exploreVideoService.ts
init_db();
init_schema();
import { S3Client as S3Client3, PutObjectCommand as PutObjectCommand3 } from "@aws-sdk/client-s3";
import { getSignedUrl as getSignedUrl3 } from "@aws-sdk/s3-request-presigner";
import crypto6 from "crypto";
import { eq as eq26 } from "drizzle-orm";
var s3Client2 = new S3Client3({
  region: process.env.AWS_REGION || "eu-north-1",
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || "",
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || ""
  }
});
var S3_BUCKET_NAME = process.env.AWS_S3_BUCKET || "listify-properties-sa";
var AWS_REGION = process.env.AWS_REGION || "eu-north-1";
var CDN_URL = process.env.CLOUDFRONT_URL || `https://${S3_BUCKET_NAME}.s3.${AWS_REGION}.amazonaws.com`;
function validateVideoMetadata(metadata) {
  const errors = [];
  if (!metadata.title || metadata.title.trim().length === 0) {
    errors.push("Title is required");
  }
  if (!metadata.tags || metadata.tags.length === 0) {
    errors.push("At least one tag is required");
  }
  if (!metadata.propertyId && !metadata.developmentId) {
    errors.push("Video must be linked to a property or development");
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
function validateVideoDuration(duration) {
  if (duration < 8) {
    return { valid: false, error: "Video duration must be at least 8 seconds" };
  }
  if (duration > 60) {
    return { valid: false, error: "Video duration must not exceed 60 seconds" };
  }
  return { valid: true };
}
async function generateVideoUploadUrls(creatorId, filename, contentType) {
  if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
    throw new Error("AWS credentials not configured");
  }
  const timestamp2 = Date.now();
  const fileId = crypto6.randomUUID();
  const sanitizedFilename = filename.replace(/[^a-zA-Z0-9.-]/g, "_");
  const videoKey = `explore/videos/${creatorId}/${timestamp2}-${fileId}-${sanitizedFilename}`;
  const thumbnailKey = `explore/thumbnails/${creatorId}/${timestamp2}-${fileId}.jpg`;
  try {
    const videoCommand = new PutObjectCommand3({
      Bucket: S3_BUCKET_NAME,
      Key: videoKey,
      ContentType: contentType
    });
    const videoUploadUrl = await getSignedUrl3(s3Client2, videoCommand, { expiresIn: 3600 });
    const thumbnailCommand = new PutObjectCommand3({
      Bucket: S3_BUCKET_NAME,
      Key: thumbnailKey,
      ContentType: "image/jpeg"
    });
    const thumbnailUploadUrl = await getSignedUrl3(s3Client2, thumbnailCommand, { expiresIn: 3600 });
    const videoUrl = `${CDN_URL}/${videoKey}`;
    const thumbnailUrl = `${CDN_URL}/${thumbnailKey}`;
    console.log(`[ExploreVideo] Generated presigned URLs for creator ${creatorId}`);
    console.log(`  Video key: ${videoKey}`);
    console.log(`  Thumbnail key: ${thumbnailKey}`);
    return {
      uploadUrl: videoUploadUrl,
      videoKey,
      thumbnailKey,
      videoUrl,
      thumbnailUrl
    };
  } catch (error) {
    console.error("[ExploreVideo] Failed to generate presigned URLs:", error);
    throw new Error(`Failed to generate upload URLs: ${error.message}`);
  }
}
async function validateAgencyAttribution(agentId, agencyId) {
  if (!agencyId) {
    return { valid: true };
  }
  if (!agentId) {
    return {
      valid: false,
      error: "Agency attribution requires an agent"
    };
  }
  const { agencies: agencies3, agents: agents2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
  const agencyRecord = await db.select({
    id: agencies3.id,
    name: agencies3.name
  }).from(agencies3).where(eq26(agencies3.id, agencyId)).limit(1);
  if (!agencyRecord[0]) {
    return {
      valid: false,
      error: `Agency with ID ${agencyId} does not exist`
    };
  }
  const agentRecord = await db.select({
    id: agents2.id,
    agencyId: agents2.agencyId
  }).from(agents2).where(eq26(agents2.id, agentId)).limit(1);
  if (!agentRecord[0]) {
    return {
      valid: false,
      error: `Agent with ID ${agentId} does not exist`
    };
  }
  if (agentRecord[0].agencyId !== agencyId) {
    return {
      valid: false,
      error: `Agent ${agentId} does not belong to agency ${agencyId}`
    };
  }
  console.log(`[ExploreVideo] Agency attribution validated: agent ${agentId} belongs to agency ${agencyId}`);
  return { valid: true };
}
async function detectAgencyAffiliation(creatorId) {
  const { agents: agents2, users: users6 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
  const agentRecord = await db.select({
    id: agents2.id,
    agencyId: agents2.agencyId,
    userId: agents2.userId
  }).from(agents2).where(eq26(agents2.userId, creatorId)).limit(1);
  if (agentRecord[0]) {
    const agencyId = agentRecord[0].agencyId;
    const agentId = agentRecord[0].id;
    console.log(`[ExploreVideo] Detected agent ${agentId} with agency ${agencyId || "none"} for user ${creatorId}`);
    return {
      agencyId,
      agentId,
      creatorType: "agent"
    };
  }
  const { developers: developers2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
  const developerRecord = await db.select({
    id: developers2.id
  }).from(developers2).where(eq26(developers2.userId, creatorId)).limit(1);
  if (developerRecord[0]) {
    console.log(`[ExploreVideo] Detected developer ${developerRecord[0].id} for user ${creatorId}`);
    return {
      agencyId: null,
      agentId: null,
      creatorType: "developer"
    };
  }
  console.log(`[ExploreVideo] User ${creatorId} is a regular user (not agent or developer)`);
  return {
    agencyId: null,
    agentId: null,
    creatorType: "user"
  };
}
async function createExploreVideo(creatorId, videoUrl, thumbnailUrl, metadata, duration) {
  const metadataValidation = validateVideoMetadata(metadata);
  if (!metadataValidation.valid) {
    throw new Error(`Invalid metadata: ${metadataValidation.errors.join(", ")}`);
  }
  const durationValidation = validateVideoDuration(duration);
  if (!durationValidation.valid) {
    throw new Error(durationValidation.error);
  }
  const affiliation = await detectAgencyAffiliation(creatorId);
  const attributionValidation = await validateAgencyAttribution(
    affiliation.agentId,
    affiliation.agencyId
  );
  if (!attributionValidation.valid) {
    throw new Error(`Invalid agency attribution: ${attributionValidation.error}`);
  }
  console.log(`[ExploreVideo] Agency attribution decision:`, {
    creatorId,
    agencyId: affiliation.agencyId,
    agentId: affiliation.agentId,
    creatorType: affiliation.creatorType
  });
  let locationLat = null;
  let locationLng = null;
  let priceMin = null;
  let priceMax = null;
  if (metadata.propertyId) {
    const property = await db.select().from(properties).where(eq26(properties.id, metadata.propertyId)).limit(1);
    if (!property[0]) {
      throw new Error("Property not found");
    }
    locationLat = property[0].latitude ? parseFloat(property[0].latitude.toString()) : null;
    locationLng = property[0].longitude ? parseFloat(property[0].longitude.toString()) : null;
    priceMin = property[0].price || null;
    priceMax = property[0].price || null;
  } else if (metadata.developmentId) {
    const development = await db.select().from(developments).where(eq26(developments.id, metadata.developmentId)).limit(1);
    if (!development[0]) {
      throw new Error("Development not found");
    }
    locationLat = development[0].latitude ? parseFloat(development[0].latitude.toString()) : null;
    locationLng = development[0].longitude ? parseFloat(development[0].longitude.toString()) : null;
    priceMin = development[0].priceFrom || null;
    priceMax = development[0].priceTo || null;
  }
  try {
    const contentResult = await db.insert(exploreContent).values({
      contentType: "video",
      referenceId: metadata.propertyId || metadata.developmentId || 0,
      creatorId,
      creatorType: affiliation.creatorType,
      agencyId: affiliation.agencyId,
      title: metadata.title,
      description: metadata.description || null,
      thumbnailUrl,
      videoUrl,
      metadata: JSON.stringify({
        beds: metadata.beds,
        baths: metadata.baths,
        location: metadata.location
      }),
      tags: JSON.stringify(metadata.tags),
      lifestyleCategories: JSON.stringify(metadata.lifestyleCategories),
      locationLat,
      locationLng,
      priceMin,
      priceMax,
      viewCount: 0,
      engagementScore: 0,
      isActive: true,
      isFeatured: false
    });
    const exploreContentId = Number(contentResult.insertId);
    const videoResult = await db.insert(exploreDiscoveryVideos).values({
      exploreContentId,
      propertyId: metadata.propertyId || null,
      developmentId: metadata.developmentId || null,
      videoUrl,
      thumbnailUrl,
      duration,
      transcodedUrls: null,
      // Will be populated by transcoding service
      musicTrack: null,
      hasSubtitles: false,
      subtitleUrl: null,
      totalViews: 0,
      totalWatchTime: 0,
      completionRate: 0,
      saveCount: 0,
      shareCount: 0,
      clickThroughCount: 0
    });
    const exploreVideoId = Number(videoResult.insertId);
    console.log(`[ExploreVideo] Created video record: content=${exploreContentId}, video=${exploreVideoId}`);
    return {
      exploreContentId,
      exploreVideoId,
      videoUrl,
      thumbnailUrl
    };
  } catch (error) {
    console.error("[ExploreVideo] Failed to create video records:", error);
    throw new Error(`Failed to create video: ${error.message}`);
  }
}
async function updateVideoAnalytics(exploreVideoId, analytics) {
  try {
    const updates = {};
    if (analytics.views !== void 0) {
      updates.totalViews = analytics.views;
    }
    if (analytics.watchTime !== void 0) {
      updates.totalWatchTime = analytics.watchTime;
    }
    if (analytics.completionRate !== void 0) {
      updates.completionRate = analytics.completionRate;
    }
    if (analytics.saves !== void 0) {
      updates.saveCount = analytics.saves;
    }
    if (analytics.shares !== void 0) {
      updates.shareCount = analytics.shares;
    }
    if (analytics.clickThroughs !== void 0) {
      updates.clickThroughCount = analytics.clickThroughs;
    }
    await db.update(exploreDiscoveryVideos).set(updates).where(eq26(exploreDiscoveryVideos.id, exploreVideoId));
    console.log(`[ExploreVideo] Updated analytics for video ${exploreVideoId}`);
  } catch (error) {
    console.error("[ExploreVideo] Failed to update analytics:", error);
    throw new Error(`Failed to update video analytics: ${error.message}`);
  }
}

// server/exploreVideoUploadRouter.ts
init_videoProcessingService();
var exploreVideoUploadRouter = router({
  /**
   * Generate presigned URLs for video and thumbnail upload
   * Requirements 8.1: Video upload with metadata
   */
  generateUploadUrl: protectedProcedure.input(
    z22.object({
      filename: z22.string().min(1, "Filename is required"),
      contentType: z22.string().regex(/^video\/(mp4|quicktime|x-msvideo|webm)$/, "Invalid video format")
    })
  ).mutation(async ({ ctx, input }) => {
    const creatorId = ctx.user.id;
    const result = await generateVideoUploadUrls(creatorId, input.filename, input.contentType);
    return {
      success: true,
      data: result
    };
  }),
  /**
   * Create explore video record after successful upload
   * Requirements 8.1, 8.2, 8.4: Store video metadata and validate duration
   */
  createVideo: protectedProcedure.input(
    z22.object({
      videoUrl: z22.string().url("Invalid video URL"),
      thumbnailUrl: z22.string().url("Invalid thumbnail URL"),
      duration: z22.number().min(8, "Video must be at least 8 seconds").max(60, "Video must not exceed 60 seconds"),
      metadata: z22.object({
        propertyId: z22.number().optional(),
        developmentId: z22.number().optional(),
        title: z22.string().min(1, "Title is required"),
        description: z22.string().optional(),
        tags: z22.array(z22.string()).min(1, "At least one tag is required"),
        lifestyleCategories: z22.array(z22.string()),
        price: z22.number().optional(),
        location: z22.string().optional(),
        beds: z22.number().optional(),
        baths: z22.number().optional()
      })
    })
  ).mutation(async ({ ctx, input }) => {
    const creatorId = ctx.user.id;
    const metadataValidation = validateVideoMetadata(input.metadata);
    if (!metadataValidation.valid) {
      throw new Error(`Invalid metadata: ${metadataValidation.errors.join(", ")}`);
    }
    const durationValidation = validateVideoDuration(input.duration);
    if (!durationValidation.valid) {
      throw new Error(durationValidation.error);
    }
    const result = await createExploreVideo(
      creatorId,
      input.videoUrl,
      input.thumbnailUrl,
      input.metadata,
      input.duration
    );
    processUploadedVideo(result.exploreVideoId, input.videoUrl, input.duration).catch((error) => {
      console.error("[ExploreVideoUpload] Video processing failed:", error);
    });
    return {
      success: true,
      data: result,
      message: "Video uploaded successfully and is being processed. It will be available in Explore feed within 5 minutes."
    };
  }),
  /**
   * Update video analytics
   * Requirements 8.6: Provide analytics on views, watch time, saves, and click-throughs
   */
  updateAnalytics: protectedProcedure.input(
    z22.object({
      exploreVideoId: z22.number(),
      analytics: z22.object({
        views: z22.number().optional(),
        watchTime: z22.number().optional(),
        completionRate: z22.number().min(0).max(100).optional(),
        saves: z22.number().optional(),
        shares: z22.number().optional(),
        clickThroughs: z22.number().optional()
      })
    })
  ).mutation(async ({ input }) => {
    await updateVideoAnalytics(input.exploreVideoId, input.analytics);
    return {
      success: true,
      message: "Analytics updated successfully"
    };
  }),
  /**
   * Validate video metadata before upload
   * Requirements 8.1: Validate required metadata
   */
  validateMetadata: protectedProcedure.input(
    z22.object({
      propertyId: z22.number().optional(),
      developmentId: z22.number().optional(),
      title: z22.string(),
      description: z22.string().optional(),
      tags: z22.array(z22.string()),
      lifestyleCategories: z22.array(z22.string()),
      price: z22.number().optional(),
      location: z22.string().optional(),
      beds: z22.number().optional(),
      baths: z22.number().optional()
    })
  ).query(({ input }) => {
    const validation = validateVideoMetadata(input);
    return {
      valid: validation.valid,
      errors: validation.errors
    };
  }),
  /**
   * Validate video duration
   * Requirements 8.4: Duration must be between 8 and 60 seconds
   */
  validateDuration: protectedProcedure.input(
    z22.object({
      duration: z22.number()
    })
  ).query(({ input }) => {
    const validation = validateVideoDuration(input.duration);
    return {
      valid: validation.valid,
      error: validation.error
    };
  }),
  /**
   * Update transcoded video URLs
   * Called by transcoding service webhook when processing completes
   * Requirements 8.2: Store processed video URLs
   */
  updateTranscodedUrls: protectedProcedure.input(
    z22.object({
      exploreVideoId: z22.number(),
      transcodedVideos: z22.array(
        z22.object({
          quality: z22.string(),
          url: z22.string().url(),
          width: z22.number(),
          height: z22.number()
        })
      )
    })
  ).mutation(async ({ input }) => {
    await updateTranscodedUrls(input.exploreVideoId, input.transcodedVideos);
    return {
      success: true,
      message: "Transcoded URLs updated successfully"
    };
  }),
  /**
   * Get transcoding status for a video
   * Requirements 8.2: Track video processing status
   */
  getTranscodingStatus: protectedProcedure.input(
    z22.object({
      exploreVideoId: z22.number()
    })
  ).query(async ({ input }) => {
    const { getTranscodingStatus: getTranscodingStatus2 } = await Promise.resolve().then(() => (init_videoProcessingService(), videoProcessingService_exports));
    const status = await getTranscodingStatus2(input.exploreVideoId);
    return {
      success: true,
      data: status
    };
  }),
  /**
   * Validate video file
   * Requirements 8.1, 8.4: Validate video format and duration
   */
  validateVideoFile: protectedProcedure.input(
    z22.object({
      videoUrl: z22.string().url(),
      duration: z22.number().optional()
    })
  ).query(async ({ input }) => {
    const { validateVideoFile: validateVideoFile2 } = await Promise.resolve().then(() => (init_videoProcessingService(), videoProcessingService_exports));
    const validation = await validateVideoFile2(input.videoUrl, input.duration);
    return {
      valid: validation.valid,
      errors: validation.errors
    };
  })
});

// server/exploreAnalyticsRouter.ts
import { z as z23 } from "zod";

// server/services/exploreAnalyticsService.ts
init_db();
init_schema();
import { eq as eq28, and as and23, gte as gte4, lte as lte4 } from "drizzle-orm";
var ExploreAnalyticsService = class {
  /**
   * Get video analytics for a specific video
   * Requirement 8.6: Provide analytics on views, watch time, saves, and click-throughs
   */
  async getVideoAnalytics(videoId, startDate, endDate) {
    const video = await db.select({ contentId: exploreDiscoveryVideos.exploreContentId }).from(exploreDiscoveryVideos).where(eq28(exploreDiscoveryVideos.id, videoId)).limit(1);
    if (!video[0]) {
      throw new Error("Video not found");
    }
    const contentId = video[0].contentId;
    const dateFilter = [];
    if (startDate) {
      dateFilter.push(gte4(exploreEngagements.createdAt, startDate.toISOString()));
    }
    if (endDate) {
      dateFilter.push(lte4(exploreEngagements.createdAt, endDate.toISOString()));
    }
    const engagements = await db.select({
      engagementType: exploreEngagements.engagementType,
      watchTime: exploreEngagements.watchTime,
      completed: exploreEngagements.completed,
      userId: exploreEngagements.userId
    }).from(exploreEngagements).where(
      and23(
        eq28(exploreEngagements.contentId, contentId),
        ...dateFilter.length > 0 ? dateFilter : []
      )
    );
    const views = engagements.filter((e) => e.engagementType === "view").length;
    const uniqueViewers = new Set(
      engagements.filter((e) => e.engagementType === "view").map((e) => e.userId)
    ).size;
    const completions = engagements.filter((e) => e.completed).length;
    const saves = engagements.filter((e) => e.engagementType === "save").length;
    const shares = engagements.filter((e) => e.engagementType === "share").length;
    const clicks = engagements.filter((e) => e.engagementType === "click").length;
    const skips = engagements.filter((e) => e.engagementType === "skip").length;
    const totalWatchTime = engagements.reduce((sum3, e) => sum3 + (e.watchTime || 0), 0);
    const averageWatchTime = views > 0 ? totalWatchTime / views : 0;
    const completionRate = views > 0 ? completions / views * 100 : 0;
    const totalEngagements = saves + shares + clicks;
    const engagementRate = views > 0 ? totalEngagements / views * 100 : 0;
    const averageEngagementScore = this.calculateEngagementScore({
      views,
      completions,
      saves,
      shares,
      clicks,
      skips
    });
    return {
      videoId,
      contentId,
      totalViews: views,
      uniqueViewers,
      totalWatchTime,
      averageWatchTime,
      completionRate,
      completions,
      saves,
      shares,
      clicks,
      skips,
      engagementRate,
      averageEngagementScore
    };
  }
  /**
   * Get creator analytics across all their videos
   * Requirement 8.6: Generate creator analytics
   */
  async getCreatorAnalytics(creatorId, startDate, endDate) {
    const videos2 = await db.select({
      id: exploreContent.id,
      title: exploreContent.title,
      videoId: exploreDiscoveryVideos.id
    }).from(exploreContent).innerJoin(
      exploreDiscoveryVideos,
      eq28(exploreContent.id, exploreDiscoveryVideos.exploreContentId)
    ).where(eq28(exploreContent.creatorId, creatorId));
    const totalVideos = videos2.length;
    if (totalVideos === 0) {
      return {
        creatorId,
        totalVideos: 0,
        totalViews: 0,
        totalWatchTime: 0,
        averageCompletionRate: 0,
        totalSaves: 0,
        totalShares: 0,
        totalClicks: 0,
        engagementRate: 0,
        topPerformingVideos: []
      };
    }
    const videoAnalytics = await Promise.all(
      videos2.map((v) => this.getVideoAnalytics(v.videoId, startDate, endDate))
    );
    const totalViews = videoAnalytics.reduce((sum3, v) => sum3 + v.totalViews, 0);
    const totalWatchTime = videoAnalytics.reduce((sum3, v) => sum3 + v.totalWatchTime, 0);
    const averageCompletionRate = videoAnalytics.reduce((sum3, v) => sum3 + v.completionRate, 0) / totalVideos;
    const totalSaves = videoAnalytics.reduce((sum3, v) => sum3 + v.saves, 0);
    const totalShares = videoAnalytics.reduce((sum3, v) => sum3 + v.shares, 0);
    const totalClicks = videoAnalytics.reduce((sum3, v) => sum3 + v.clicks, 0);
    const totalEngagements = totalSaves + totalShares + totalClicks;
    const engagementRate = totalViews > 0 ? totalEngagements / totalViews * 100 : 0;
    const topPerformingVideos = videoAnalytics.map((v, index2) => ({
      contentId: v.contentId,
      title: videos2[index2].title,
      views: v.totalViews,
      completionRate: v.completionRate,
      engagementScore: v.averageEngagementScore
    })).sort((a, b) => b.engagementScore - a.engagementScore).slice(0, 10);
    return {
      creatorId,
      totalVideos,
      totalViews,
      totalWatchTime,
      averageCompletionRate,
      totalSaves,
      totalShares,
      totalClicks,
      engagementRate,
      topPerformingVideos
    };
  }
  /**
   * Get session analytics
   * Requirement 2.6: Track session duration and interactions
   */
  async getSessionAnalytics(sessionId) {
    const session = await db.select().from(exploreFeedSessions).where(eq28(exploreFeedSessions.id, sessionId)).limit(1);
    if (!session[0]) {
      throw new Error("Session not found");
    }
    const engagements = await db.select().from(exploreEngagements).where(eq28(exploreEngagements.sessionId, sessionId));
    const videosViewed = new Set(
      engagements.filter((e) => e.engagementType === "view").map((e) => e.contentId)
    ).size;
    const completions = engagements.filter((e) => e.completed).length;
    const saves = engagements.filter((e) => e.engagementType === "save").length;
    const shares = engagements.filter((e) => e.engagementType === "share").length;
    const clicks = engagements.filter((e) => e.engagementType === "click").length;
    const totalWatchTime = engagements.reduce((sum3, e) => sum3 + (e.watchTime || 0), 0);
    const averageWatchTime = videosViewed > 0 ? totalWatchTime / videosViewed : 0;
    const totalEngagements = saves + shares + clicks;
    const engagementRate = videosViewed > 0 ? totalEngagements / videosViewed * 100 : 0;
    const duration = session[0].endedAt ? (session[0].endedAt.getTime() - session[0].startedAt.getTime()) / 1e3 : 0;
    return {
      sessionId,
      userId: session[0].userId,
      duration,
      videosViewed,
      completions,
      saves,
      shares,
      clicks,
      averageWatchTime,
      engagementRate
    };
  }
  /**
   * Get aggregated metrics for a period
   * Requirement 8.6: Display engagement metrics
   */
  async getAggregatedMetrics(period, creatorId) {
    const now = /* @__PURE__ */ new Date();
    let startDate;
    switch (period) {
      case "day":
        startDate = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
        break;
      case "week":
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
        break;
      case "month":
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
        break;
      case "all":
        startDate = void 0;
        break;
    }
    const filters = [];
    if (startDate) {
      filters.push(gte4(exploreEngagements.createdAt, startDate.toISOString()));
    }
    let contentIds = [];
    if (creatorId) {
      const creatorContent = await db.select({ id: exploreContent.id }).from(exploreContent).where(eq28(exploreContent.creatorId, creatorId));
      contentIds = creatorContent.map((c) => c.id);
    }
    let engagementsQuery = db.select().from(exploreEngagements);
    if (filters.length > 0) {
      engagementsQuery = engagementsQuery.where(and23(...filters));
    }
    const engagements = await engagementsQuery;
    const filteredEngagements = creatorId ? engagements.filter((e) => contentIds.includes(e.contentId)) : engagements;
    const totalViews = filteredEngagements.filter((e) => e.engagementType === "view").length;
    const totalUniqueViewers = new Set(
      filteredEngagements.filter((e) => e.engagementType === "view").map((e) => e.userId)
    ).size;
    const totalWatchTime = filteredEngagements.reduce((sum3, e) => sum3 + (e.watchTime || 0), 0);
    const completions = filteredEngagements.filter((e) => e.completed).length;
    const averageCompletionRate = totalViews > 0 ? completions / totalViews * 100 : 0;
    const saves = filteredEngagements.filter((e) => e.engagementType === "save").length;
    const shares = filteredEngagements.filter((e) => e.engagementType === "share").length;
    const clicks = filteredEngagements.filter((e) => e.engagementType === "click").length;
    const totalEngagements = saves + shares + clicks;
    const engagementRate = totalViews > 0 ? totalEngagements / totalViews * 100 : 0;
    let sessionsQuery = db.select().from(exploreFeedSessions);
    if (startDate) {
      sessionsQuery = sessionsQuery.where(gte4(exploreFeedSessions.startedAt, startDate.toISOString()));
    }
    const sessions = await sessionsQuery;
    const totalSessions = sessions.length;
    const averageSessionDuration = sessions.reduce((sum3, s) => {
      if (s.endedAt) {
        return sum3 + (s.endedAt.getTime() - s.startedAt.getTime()) / 1e3;
      }
      return sum3;
    }, 0) / (totalSessions || 1);
    return {
      period,
      totalViews,
      totalUniqueViewers,
      totalWatchTime,
      averageSessionDuration,
      totalSessions,
      averageCompletionRate,
      totalEngagements,
      engagementRate
    };
  }
  /**
   * Update video completion rate in database
   * Requirement 8.6: Calculate video completion rates
   */
  async updateVideoCompletionRate(videoId) {
    const analytics = await this.getVideoAnalytics(videoId);
    await db.update(exploreDiscoveryVideos).set({
      totalViews: analytics.totalViews,
      completionRate: analytics.completionRate
    }).where(eq28(exploreDiscoveryVideos.id, videoId));
  }
  /**
   * Calculate engagement score
   * Used for ranking and recommendations
   */
  calculateEngagementScore(metrics) {
    if (metrics.views === 0) return 0;
    const completionScore = metrics.completions / metrics.views * 40;
    const saveScore = metrics.saves / metrics.views * 30;
    const shareScore = metrics.shares / metrics.views * 20;
    const clickScore = metrics.clicks / metrics.views * 10;
    const skipPenalty = metrics.skips / metrics.views * -20;
    return Math.max(0, Math.min(100, completionScore + saveScore + shareScore + clickScore + skipPenalty));
  }
  /**
   * Batch update engagement scores for all content
   * Should be run periodically (e.g., hourly)
   */
  async batchUpdateEngagementScores() {
    const videos2 = await db.select({ id: exploreDiscoveryVideos.id }).from(exploreDiscoveryVideos);
    for (const video of videos2) {
      try {
        const analytics = await this.getVideoAnalytics(video.id);
        await db.update(exploreDiscoveryVideos).set({
          totalViews: analytics.totalViews,
          completionRate: analytics.completionRate
        }).where(eq28(exploreDiscoveryVideos.id, video.id));
        await db.update(exploreContent).set({
          viewCount: analytics.totalViews,
          engagementScore: analytics.averageEngagementScore
        }).where(eq28(exploreContent.id, analytics.contentId));
      } catch (error) {
        console.error(`Failed to update analytics for video ${video.id}:`, error);
      }
    }
  }
};
var exploreAnalyticsService = new ExploreAnalyticsService();

// server/exploreAnalyticsRouter.ts
var exploreAnalyticsRouter = router({
  /**
   * Get video analytics
   * Requirement 8.6: Provide analytics on views, watch time, saves, and click-throughs
   */
  getVideoAnalytics: protectedProcedure.input(
    z23.object({
      videoId: z23.number(),
      startDate: z23.date().optional(),
      endDate: z23.date().optional()
    })
  ).query(async ({ input }) => {
    const analytics = await exploreAnalyticsService.getVideoAnalytics(
      input.videoId,
      input.startDate,
      input.endDate
    );
    return {
      success: true,
      data: analytics
    };
  }),
  /**
   * Get creator analytics
   * Requirement 8.6: Generate creator analytics
   */
  getCreatorAnalytics: protectedProcedure.input(
    z23.object({
      creatorId: z23.number().optional(),
      // If not provided, use current user
      startDate: z23.date().optional(),
      endDate: z23.date().optional()
    })
  ).query(async ({ ctx, input }) => {
    const creatorId = input.creatorId || ctx.user.id;
    const analytics = await exploreAnalyticsService.getCreatorAnalytics(
      creatorId,
      input.startDate,
      input.endDate
    );
    return {
      success: true,
      data: analytics
    };
  }),
  /**
   * Get session analytics
   * Requirement 2.6: Track session duration and interactions
   */
  getSessionAnalytics: protectedProcedure.input(
    z23.object({
      sessionId: z23.number()
    })
  ).query(async ({ input }) => {
    const analytics = await exploreAnalyticsService.getSessionAnalytics(input.sessionId);
    return {
      success: true,
      data: analytics
    };
  }),
  /**
   * Get aggregated metrics
   * Requirement 8.6: Display engagement metrics
   */
  getAggregatedMetrics: protectedProcedure.input(
    z23.object({
      period: z23.enum(["day", "week", "month", "all"]),
      creatorId: z23.number().optional()
    })
  ).query(async ({ input }) => {
    const metrics = await exploreAnalyticsService.getAggregatedMetrics(
      input.period,
      input.creatorId
    );
    return {
      success: true,
      data: metrics
    };
  }),
  /**
   * Get my analytics dashboard
   * Requirement 8.6: Creator analytics dashboard
   */
  getMyAnalyticsDashboard: protectedProcedure.input(
    z23.object({
      period: z23.enum(["day", "week", "month", "all"]).default("week")
    })
  ).query(async ({ ctx, input }) => {
    const creatorAnalytics = await exploreAnalyticsService.getCreatorAnalytics(ctx.user.id);
    const periodMetrics = await exploreAnalyticsService.getAggregatedMetrics(
      input.period,
      ctx.user.id
    );
    return {
      success: true,
      data: {
        overview: {
          totalVideos: creatorAnalytics.totalVideos,
          totalViews: creatorAnalytics.totalViews,
          totalWatchTime: creatorAnalytics.totalWatchTime,
          averageCompletionRate: creatorAnalytics.averageCompletionRate,
          engagementRate: creatorAnalytics.engagementRate
        },
        periodMetrics: {
          period: input.period,
          views: periodMetrics.totalViews,
          uniqueViewers: periodMetrics.totalUniqueViewers,
          watchTime: periodMetrics.totalWatchTime,
          sessions: periodMetrics.totalSessions,
          averageSessionDuration: periodMetrics.averageSessionDuration,
          completionRate: periodMetrics.averageCompletionRate,
          engagementRate: periodMetrics.engagementRate
        },
        topPerformingVideos: creatorAnalytics.topPerformingVideos,
        engagement: {
          saves: creatorAnalytics.totalSaves,
          shares: creatorAnalytics.totalShares,
          clicks: creatorAnalytics.totalClicks
        }
      }
    };
  }),
  /**
   * Trigger batch update of engagement scores
   * Admin only - should be called periodically
   */
  batchUpdateEngagementScores: protectedProcedure.mutation(async ({ ctx }) => {
    await exploreAnalyticsService.batchUpdateEngagementScores();
    return {
      success: true,
      message: "Engagement scores updated successfully"
    };
  })
});

// server/analyticsRouter.ts
init_db();
init_schema();
import { z as z24 } from "zod";
var analyticsRouter = router({
  // Fire-and-forget tracking endpoint
  track: publicProcedure.input(z24.object({
    event: z24.string(),
    properties: z24.record(z24.any()).optional(),
    sessionId: z24.string().optional()
  })).mutation(async ({ input, ctx }) => {
    const { event, properties: properties4, sessionId } = input;
    const userId = ctx.session?.user?.id;
    try {
      await db.insert(locationAnalyticsEvents).values({
        eventType: event,
        metadata: properties4,
        sessionId: sessionId || "anonymous",
        userId: userId ? parseInt(userId.toString()) : null,
        // Extract known ID fields from properties for indexed columns
        locationId: properties4?.locationId ? parseInt(properties4.locationId.toString()) : null,
        developmentId: properties4?.developmentId ? parseInt(properties4.developmentId.toString()) : null,
        listingId: properties4?.listingId ? parseInt(properties4.listingId.toString()) : null,
        targetId: properties4?.adId || properties4?.agentId ? parseInt((properties4.adId || properties4.agentId).toString()) : null
      });
      return { success: true };
    } catch (error) {
      console.error("Analytics tracking failed:", error);
      return { success: false, error: "Tracking failed" };
    }
  })
});

// server/similarPropertiesRouter.ts
import { z as z25 } from "zod";

// server/services/similarPropertiesService.ts
init_db();
init_schema();
import { eq as eq29, and as and24, gte as gte5, lte as lte5, ne as ne2, inArray as inArray6 } from "drizzle-orm";
var SimilarPropertiesService = class {
  // Default similarity weights
  defaultWeights = {
    priceMatch: 0.35,
    // 35% weight
    locationMatch: 0.25,
    // 25% weight
    propertyTypeMatch: 0.2,
    // 20% weight
    bedroomsMatch: 0.1,
    // 10% weight
    bathroomsMatch: 0.05,
    // 5% weight
    areaMatch: 0.05
    // 5% weight
  };
  /**
   * Find similar properties based on a reference property
   * Requirement 15.1: Generate list of similar properties
   * Requirement 15.3: Consider price range (Â±20%), location, and features
   */
  async findSimilarProperties(propertyId, limit = 10, weights) {
    const referenceProperty = await db.select().from(properties).where(eq29(properties.id, propertyId)).limit(1);
    if (!referenceProperty[0]) {
      throw new Error("Reference property not found");
    }
    const ref = referenceProperty[0];
    const priceMin = ref.price ? ref.price * 0.8 : 0;
    const priceMax = ref.price ? ref.price * 1.2 : Number.MAX_SAFE_INTEGER;
    let candidates = await db.select({
      id: properties.id,
      title: properties.title,
      price: properties.price,
      city: properties.city,
      province: properties.province,
      suburbId: properties.suburbId,
      propertyType: properties.propertyType,
      bedrooms: properties.bedrooms,
      bathrooms: properties.bathrooms,
      area: properties.area,
      latitude: properties.latitude,
      longitude: properties.longitude
    }).from(properties).where(
      and24(
        ne2(properties.id, propertyId),
        // Exclude reference property
        eq29(properties.status, "available"),
        gte5(properties.price, priceMin),
        lte5(properties.price, priceMax)
      )
    ).limit(100);
    if (candidates.length < limit) {
      candidates = await this.expandSearch(ref, propertyId, limit * 2);
    }
    const mergedWeights = { ...this.defaultWeights, ...weights };
    const scoredProperties = candidates.map((candidate) => {
      const score = this.calculateSimilarityScore(ref, candidate, mergedWeights);
      const reasons = this.getMatchReasons(ref, candidate);
      return {
        contentId: 0,
        // Will be populated from explore_content if available
        propertyId: candidate.id,
        title: candidate.title,
        price: candidate.price || 0,
        location: `${candidate.city}, ${candidate.province}`,
        propertyType: candidate.propertyType,
        bedrooms: candidate.bedrooms || void 0,
        bathrooms: candidate.bathrooms || void 0,
        area: candidate.area || void 0,
        thumbnailUrl: void 0,
        // Will be populated from explore_content if available
        similarityScore: score,
        matchReasons: reasons
      };
    });
    const sortedProperties = scoredProperties.sort((a, b) => b.similarityScore - a.similarityScore).slice(0, limit);
    const propertyIds = sortedProperties.map((p) => p.propertyId);
    const exploreData = await db.select({
      propertyId: exploreContent.id,
      contentId: exploreContent.id,
      thumbnailUrl: exploreContent.thumbnailUrl
    }).from(exploreContent).where(
      and24(
        inArray6(exploreContent.id, propertyIds),
        eq29(exploreContent.contentType, "property")
      )
    );
    const exploreMap = new Map(exploreData.map((e) => [e.propertyId, e]));
    sortedProperties.forEach((prop) => {
      const exploreInfo = exploreMap.get(prop.propertyId);
      if (exploreInfo) {
        prop.contentId = exploreInfo.contentId;
        prop.thumbnailUrl = exploreInfo.thumbnailUrl || void 0;
      }
    });
    return sortedProperties;
  }
  /**
   * Calculate similarity score between two properties
   * Returns a score between 0 and 100
   */
  calculateSimilarityScore(reference, candidate, weights) {
    let totalScore = 0;
    if (reference.price && candidate.price) {
      const priceDiff = Math.abs(reference.price - candidate.price) / reference.price;
      const priceScore = Math.max(0, 100 - priceDiff * 500);
      totalScore += priceScore * weights.priceMatch;
    }
    const locationScore = this.calculateLocationScore(reference, candidate);
    totalScore += locationScore * weights.locationMatch;
    if (reference.propertyType === candidate.propertyType) {
      totalScore += 100 * weights.propertyTypeMatch;
    }
    if (reference.bedrooms && candidate.bedrooms) {
      const bedroomDiff = Math.abs(reference.bedrooms - candidate.bedrooms);
      const bedroomScore = Math.max(0, 100 - bedroomDiff * 25);
      totalScore += bedroomScore * weights.bedroomsMatch;
    }
    if (reference.bathrooms && candidate.bathrooms) {
      const bathroomDiff = Math.abs(reference.bathrooms - candidate.bathrooms);
      const bathroomScore = Math.max(0, 100 - bathroomDiff * 25);
      totalScore += bathroomScore * weights.bathroomsMatch;
    }
    if (reference.area && candidate.area) {
      const areaDiff = Math.abs(reference.area - candidate.area) / reference.area;
      const areaScore = Math.max(0, 100 - areaDiff * 500);
      totalScore += areaScore * weights.areaMatch;
    }
    return Math.round(totalScore);
  }
  /**
   * Calculate location similarity score
   * Same suburb = 100, same city = 70, same province = 40, different = 0
   */
  calculateLocationScore(reference, candidate) {
    if (reference.suburbId && candidate.suburbId && reference.suburbId === candidate.suburbId) {
      return 100;
    }
    if (reference.city && candidate.city && reference.city === candidate.city) {
      return 70;
    }
    if (reference.province && candidate.province && reference.province === candidate.province) {
      return 40;
    }
    if (reference.latitude && reference.longitude && candidate.latitude && candidate.longitude) {
      const distance = this.calculateDistance(
        reference.latitude,
        reference.longitude,
        candidate.latitude,
        candidate.longitude
      );
      if (distance <= 5) return 90;
      if (distance <= 10) return 70;
      if (distance <= 20) return 50;
      if (distance <= 50) return 20;
    }
    return 0;
  }
  /**
   * Calculate distance between two coordinates in kilometers
   * Using Haversine formula
   */
  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = this.toRad(lat2 - lat1);
    const dLon = this.toRad(lon2 - lon1);
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  toRad(degrees) {
    return degrees * Math.PI / 180;
  }
  /**
   * Get human-readable match reasons
   */
  getMatchReasons(reference, candidate) {
    const reasons = [];
    if (reference.price && candidate.price) {
      const priceDiff = Math.abs(reference.price - candidate.price) / reference.price;
      if (priceDiff <= 0.1) {
        reasons.push("Similar price");
      } else if (priceDiff <= 0.2) {
        reasons.push("Comparable price");
      }
    }
    if (reference.suburbId === candidate.suburbId && reference.suburbId) {
      reasons.push("Same suburb");
    } else if (reference.city === candidate.city) {
      reasons.push("Same city");
    } else if (reference.province === candidate.province) {
      reasons.push("Same province");
    }
    if (reference.propertyType === candidate.propertyType) {
      reasons.push("Same property type");
    }
    if (reference.bedrooms === candidate.bedrooms) {
      reasons.push("Same bedrooms");
    }
    if (reference.bathrooms === candidate.bathrooms) {
      reasons.push("Same bathrooms");
    }
    if (reference.area && candidate.area) {
      const areaDiff = Math.abs(reference.area - candidate.area) / reference.area;
      if (areaDiff <= 0.1) {
        reasons.push("Similar size");
      }
    }
    return reasons;
  }
  /**
   * Expand search when not enough similar properties found
   * Requirement 15.5: Expand search radius and adjust price range
   */
  async expandSearch(reference, excludeId, limit) {
    const priceMin = reference.price ? reference.price * 0.6 : 0;
    const priceMax = reference.price ? reference.price * 1.4 : Number.MAX_SAFE_INTEGER;
    const expanded = await db.select({
      id: properties.id,
      title: properties.title,
      price: properties.price,
      city: properties.city,
      province: properties.province,
      suburbId: properties.suburbId,
      propertyType: properties.propertyType,
      bedrooms: properties.bedrooms,
      bathrooms: properties.bathrooms,
      area: properties.area,
      latitude: properties.latitude,
      longitude: properties.longitude
    }).from(properties).where(
      and24(
        ne2(properties.id, excludeId),
        eq29(properties.status, "available"),
        gte5(properties.price, priceMin),
        lte5(properties.price, priceMax)
      )
    ).limit(limit);
    return expanded;
  }
  /**
   * Track which similar properties get engagement
   * Requirement 15.4: Adjust similarity weights based on interactions
   */
  async recordSimilarPropertyEngagement(referencePropertyId, similarPropertyId, engagementType) {
    console.log(
      `Similar property engagement: ${referencePropertyId} -> ${similarPropertyId} (${engagementType})`
    );
  }
  /**
   * Get refined weights based on user engagement history
   * Requirement 15.4: Algorithm refinement
   */
  async getRefinedWeights(userId) {
    return this.defaultWeights;
  }
};
var similarPropertiesService = new SimilarPropertiesService();

// server/similarPropertiesRouter.ts
var similarPropertiesRouter = router({
  /**
   * Find similar properties
   * Requirement 15.1: Generate list of similar properties
   * Requirement 15.3: Consider price range (Â±20%), location, and features
   */
  findSimilar: publicProcedure.input(
    z25.object({
      propertyId: z25.number(),
      limit: z25.number().min(1).max(50).default(10),
      weights: z25.object({
        priceMatch: z25.number().min(0).max(1).optional(),
        locationMatch: z25.number().min(0).max(1).optional(),
        propertyTypeMatch: z25.number().min(0).max(1).optional(),
        bedroomsMatch: z25.number().min(0).max(1).optional(),
        bathroomsMatch: z25.number().min(0).max(1).optional(),
        areaMatch: z25.number().min(0).max(1).optional()
      }).optional()
    })
  ).query(async ({ input }) => {
    const similarProperties = await similarPropertiesService.findSimilarProperties(
      input.propertyId,
      input.limit,
      input.weights
    );
    return {
      success: true,
      data: {
        properties: similarProperties,
        total: similarProperties.length
      }
    };
  }),
  /**
   * Get similar properties for Explore feed
   * Requirement 15.2: Display in "Similar to What You Viewed" section
   */
  getSimilarForFeed: protectedProcedure.input(
    z25.object({
      propertyId: z25.number(),
      limit: z25.number().min(1).max(20).default(10)
    })
  ).query(async ({ ctx, input }) => {
    const weights = await similarPropertiesService.getRefinedWeights(ctx.user.id);
    const similarProperties = await similarPropertiesService.findSimilarProperties(
      input.propertyId,
      input.limit,
      weights
    );
    return {
      success: true,
      data: {
        sectionTitle: "Similar to What You Viewed",
        properties: similarProperties,
        referencePropertyId: input.propertyId
      }
    };
  }),
  /**
   * Get similar properties based on viewing history
   * Requirement 15.2: Display similar properties based on history
   */
  getSimilarFromHistory: protectedProcedure.input(
    z25.object({
      limit: z25.number().min(1).max(50).default(20)
    })
  ).query(async ({ ctx, input }) => {
    return {
      success: true,
      data: {
        sectionTitle: "Based on Your Recent Views",
        properties: [],
        message: "Start viewing properties to see personalized recommendations"
      }
    };
  }),
  /**
   * Record engagement with similar property
   * Requirement 15.4: Track which similar properties get engagement
   */
  recordEngagement: protectedProcedure.input(
    z25.object({
      referencePropertyId: z25.number(),
      similarPropertyId: z25.number(),
      engagementType: z25.enum(["view", "save", "click"])
    })
  ).mutation(async ({ input }) => {
    await similarPropertiesService.recordSimilarPropertyEngagement(
      input.referencePropertyId,
      input.similarPropertyId,
      input.engagementType
    );
    return {
      success: true,
      message: "Engagement recorded"
    };
  }),
  /**
   * Get similarity explanation
   * Shows why properties are considered similar
   */
  getExplanation: publicProcedure.input(
    z25.object({
      propertyId: z25.number(),
      similarPropertyId: z25.number()
    })
  ).query(async ({ input }) => {
    const similar = await similarPropertiesService.findSimilarProperties(
      input.propertyId,
      50
      // Get more to find the specific one
    );
    const match = similar.find((p) => p.propertyId === input.similarPropertyId);
    if (!match) {
      return {
        success: false,
        error: "Properties not found or not similar enough"
      };
    }
    return {
      success: true,
      data: {
        similarityScore: match.similarityScore,
        matchReasons: match.matchReasons,
        explanation: `This property matches ${match.similarityScore}% based on: ${match.matchReasons.join(", ")}`
      }
    };
  })
});

// server/cacheRouter.ts
import { z as z26 } from "zod";
init_redis();

// server/services/cacheIntegrationService.ts
init_redis();
async function getCacheStats() {
  return await redisCache.getStats();
}

// server/cacheRouter.ts
var cacheRouter = router({
  /**
   * Get cache statistics
   */
  getStats: publicProcedure.query(async () => {
    try {
      const stats2 = await getCacheStats();
      return {
        success: true,
        stats: {
          connected: stats2.connected,
          totalKeys: stats2.keys,
          memory: stats2.memory || "N/A",
          backend: stats2.connected ? "Redis" : "In-Memory Fallback"
        }
      };
    } catch (error) {
      console.error("Error fetching cache stats:", error);
      throw new Error("Failed to fetch cache statistics");
    }
  }),
  /**
   * Clear all cache (admin only)
   */
  clearAll: protectedProcedure.mutation(async ({ ctx }) => {
    try {
      await redisCache.delByPattern("explore:*");
      return {
        success: true,
        message: "Cache cleared successfully"
      };
    } catch (error) {
      console.error("Error clearing cache:", error);
      throw new Error("Failed to clear cache");
    }
  }),
  /**
   * Clear specific cache pattern (admin only)
   */
  clearPattern: protectedProcedure.input(
    z26.object({
      pattern: z26.string()
    })
  ).mutation(async ({ ctx, input }) => {
    try {
      await redisCache.delByPattern(`explore:${input.pattern}:*`);
      return {
        success: true,
        message: `Cache pattern 'explore:${input.pattern}:*' cleared successfully`
      };
    } catch (error) {
      console.error("Error clearing cache pattern:", error);
      throw new Error("Failed to clear cache pattern");
    }
  }),
  /**
   * Health check for cache connection
   */
  health: publicProcedure.query(async () => {
    try {
      const stats2 = await getCacheStats();
      return {
        success: true,
        healthy: true,
        connected: stats2.connected,
        backend: stats2.connected ? "Redis" : "In-Memory Fallback"
      };
    } catch (error) {
      return {
        success: false,
        healthy: false,
        error: "Cache service unavailable"
      };
    }
  })
});

// server/locationPagesRouter.ts
import { z as z27 } from "zod";

// server/services/locationPagesService.improved.ts
init_db();
init_schema();
import { eq as eq30, and as and25, desc as desc18, sql as sql23 } from "drizzle-orm";

// server/_core/cache/redis.ts
import Redis from "ioredis";
var RedisCacheManager = class {
  redis = null;
  isConnected = false;
  fallbackMode = false;
  metrics = {
    hits: 0,
    misses: 0,
    connectionErrors: 0,
    timeoutErrors: 0,
    fallbackActivations: 0,
    memoryUsage: 0,
    keyCount: 0,
    evictions: 0,
    averageLatency: 0
  };
  // Cache configuration
  cacheConfigs = [
    // Price Analytics (Low frequency updates)
    { key: "pa:*:avg_price", ttl: 24 * 3600, description: "Average prices - 24 hours" },
    { key: "pa:*:price_trend", ttl: 12 * 3600, description: "Price trends - 12 hours" },
    { key: "pa:*:market_stats", ttl: 6 * 3600, description: "Market statistics - 6 hours" },
    { key: "pa:*:growth_metrics", ttl: 6 * 3600, description: "Growth metrics - 6 hours" },
    // Property Data (Medium frequency updates)
    { key: "prop:featured_listings", ttl: 2 * 3600, description: "Featured properties - 2 hours" },
    { key: "prop:*:full_data", ttl: 1 * 3600, description: "Property details - 1 hour" },
    { key: "prop:search:*", ttl: 30 * 60, description: "Search results - 30 minutes" },
    // User Preferences (High importance, lower TTL)
    { key: "up:user:*:preferences", ttl: 7 * 24 * 3600, description: "User preferences - 7 days" },
    { key: "up:user:*:recommendations", ttl: 1 * 3600, description: "Recommendations - 1 hour" },
    // Location Data (Relatively static)
    { key: "loc:*:suburbs", ttl: 24 * 7 * 24 * 3600, description: "Suburb data - 1 week" },
    { key: "loc:*:cities", ttl: 24 * 7 * 24 * 3600, description: "City data - 1 week" },
    // Session Data (Short-lived)
    { key: "session:*", ttl: 30 * 60, description: "User sessions - 30 minutes" },
    // Temporary Data (Very short-lived)
    { key: "temp:*", ttl: 15 * 60, description: "Temporary data - 15 minutes" }
  ];
  constructor() {
    try {
      this.initializeRedis();
    } catch (error) {
      console.warn("Redis initialization failed, running in fallback mode:", error);
      this.fallbackMode = true;
    }
  }
  /**
   * Initialize Redis connection
   */
  initializeRedis() {
    if (!process.env.REDIS_HOST) {
      console.warn("REDIS_HOST not configured, skipping Redis initialization");
      this.fallbackMode = true;
      return;
    }
    const config = {
      host: process.env.REDIS_HOST || "localhost",
      port: parseInt(process.env.REDIS_PORT || "6379"),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || "0"),
      retryDelayOnFailover: 100,
      retryAttempts: 3,
      maxRetriesPerRequest: 3,
      enableAutoPipelining: true,
      lazyConnect: true,
      connectTimeout: 5e3,
      commandTimeout: 2e3
    };
    this.redis = new Redis(config);
    this.redis.on("connect", () => {
      console.log("Redis: Connected successfully");
      this.isConnected = true;
      this.fallbackMode = false;
    });
    this.redis.on("error", (error) => {
      console.error("Redis: Connection error:", error);
      this.handleRedisFailure(error);
    });
    this.redis.on("close", () => {
      console.warn("Redis: Connection closed");
      this.isConnected = false;
    });
    this.redis.on("reconnecting", (delay, retry) => {
      console.log(`Redis: Reconnecting in ${delay}ms (attempt ${retry})`);
    });
    this.redis.on("end", () => {
      console.log("Redis: Connection ended");
      this.isConnected = false;
    });
  }
  /**
   * Handle Redis failure and switch to fallback mode
   */
  handleRedisFailure(error) {
    this.metrics.connectionErrors++;
    this.fallbackMode = true;
    this.isConnected = false;
    console.error("Redis cache unavailable, switching to fallback mode:", error.message);
    setTimeout(() => {
      this.checkRedisConnection();
    }, 5e3);
  }
  /**
   * Check Redis connection and attempt reconnection
   */
  async checkRedisConnection() {
    if (!this.redis) return;
    try {
      await this.redis.ping();
      this.isConnected = true;
      this.fallbackMode = false;
      console.log("Redis: Connection restored");
    } catch (error) {
      console.error("Redis: Reconnection failed:", error.message);
      setTimeout(() => {
        this.checkRedisConnection();
      }, 1e4);
    }
  }
  /**
   * Get TTL for a specific cache key
   */
  getTTLForKey(key) {
    const config = this.cacheConfigs.find((c) => this.matchesKeyPattern(key, c.key));
    return config?.ttl || 3600;
  }
  /**
   * Check if key matches pattern
   */
  matchesKeyPattern(key, pattern) {
    if (pattern.includes("*")) {
      const regex = new RegExp(pattern.replace("*", ".*"));
      return regex.test(key);
    }
    return key === pattern;
  }
  /**
   * Get value from cache with fallback
   */
  async get(key, fetchFn, fallback) {
    const startTime = Date.now();
    try {
      if (!this.fallbackMode && this.redis && this.isConnected) {
        const cached = await this.redis.get(key);
        if (cached) {
          this.metrics.hits++;
          const latency = Date.now() - startTime;
          this.updateAverageLatency(latency);
          return JSON.parse(cached);
        }
        this.metrics.misses++;
      }
      const result = await this.fetchWithTimeout(fetchFn, fallback?.timeout || 5e3);
      if (this.redis && !this.fallbackMode && this.isConnected && result) {
        const ttl = this.getTTLForKey(key);
        await this.set(key, result, ttl);
      }
      return result;
    } catch (error) {
      this.metrics.timeoutErrors++;
      if (error instanceof Error && error.message.includes("redis")) {
        this.handleRedisFailure(error);
      }
      const result = await fetchFn();
      if (this.fallbackMode) {
        this.metrics.fallbackActivations++;
      }
      return result;
    }
  }
  /**
   * Set value in cache with TTL
   */
  async set(key, value, ttl) {
    if (this.fallbackMode || !this.redis || !this.isConnected) {
      return;
    }
    try {
      const serialized = JSON.stringify(value);
      const finalTTL = ttl || this.getTTLForKey(key);
      if (finalTTL > 0) {
        await this.redis.setex(key, finalTTL, serialized);
      } else {
        await this.redis.set(key, serialized);
      }
    } catch (error) {
      console.error("Redis: Set operation failed:", error);
      this.metrics.connectionErrors++;
    }
  }
  /**
   * Delete specific keys from cache
   */
  async del(key) {
    if (this.fallbackMode || !this.redis || !this.isConnected) {
      return;
    }
    try {
      if (Array.isArray(key)) {
        await this.redis.del(...key);
      } else {
        await this.redis.del(key);
      }
    } catch (error) {
      console.error("Redis: Delete operation failed:", error);
      this.metrics.connectionErrors++;
    }
  }
  /**
   * Delete keys matching pattern
   */
  async delPattern(pattern) {
    if (this.fallbackMode || !this.redis || !this.isConnected) {
      return;
    }
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    } catch (error) {
      console.error("Redis: Pattern delete operation failed:", error);
      this.metrics.connectionErrors++;
    }
  }
  /**
   * Check if key exists in cache
   */
  async exists(key) {
    if (this.fallbackMode || !this.redis || !this.isConnected) {
      return false;
    }
    try {
      const result = await this.redis.exists(key);
      return result === 1;
    } catch (error) {
      console.error("Redis: Exists operation failed:", error);
      this.metrics.connectionErrors++;
      return false;
    }
  }
  /**
   * Get cache statistics
   */
  async getStats() {
    try {
      if (this.redis && this.isConnected) {
        const info = await this.redis.info("memory");
        const dbSize = await this.redis.dbSize();
        this.metrics.memoryUsage = this.parseMemoryUsage(info);
        this.metrics.keyCount = dbSize;
      }
      return { ...this.metrics };
    } catch (error) {
      console.error("Redis: Stats collection failed:", error);
      return { ...this.metrics };
    }
  }
  /**
   * Clear all cache data
   */
  async clear() {
    if (this.fallbackMode || !this.redis || !this.isConnected) {
      return;
    }
    try {
      await this.redis.flushall();
    } catch (error) {
      console.error("Redis: Clear operation failed:", error);
      this.metrics.connectionErrors++;
    }
  }
  /**
   * Gracefully close Redis connection
   */
  async close() {
    if (this.redis) {
      try {
        await this.redis.quit();
      } catch (error) {
        console.error("Redis: Close operation failed:", error);
        await this.redis.disconnect();
      }
    }
  }
  /**
   * Update average latency metric
   */
  updateAverageLatency(latency) {
    const currentAvg = this.metrics.averageLatency;
    const totalRequests = this.metrics.hits + this.metrics.misses;
    this.metrics.averageLatency = Math.round(
      (currentAvg * (totalRequests - 1) + latency) / totalRequests
    );
  }
  /**
   * Parse memory usage from Redis INFO command
   */
  parseMemoryUsage(info) {
    const match = info.match(/used_memory_human:(\S+)/);
    if (match) {
      const memoryStr = match[1];
      if (memoryStr.includes("M")) {
        return parseFloat(memoryStr.replace("M", "")) * 1024 * 1024;
      } else if (memoryStr.includes("G")) {
        return parseFloat(memoryStr.replace("G", "")) * 1024 * 1024 * 1024;
      }
    }
    return 0;
  }
  /**
   * Fetch with timeout
   */
  async fetchWithTimeout(fetchFn, timeout) {
    return await Promise.race([
      fetchFn(),
      new Promise(
        (_, reject) => setTimeout(() => reject(new Error("Cache fetch timeout")), timeout)
      )
    ]);
  }
};
var PriceAnalyticsCache = class {
  cacheManager;
  constructor(cacheManager) {
    this.cacheManager = cacheManager;
  }
  /**
   * Get suburb price analytics from cache
   */
  async getSuburbAnalytics(suburbId) {
    const cacheKey = `${"pa:" /* PRICE_ANALYTICS */}suburb:${suburbId}:analytics`;
    return await this.cacheManager.get(
      cacheKey,
      async () => {
        console.log(`Fetching suburb analytics for ID: ${suburbId} from database`);
        return {
          suburbId,
          currentAvgPrice: Math.floor(Math.random() * 2e6) + 5e5,
          currentMedianPrice: Math.floor(Math.random() * 18e5) + 4e5,
          priceGrowthPercent: Math.floor(Math.random() * 20) - 5,
          totalProperties: Math.floor(Math.random() * 500) + 100,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
      },
      {
        strategy: "database",
        timeout: 5e3,
        maxRetries: 3,
        logLevel: "warn"
      }
    );
  }
  /**
   * Get city price analytics from cache
   */
  async getCityAnalytics(cityId) {
    const cacheKey = `${"pa:" /* PRICE_ANALYTICS */}city:${cityId}:analytics`;
    return await this.cacheManager.get(
      cacheKey,
      async () => {
        console.log(`Fetching city analytics for ID: ${cityId} from database`);
        return {
          cityId,
          currentAvgPrice: Math.floor(Math.random() * 25e5) + 8e5,
          currentMedianPrice: Math.floor(Math.random() * 22e5) + 6e5,
          priceGrowthPercent: Math.floor(Math.random() * 25) - 8,
          totalProperties: Math.floor(Math.random() * 2e3) + 500,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
      },
      {
        strategy: "database",
        timeout: 5e3,
        maxRetries: 3,
        logLevel: "warn"
      }
    );
  }
  /**
   * Get province price analytics from cache
   */
  async getProvinceAnalytics(provinceId) {
    const cacheKey = `${"pa:" /* PRICE_ANALYTICS */}province:${provinceId}:analytics`;
    return await this.cacheManager.get(
      cacheKey,
      async () => {
        console.log(`Fetching province analytics for ID: ${provinceId} from database`);
        return {
          provinceId,
          currentAvgPrice: Math.floor(Math.random() * 3e6) + 1e6,
          currentMedianPrice: Math.floor(Math.random() * 28e5) + 8e5,
          priceGrowthPercent: Math.floor(Math.random() * 30) - 10,
          totalProperties: Math.floor(Math.random() * 5e3) + 1e3,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
      },
      {
        strategy: "database",
        timeout: 5e3,
        maxRetries: 3,
        logLevel: "warn"
      }
    );
  }
  /**
   * Invalidate price analytics cache for location
   */
  async invalidateLocationAnalytics(locationId, locationType) {
    const pattern = `${"pa:" /* PRICE_ANALYTICS */}${locationType}:${locationId}:*`;
    await this.cacheManager.delPattern(pattern);
  }
  /**
   * Invalidate all price analytics cache
   */
  async invalidateAllPriceAnalytics() {
    await this.cacheManager.delPattern(`${"pa:" /* PRICE_ANALYTICS */}*`);
  }
};
var CacheInvalidator = class {
  cacheManager;
  constructor(cacheManager) {
    this.cacheManager = cacheManager;
  }
  /**
   * Invalidate cache based on trigger and context
   */
  async invalidate(trigger, context) {
    const rules = [
      // Price Analytics Invalidation
      {
        trigger: "property_price_update",
        pattern: `${"pa:" /* PRICE_ANALYTICS */}*:avg_price`,
        strategy: "pattern"
      },
      {
        trigger: "property_created",
        pattern: `${"pa:" /* PRICE_ANALYTICS */}*:market_stats`,
        strategy: "pattern"
      },
      {
        trigger: "property_sold",
        pattern: `${"pa:" /* PRICE_ANALYTICS */}*:active_listings`,
        strategy: "pattern"
      },
      // Property Data Invalidation
      {
        trigger: "property_updated",
        pattern: `${"prop:" /* PROPERTY_DATA */}*:full_data`,
        strategy: "pattern"
      },
      {
        trigger: "property_created",
        pattern: `${"prop:" /* PROPERTY_DATA */}featured_listings`,
        strategy: "exact"
      },
      // Search Result Invalidation
      {
        trigger: "property_updated",
        pattern: `${"prop:" /* PROPERTY_DATA */}search:*`,
        strategy: "pattern"
      }
    ];
    const rule = rules.find((r) => r.trigger === trigger);
    if (!rule) return;
    switch (rule.strategy) {
      case "exact":
        await this.cacheManager.del(rule.pattern);
        break;
      case "pattern":
        await this.cacheManager.delPattern(rule.pattern);
        break;
      case "tag":
        await this.invalidateByTag(context);
        break;
    }
    console.log(`Cache invalidated for trigger: ${trigger}`);
  }
  /**
   * Invalidate cache by tag
   */
  async invalidateByTag(context) {
    if (context.userId) {
      await this.cacheManager.delPattern(
        `${"up:" /* USER_PREFERENCES */}user:${context.userId}:*`
      );
    }
  }
};
var redisCacheManager = null;
var priceAnalyticsCache = null;
var cacheInvalidator = null;
async function initializeCache() {
  redisCacheManager = new RedisCacheManager();
  priceAnalyticsCache = new PriceAnalyticsCache(redisCacheManager);
  cacheInvalidator = new CacheInvalidator(redisCacheManager);
  console.log("Redis cache services initialized");
}
async function shutdownCache() {
  if (redisCacheManager) {
    await redisCacheManager.close();
    console.log("Redis cache services shutdown");
  }
}

// server/data/marketIntelligence.ts
var MARKET_INTELLIGENCE = [
  // --- GAUTENG CITIES ---
  {
    slug: "johannesburg",
    name: "Johannesburg",
    province: "gauteng",
    level: "city",
    avgSale: 28e5,
    sentimentBase: 4.1,
    tier: "upper"
  },
  {
    slug: "pretoria",
    name: "Pretoria",
    province: "gauteng",
    level: "city",
    avgSale: 24e5,
    sentimentBase: 4,
    tier: "upper"
  },
  {
    slug: "sandton",
    // Listing Sandton as a City-level entity for navigation ease, though effectively a major metro area
    name: "Sandton",
    province: "gauteng",
    level: "city",
    avgSale: 46e5,
    avgRent: 32e3,
    sentimentBase: 4.6,
    tier: "luxury"
  },
  {
    slug: "midrand",
    name: "Midrand",
    province: "gauteng",
    level: "city",
    avgSale: 18e5,
    sentimentBase: 4.2,
    tier: "mid"
  },
  {
    slug: "centurion",
    name: "Centurion",
    province: "gauteng",
    level: "city",
    avgSale: 195e4,
    sentimentBase: 4.3,
    tier: "mid"
  },
  // --- GAUTENG SUBURBS ---
  {
    slug: "sandton",
    // Also handled as suburb context if resolved under JHB
    name: "Sandton",
    province: "gauteng",
    level: "suburb",
    parentSlug: "johannesburg",
    avgSale: 46e5,
    avgRent: 32e3,
    sentimentBase: 4.6,
    tier: "luxury"
  },
  {
    slug: "hyde-park",
    name: "Hyde Park",
    province: "gauteng",
    level: "suburb",
    parentSlug: "sandton",
    // Or Johannesburg depending on URL structure
    avgSale: 85e5,
    avgRent: 45e3,
    sentimentBase: 4.8,
    tier: "luxury"
  },
  {
    slug: "bryanston",
    name: "Bryanston",
    province: "gauteng",
    level: "suburb",
    parentSlug: "sandton",
    avgSale: 39e5,
    avgRent: 25e3,
    sentimentBase: 4.5,
    tier: "upper"
  },
  {
    slug: "waterkloof",
    name: "Waterkloof",
    province: "gauteng",
    level: "suburb",
    parentSlug: "pretoria",
    avgSale: 385e4,
    avgRent: 22e3,
    sentimentBase: 4.7,
    tier: "luxury"
  },
  // --- WESTERN CAPE CITIES ---
  {
    slug: "cape-town",
    name: "Cape Town",
    province: "western-cape",
    level: "city",
    avgSale: 52e5,
    avgRent: 35e3,
    sentimentBase: 4.9,
    tier: "luxury"
  },
  {
    slug: "stellenbosch",
    name: "Stellenbosch",
    province: "western-cape",
    level: "city",
    avgSale: 38e5,
    sentimentBase: 4.7,
    tier: "upper"
  },
  {
    slug: "somerset-west",
    name: "Somerset West",
    province: "western-cape",
    level: "city",
    avgSale: 32e5,
    sentimentBase: 4.5,
    tier: "upper"
  },
  // --- WESTERN CAPE SUBURBS ---
  {
    slug: "camps-bay",
    name: "Camps Bay",
    province: "western-cape",
    level: "suburb",
    parentSlug: "cape-town",
    avgSale: 125e5,
    avgRent: 55e3,
    sentimentBase: 4.9,
    tier: "luxury"
  },
  {
    slug: "clifton",
    name: "Clifton",
    province: "western-cape",
    level: "suburb",
    parentSlug: "cape-town",
    avgSale: 22e6,
    avgRent: 85e3,
    sentimentBase: 4.9,
    tier: "luxury"
  },
  {
    slug: "sea-point",
    name: "Sea Point",
    province: "western-cape",
    level: "suburb",
    parentSlug: "cape-town",
    avgSale: 45e5,
    avgRent: 28e3,
    sentimentBase: 4.6,
    tier: "upper"
  },
  // --- KZN ---
  {
    slug: "durban",
    name: "Durban",
    province: "kwazulu-natal",
    level: "city",
    avgSale: 15e5,
    sentimentBase: 4,
    tier: "mid"
  },
  {
    slug: "umhlanga",
    name: "Umhlanga",
    province: "kwazulu-natal",
    level: "city",
    // Treated as city often
    avgSale: 36e5,
    avgRent: 22e3,
    sentimentBase: 4.6,
    tier: "upper"
  },
  {
    slug: "ballito",
    name: "Ballito",
    province: "kwazulu-natal",
    level: "city",
    avgSale: 32e5,
    sentimentBase: 4.5,
    tier: "upper"
  }
];

// server/services/locationPagesService.improved.ts
var STATIC_CONTENT_CACHE_TTL = 24 * 60 * 60;
var DYNAMIC_STATS_CACHE_TTL = 5 * 60;
function parseJsonField2(field) {
  if (!field) return [];
  if (Array.isArray(field)) return field;
  try {
    const parsed = JSON.parse(field);
    return Array.isArray(parsed) ? parsed : [];
  } catch (e) {
    return [];
  }
}
var locationPagesService = {
  /**
   * Get data for Province Page (Level 1)
   * HYBRID MODEL: Combines DB Inventory with Market Intelligence Pricing
   */
  async getProvinceData(provinceSlug) {
    console.log(`[LocationPages] getProvinceData called with slug: "${provinceSlug}"`);
    const db3 = await getDb();
    const featuredDevelopmentsRaw = await db3.select({
      id: developments.id,
      title: developments.name,
      name: developments.name,
      slug: developments.slug,
      images: developments.images,
      priceFrom: developments.priceFrom,
      priceTo: developments.priceTo,
      city: developments.city,
      cityName: cities.name,
      citySlug: cities.slug,
      province: developments.province,
      status: developments.status,
      isHotSelling: developments.isHotSelling,
      isHighDemand: developments.isHighDemand,
      demandScore: developments.demandScore
    }).from(developments).leftJoin(cities, eq30(developments.city, cities.name)).where(eq30(developments.province, province.name)).orderBy(desc18(developments.isHotSelling), desc18(developments.createdAt)).limit(12);
    const featuredDevelopments = featuredDevelopmentsRaw.map((dev) => ({
      ...dev,
      images: parseJsonField2(dev.images)
    }));
    const trendingSuburbs = await db3.select({
      id: suburbs.id,
      name: suburbs.name,
      slug: suburbs.slug,
      cityName: cities.name,
      citySlug: cities.slug,
      listingCount: sql23`count(${properties.id})`,
      growth: sql23`count(${properties.id})`
    }).from(suburbs).leftJoin(cities, eq30(suburbs.cityId, cities.id)).leftJoin(properties, and25(eq30(properties.suburbId, suburbs.id), eq30(properties.status, "published"))).where(eq30(cities.provinceId, province.id)).groupBy(suburbs.id, suburbs.name, suburbs.slug, cities.name, cities.slug).orderBy(desc18(sql23`count(${properties.id})`)).limit(10);
    return {
      province,
      cities: cityList,
      featuredDevelopments,
      trendingSuburbs,
      topLocalities,
      // <--- HYBRID DATA
      // Mock data for legacy component support where needed
      topDevelopers: [],
      investmentProjects: [],
      recommendedAgencies: [],
      stats: {
        totalListings: Number(stats?.totalListings || 0),
        avgPrice: Math.round(Number(stats?.avgPrice || 0)),
        minPrice: Number(stats?.minPrice || 0),
        maxPrice: Number(stats?.maxPrice || 0),
        rentalCount: Number(stats?.rentalCount || 0),
        saleCount: Number(stats?.saleCount || 0)
      }
    };
  },
  /**
   * Get data for City Page (Level 2)
   */
  async getCityData(provinceSlug, citySlug) {
    console.log(`[LocationPages] getCityData: ${provinceSlug}/${citySlug}`);
    const db3 = await getDb();
    const cityIntel = MARKET_INTELLIGENCE.find(
      (i) => i.level === "city" && i.slug === citySlug && i.province === provinceSlug
    );
    let [city] = await db3.select({ id: cities.id, name: cities.name, slug: cities.slug }).from(cities).where(eq30(cities.slug, citySlug)).limit(1);
    if (!city && !cityIntel) return null;
    let cityDbStats;
    if (city) {
      [cityDbStats] = await db3.select({
        totalListings: sql23`count(*)`,
        avgSalePrice: sql23`avg(case when ${properties.listingType} = 'sale' then ${properties.price} else null end)`,
        avgRentPrice: sql23`avg(case when ${properties.listingType} = 'rent' then ${properties.price} else null end)`,
        minPrice: sql23`min(${properties.price})`,
        maxPrice: sql23`max(${properties.price})`,
        rentalCount: sql23`sum(case when ${properties.listingType} = 'rent' then 1 else 0 end)`,
        saleCount: sql23`sum(case when ${properties.listingType} = 'sale' then 1 else 0 end)`
      }).from(properties).where(and25(eq30(properties.cityId, city.id), eq30(properties.status, "published")));
    }
    const hasEnoughData = Number(cityDbStats?.totalListings || 0) >= 5;
    const suburbStats = await db3.select({
      id: suburbs.id,
      name: suburbs.name,
      slug: suburbs.slug,
      listingCount: sql23`count(${properties.id})`,
      avgSalePrice: sql23`avg(case when ${properties.listingType} = 'sale' then ${properties.price} else null end)`
    }).from(suburbs).leftJoin(cities, eq30(suburbs.cityId, cities.id)).leftJoin(properties, and25(eq30(properties.suburbId, suburbs.id), eq30(properties.status, "published"))).where(eq30(cities.slug, citySlug)).groupBy(suburbs.id, suburbs.name, suburbs.slug).orderBy(desc18(sql23`count(${properties.id})`));
    const suburbIntel = MARKET_INTELLIGENCE.filter(
      (i) => i.level === "suburb" && i.parentSlug === citySlug
    );
    const mergedSuburbs = suburbIntel.map((intel) => {
      const dbSub = suburbStats.find((s) => s.slug === intel.slug);
      const subHasData = dbSub && Number(dbSub.listingCount) >= 5;
      return {
        name: intel.name,
        slug: intel.slug,
        propertiesForSale: Number(dbSub?.listingCount || 0),
        avgSalePrice: subHasData ? Math.round(Number(dbSub.avgSalePrice)) : intel.avgSale,
        rating: generateSmartScore(intel.sentimentBase)
      };
    });
    suburbStats.forEach((stat) => {
      if (!mergedSuburbs.find((m) => m.slug === stat.slug) && Number(stat.listingCount) >= 5) {
        mergedSuburbs.push({
          name: stat.name,
          slug: stat.slug || "",
          propertiesForSale: Number(stat.listingCount),
          avgSalePrice: Math.round(Number(stat.avgSalePrice)),
          rating: 4
        });
      }
    });
    mergedSuburbs.sort((a, b) => b.propertiesForSale - a.propertiesForSale);
    let featuredProperties = [];
    if (city) {
      featuredProperties = await db3.select({
        id: properties.id,
        title: properties.title,
        propertyType: properties.propertyType,
        listingType: properties.listingType,
        price: properties.price,
        bedrooms: properties.bedrooms,
        bathrooms: properties.bathrooms,
        area: properties.area,
        address: properties.address,
        mainImage: properties.mainImage,
        city: properties.city,
        // properties.city exists (varchar)
        suburb: suburbs.name,
        // Join suburbs to get name
        featured: properties.featured
      }).from(properties).leftJoin(suburbs, eq30(properties.suburbId, suburbs.id)).where(and25(eq30(properties.cityId, city.id), eq30(properties.status, "published"))).limit(6);
    }
    const developmentsListRaw = await db3.select({
      id: developments.id,
      name: developments.name,
      slug: developments.slug,
      images: developments.images,
      priceFrom: developments.priceFrom,
      priceTo: developments.priceTo,
      city: developments.city,
      suburb: developments.suburb
    }).from(developments).where(eq30(developments.city, city?.name || cityIntel?.name || "")).orderBy(desc18(developments.createdAt)).limit(10);
    const developmentsList = developmentsListRaw.map((dev) => ({
      ...dev,
      images: parseJsonField2(dev.images)
    }));
    return {
      city: city || { name: cityIntel.name, slug: citySlug },
      suburbs: mergedSuburbs.length > 0 ? mergedSuburbs : suburbStats.slice(0, 10).map((s) => ({
        name: s.name,
        slug: s.slug,
        propertiesForSale: Number(s.listingCount),
        avgSalePrice: Number(s.avgSalePrice)
      })),
      featuredProperties,
      developments: developmentsList,
      stats: {
        totalListings: Number(cityDbStats?.totalListings || 0),
        avgSalePrice: hasEnoughData ? Math.round(Number(cityDbStats?.avgSalePrice || 0)) : cityIntel?.avgSale || 0,
        avgRentPrice: hasEnoughData ? Math.round(Number(cityDbStats?.avgRentPrice || 0)) : cityIntel?.avgRent || 0,
        minPrice: Number(cityDbStats?.minPrice || 0),
        maxPrice: Number(cityDbStats?.maxPrice || 0),
        rentalCount: Number(cityDbStats?.rentalCount || 0),
        saleCount: Number(cityDbStats?.saleCount || 0),
        marketSentiment: generateSmartScore(hasEnoughData ? void 0 : cityIntel?.sentimentBase)
      },
      topSuburbs: mergedSuburbs.length > 0 ? mergedSuburbs : suburbStats.slice(0, 6)
    };
  },
  /**
   * Get data for Suburb Page (Level 3)
   */
  async getSuburbData(provinceSlug, citySlug, suburbSlug) {
    console.log(`[LocationPages] getSuburbData called with: ${provinceSlug}/${citySlug}/${suburbSlug}`);
    const db3 = await getDb();
    const suburbIntel = MARKET_INTELLIGENCE.find(
      (i) => i.level === "suburb" && i.slug === suburbSlug && (i.parentSlug === citySlug || i.province === provinceSlug)
    );
    let [suburb] = await db3.select({ id: suburbs.id, name: suburbs.name, slug: suburbs.slug }).from(suburbs).where(eq30(suburbs.slug, suburbSlug)).limit(1);
    let suburbDbStats;
    if (suburb) {
      [suburbDbStats] = await db3.select({
        totalListings: sql23`count(*)`,
        avgSalePrice: sql23`avg(case when ${properties.listingType} = 'sale' then ${properties.price} else null end)`,
        avgRentPrice: sql23`avg(case when ${properties.listingType} = 'rent' then ${properties.price} else null end)`,
        minPrice: sql23`min(${properties.price})`,
        maxPrice: sql23`max(${properties.price})`,
        rentalCount: sql23`sum(case when ${properties.listingType} = 'rent' then 1 else 0 end)`,
        saleCount: sql23`sum(case when ${properties.listingType} = 'sale' then 1 else 0 end)`
      }).from(properties).where(and25(eq30(properties.suburbId, suburb.id), eq30(properties.status, "published")));
    }
    const hasStats = Number(suburbDbStats?.totalListings || 0) > 0;
    if (!suburbIntel && !hasStats) {
      return null;
    }
    const hasEnoughData = Number(suburbDbStats?.totalListings || 0) >= 5;
    let featuredProperties = [];
    if (suburb) {
      featuredProperties = await db3.select({
        id: properties.id,
        title: properties.title,
        propertyType: properties.propertyType,
        listingType: properties.listingType,
        price: properties.price,
        bedrooms: properties.bedrooms,
        bathrooms: properties.bathrooms,
        area: properties.area,
        address: properties.address,
        mainImage: properties.mainImage,
        city: properties.city,
        suburb: suburbs.name
      }).from(properties).leftJoin(suburbs, eq30(properties.suburbId, suburbs.id)).where(and25(eq30(properties.suburbId, suburb.id), eq30(properties.status, "published"))).limit(6);
    }
    return {
      suburb: suburb || {
        name: suburbIntel?.name || suburbSlug,
        slug: suburbSlug
      },
      enhancedData: {
        avgSalePrice: hasEnoughData ? Math.round(Number(suburbDbStats?.avgSalePrice || 0)) : suburbIntel?.avgSale || 0,
        avgRentPrice: hasEnoughData ? Math.round(Number(suburbDbStats?.avgRentPrice || 0)) : suburbIntel?.avgRent || 0,
        totalListings: Number(suburbDbStats?.totalListings || 0),
        marketSentiment: generateSmartScore(hasEnoughData ? void 0 : suburbIntel?.sentimentBase),
        tier: suburbIntel?.tier || "mid",
        dataSource: hasEnoughData ? "database" : "market_intelligence"
      },
      featuredProperties,
      stats: {
        totalListings: Number(suburbDbStats?.totalListings || 0),
        avgPrice: Math.round(Number(suburbDbStats?.avgSalePrice || 0)),
        minPrice: Number(suburbDbStats?.minPrice || 0),
        maxPrice: Number(suburbDbStats?.maxPrice || 0),
        rentalCount: Number(suburbDbStats?.rentalCount || 0),
        saleCount: Number(suburbDbStats?.saleCount || 0)
      },
      nearbySuburbs: MARKET_INTELLIGENCE.filter(
        (i) => i.level === "suburb" && i.parentSlug === citySlug && i.slug !== suburbSlug
      ).slice(0, 5)
    };
  },
  // Legacy Wrappers
  async getEnhancedProvinceData(slug) {
    return this.getProvinceData(slug);
  },
  async getEnhancedCityData(p, c) {
    return this.getCityData(p, c);
  },
  async getEnhancedSuburbData(p, c, s) {
    return this.getSuburbData(p, c, s);
  },
  // Placeholder methods
  async getLocationByPath(p, c, s) {
    return null;
  },
  async invalidateLocationCache(id) {
  }
};

// server/locationPagesRouter.ts
init_db();
init_schema();
import { and as and27, eq as eq33, lte as lte6, gte as gte7, or as or13, isNull as isNull2, inArray as inArray8 } from "drizzle-orm";
var locationPagesRouter = router({
  /**
   * Get province data (legacy method - dynamic only)
   */
  getProvinceData: publicProcedure.input(z27.object({
    provinceSlug: z27.string()
  })).query(async ({ input }) => {
    return await locationPagesService.getProvinceData(input.provinceSlug);
  }),
  /**
   * Get city data (legacy method - dynamic only)
   */
  getCityData: publicProcedure.input(z27.object({
    provinceSlug: z27.string(),
    citySlug: z27.string()
  })).query(async ({ input }) => {
    return await locationPagesService.getCityData(input.provinceSlug, input.citySlug);
  }),
  /**
   * Get suburb data (legacy method - dynamic only)
   */
  getSuburbData: publicProcedure.input(z27.object({
    provinceSlug: z27.string(),
    citySlug: z27.string(),
    suburbSlug: z27.string()
  })).query(async ({ input }) => {
    return await locationPagesService.getSuburbData(input.provinceSlug, input.citySlug, input.suburbSlug);
  }),
  /**
   * Get enhanced province data with Google Places integration
   * Requirements 24.1-24.5, 28.1-28.5: Merge static + dynamic content
   * 
   * Returns:
   * - Static SEO content from locations table (80%, cached 24 hours)
   * - Dynamic market statistics from listings (20%, cached 5 minutes)
   */
  getEnhancedProvinceData: publicProcedure.input(z27.object({
    provinceSlug: z27.string()
  })).query(async ({ input }) => {
    return await locationPagesService.getEnhancedProvinceData(input.provinceSlug);
  }),
  /**
   * Get enhanced city data with Google Places integration
   * Requirements 24.1-24.5, 28.1-28.5: Merge static + dynamic content
   */
  getEnhancedCityData: publicProcedure.input(z27.object({
    provinceSlug: z27.string(),
    citySlug: z27.string()
  })).query(async ({ input }) => {
    return await locationPagesService.getEnhancedCityData(input.provinceSlug, input.citySlug);
  }),
  /**
   * Get enhanced suburb data with Google Places integration
   * Requirements 24.1-24.5, 28.1-28.5: Merge static + dynamic content
   */
  getEnhancedSuburbData: publicProcedure.input(z27.object({
    provinceSlug: z27.string(),
    citySlug: z27.string(),
    suburbSlug: z27.string()
  })).query(async ({ input }) => {
    return await locationPagesService.getEnhancedSuburbData(input.provinceSlug, input.citySlug, input.suburbSlug);
  }),
  /**
   * Get location by path (supports slug-based lookups)
   * Requirements 24.1, 28.1: Fetch static content from locations table
   */
  getLocationByPath: publicProcedure.input(z27.object({
    province: z27.string(),
    city: z27.string().optional(),
    suburb: z27.string().optional()
  })).query(async ({ input }) => {
    return await locationPagesService.getLocationByPath(input.province, input.city, input.suburb);
  }),
  /**
   * Invalidate location cache
   * Requirements 24.4: Invalidate cached statistics when listings change
   * 
   * This should be called when a listing is created, updated, or deleted
   */
  invalidateLocationCache: publicProcedure.input(z27.object({
    locationId: z27.number()
  })).mutation(async ({ input }) => {
    await locationPagesService.invalidateLocationCache(input.locationId);
    return { success: true };
  }),
  /**
   * Get trending suburbs
   * Requirements 21.4-21.5: Display top 10 trending suburbs with statistics
   * 
   * Returns suburbs ranked by search activity with market statistics
   */
  getTrendingSuburbs: publicProcedure.input(z27.object({
    limit: z27.number().min(1).max(50).default(10)
  }).optional()).query(async ({ input }) => {
    const { locationAnalyticsService: locationAnalyticsService2 } = await Promise.resolve().then(() => (init_locationAnalyticsService(), locationAnalyticsService_exports));
    return await locationAnalyticsService2.getTrendingSuburbs(input?.limit || 10);
  }),
  /**
   * Get similar locations
   * Requirements 22.1-22.5: Display up to 5 similar locations with statistics
   * 
   * Returns locations similar to the target based on:
   * - Price bracket (Â±20%)
   * - Property type distribution
   * - Listing density
   * - Proximity (prioritizes same city)
   */
  getSimilarLocations: publicProcedure.input(z27.object({
    locationId: z27.number(),
    limit: z27.number().min(1).max(10).default(5)
  })).query(async ({ input }) => {
    const { locationAnalyticsService: locationAnalyticsService2 } = await Promise.resolve().then(() => (init_locationAnalyticsService(), locationAnalyticsService_exports));
    return await locationAnalyticsService2.getSimilarLocations(input.locationId, input.limit);
  }),
  /**
   * Get active hero campaign for a location
   * Filters by target slug and date range
   */
  getHeroCampaign: publicProcedure.input(z27.object({
    locationSlug: z27.string(),
    fallbacks: z27.array(z27.string()).optional().default([])
  })).query(async ({ input }) => {
    const db3 = await getDb();
    const today = /* @__PURE__ */ new Date();
    const targetSlugs = [input.locationSlug, ...input.fallbacks];
    const campaigns = await db3.select().from(heroCampaigns).where(
      and27(
        inArray8(heroCampaigns.targetSlug, targetSlugs),
        eq33(heroCampaigns.isActive, 1),
        or13(
          isNull2(heroCampaigns.startDate),
          lte6(heroCampaigns.startDate, today.toISOString())
        ),
        or13(
          isNull2(heroCampaigns.endDate),
          gte7(heroCampaigns.endDate, today.toISOString())
        )
      )
    );
    if (campaigns.length === 0) return null;
    for (const slug of targetSlugs) {
      const match = campaigns.find((c) => c.targetSlug === slug);
      if (match) return match;
    }
    return null;
  }),
  /**
   * Submit a resident review for a suburb
   */
  submitReview: publicProcedure.input(z27.object({
    suburbId: z27.number(),
    rating: z27.number().min(1).max(5),
    userType: z27.enum(["resident", "tenant", "landlord", "visitor"]),
    pros: z27.string(),
    cons: z27.string(),
    comment: z27.string()
  })).mutation(async ({ input }) => {
    const { locationInsightsService: locationInsightsService2 } = await Promise.resolve().then(() => (init_locationInsightsService(), locationInsightsService_exports));
    return await locationInsightsService2.submitReview({
      suburbId: input.suburbId,
      userId: 1,
      // TODO: Get actual user ID from context/session
      rating: input.rating,
      userType: input.userType,
      pros: input.pros,
      cons: input.cons,
      comment: input.comment
    });
  })
});

// server/propertyResultsRouter.ts
import { z as z28 } from "zod";
init_db();
init_schema();
init_propertySearchService();
import { TRPCError as TRPCError10 } from "@trpc/server";
import { eq as eq35, desc as desc22, and as and29 } from "drizzle-orm";
var propertyFiltersSchema = z28.object({
  province: z28.string().optional(),
  city: z28.string().optional(),
  suburb: z28.array(z28.string()).optional(),
  propertyType: z28.array(z28.enum(["house", "apartment", "townhouse", "plot", "commercial"])).optional(),
  listingType: z28.enum(["sale", "rent"]).optional(),
  minPrice: z28.number().optional(),
  maxPrice: z28.number().optional(),
  minBedrooms: z28.number().optional(),
  maxBedrooms: z28.number().optional(),
  minBathrooms: z28.number().optional(),
  minErfSize: z28.number().optional(),
  maxErfSize: z28.number().optional(),
  minFloorSize: z28.number().optional(),
  maxFloorSize: z28.number().optional(),
  titleType: z28.array(z28.enum(["freehold", "sectional"])).optional(),
  maxLevy: z28.number().optional(),
  securityEstate: z28.boolean().optional(),
  petFriendly: z28.boolean().optional(),
  fibreReady: z28.boolean().optional(),
  loadSheddingSolutions: z28.array(z28.enum(["solar", "generator", "inverter", "none"])).optional(),
  status: z28.array(z28.enum(["available", "under_offer", "sold", "let"])).optional(),
  bounds: z28.object({
    north: z28.number(),
    south: z28.number(),
    east: z28.number(),
    west: z28.number()
  }).optional()
});
var sortOptionSchema = z28.enum([
  "price_asc",
  "price_desc",
  "date_desc",
  "date_asc",
  "suburb_asc",
  "suburb_desc"
]);
var propertyResultsRouter = router({
  /**
   * Search properties with filters and pagination
   * Requirement 4.1: Search endpoint with filter and pagination params
   */
  search: publicProcedure.input(
    z28.object({
      filters: propertyFiltersSchema,
      sortOption: sortOptionSchema.default("date_desc"),
      page: z28.number().int().positive().default(1),
      pageSize: z28.number().int().positive().max(100).default(12)
    })
  ).query(async ({ input }) => {
    try {
      const results = await propertySearchService.searchProperties(
        input.filters,
        input.sortOption,
        input.page,
        input.pageSize
      );
      return {
        success: true,
        data: results
      };
    } catch (error) {
      console.error("[PropertyResults] Search error:", error);
      throw new TRPCError10({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to search properties"
      });
    }
  }),
  /**
   * Get filter counts for preview
   * Requirement 7.3: Show count before applying filter
   */
  getFilterCounts: publicProcedure.input(
    z28.object({
      filters: propertyFiltersSchema
    })
  ).query(async ({ input }) => {
    try {
      const counts = await propertySearchService.getFilterCounts(
        input.filters
      );
      return {
        success: true,
        data: counts
      };
    } catch (error) {
      console.error("[PropertyResults] Filter counts error:", error);
      throw new TRPCError10({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to get filter counts"
      });
    }
  }),
  /**
   * Saved Searches
   */
  savedSearches: router({
    /**
     * Create a saved search
     * Requirement 4.1: Store filter criteria with notification options
     */
    create: protectedProcedure.input(
      z28.object({
        name: z28.string().min(1).max(255),
        filters: propertyFiltersSchema,
        notificationMethod: z28.enum(["email", "whatsapp", "both", "none"]).default("none"),
        notificationFrequency: z28.enum(["instant", "daily", "weekly"]).default("weekly")
      })
    ).mutation(async ({ ctx, input }) => {
      const db3 = await getDb();
      if (!db3) {
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Database not available"
        });
      }
      try {
        const result = await db3.insert(savedSearches).values({
          userId: ctx.user.id,
          name: input.name,
          filters: input.filters,
          notificationMethod: input.notificationMethod,
          notificationFrequency: input.notificationFrequency,
          isActive: 1
        });
        return {
          success: true,
          data: {
            id: Number(result[0].insertId)
          }
        };
      } catch (error) {
        console.error("[PropertyResults] Create saved search error:", error);
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create saved search"
        });
      }
    }),
    /**
     * List user's saved searches
     * Requirement 4.2: Display list with search names, suburbs, and result counts
     */
    list: protectedProcedure.query(async ({ ctx }) => {
      const db3 = await getDb();
      if (!db3) {
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Database not available"
        });
      }
      try {
        const searches = await db3.select().from(savedSearches).where(
          and29(
            eq35(savedSearches.userId, ctx.user.id),
            eq35(savedSearches.isActive, 1)
          )
        ).orderBy(desc22(savedSearches.createdAt));
        const searchesWithCounts = await Promise.all(
          searches.map(async (search) => {
            try {
              const filters = search.filters;
              const counts = await propertySearchService.getFilterCounts(filters);
              const location = [
                filters.suburb?.join(", "),
                filters.city,
                filters.province
              ].filter(Boolean).join(", ");
              return {
                id: search.id,
                name: search.name,
                filters: search.filters,
                location,
                resultCount: counts.total,
                notificationMethod: search.notificationMethod,
                notificationFrequency: search.notificationFrequency,
                createdAt: search.createdAt,
                lastNotified: search.lastNotified
              };
            } catch (error) {
              console.error(`[PropertyResults] Error getting counts for search ${search.id}:`, error);
              return {
                id: search.id,
                name: search.name,
                filters: search.filters,
                location: "",
                resultCount: 0,
                notificationMethod: search.notificationMethod,
                notificationFrequency: search.notificationFrequency,
                createdAt: search.createdAt,
                lastNotified: search.lastNotified
              };
            }
          })
        );
        return {
          success: true,
          data: searchesWithCounts
        };
      } catch (error) {
        console.error("[PropertyResults] List saved searches error:", error);
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to list saved searches"
        });
      }
    }),
    /**
     * Load a saved search
     * Requirement 4.3: Navigate to results with saved filters applied
     */
    load: protectedProcedure.input(
      z28.object({
        id: z28.number().int().positive()
      })
    ).query(async ({ ctx, input }) => {
      const db3 = await getDb();
      if (!db3) {
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Database not available"
        });
      }
      try {
        const search = await db3.select().from(savedSearches).where(
          and29(
            eq35(savedSearches.id, input.id),
            eq35(savedSearches.userId, ctx.user.id),
            eq35(savedSearches.isActive, 1)
          )
        ).limit(1);
        if (search.length === 0) {
          throw new TRPCError10({
            code: "NOT_FOUND",
            message: "Saved search not found"
          });
        }
        return {
          success: true,
          data: {
            id: search[0].id,
            name: search[0].name,
            filters: search[0].filters,
            notificationMethod: search[0].notificationMethod,
            notificationFrequency: search[0].notificationFrequency
          }
        };
      } catch (error) {
        if (error instanceof TRPCError10) throw error;
        console.error("[PropertyResults] Load saved search error:", error);
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to load saved search"
        });
      }
    }),
    /**
     * Delete a saved search
     */
    delete: protectedProcedure.input(
      z28.object({
        id: z28.number().int().positive()
      })
    ).mutation(async ({ ctx, input }) => {
      const db3 = await getDb();
      if (!db3) {
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Database not available"
        });
      }
      try {
        const search = await db3.select().from(savedSearches).where(
          and29(
            eq35(savedSearches.id, input.id),
            eq35(savedSearches.userId, ctx.user.id)
          )
        ).limit(1);
        if (search.length === 0) {
          throw new TRPCError10({
            code: "NOT_FOUND",
            message: "Saved search not found"
          });
        }
        await db3.update(savedSearches).set({ isActive: 0 }).where(eq35(savedSearches.id, input.id));
        return {
          success: true
        };
      } catch (error) {
        if (error instanceof TRPCError10) throw error;
        console.error("[PropertyResults] Delete saved search error:", error);
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to delete saved search"
        });
      }
    })
  }),
  /**
   * Analytics tracking
   */
  analytics: router({
    /**
     * Track search event
     * Requirement 11.1: Track search criteria and result count
     */
    trackSearch: publicProcedure.input(
      z28.object({
        filters: propertyFiltersSchema,
        resultCount: z28.number().int().nonnegative(),
        sortOrder: sortOptionSchema,
        viewMode: z28.enum(["list", "grid", "map"]),
        sessionId: z28.string()
      })
    ).mutation(async ({ ctx, input }) => {
      const db3 = await getDb();
      if (!db3) {
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Database not available"
        });
      }
      try {
        await db3.insert(searchAnalytics).values({
          userId: ctx.user?.id || null,
          sessionId: input.sessionId,
          filters: input.filters,
          resultCount: input.resultCount,
          sortOrder: input.sortOrder,
          viewMode: input.viewMode
        });
        return {
          success: true
        };
      } catch (error) {
        console.error("[PropertyResults] Track search error:", error);
        return {
          success: false
        };
      }
    }),
    /**
     * Track property click
     * Requirement 11.3: Track click-through rate by position and location
     */
    trackClick: publicProcedure.input(
      z28.object({
        propertyId: z28.number().int().positive(),
        position: z28.number().int().nonnegative(),
        searchFilters: propertyFiltersSchema,
        sessionId: z28.string()
      })
    ).mutation(async ({ ctx, input }) => {
      const db3 = await getDb();
      if (!db3) {
        throw new TRPCError10({
          code: "INTERNAL_SERVER_ERROR",
          message: "Database not available"
        });
      }
      try {
        await db3.insert(propertyClicks).values({
          propertyId: input.propertyId,
          userId: ctx.user?.id || null,
          sessionId: input.sessionId,
          position: input.position,
          searchFilters: input.searchFilters
        });
        return {
          success: true
        };
      } catch (error) {
        console.error("[PropertyResults] Track click error:", error);
        return {
          success: false
        };
      }
    })
  })
});

// server/monetizationRouter.ts
init_db();
init_schema();
import { z as z29 } from "zod";
import { and as and30, eq as eq36, desc as desc23, gte as gte9, lte as lte8, or as or15, isNull as isNull3 } from "drizzle-orm";
var monetizationRouter = router({
  createTargetingRule: protectedProcedure.input(z29.object({
    targetType: z29.enum(["hero_ad", "featured_developer", "recommended_agent"]),
    targetId: z29.number(),
    locationType: z29.enum(["province", "city", "suburb"]),
    locationId: z29.number(),
    ranking: z29.number().default(0),
    status: z29.enum(["active", "scheduled", "expired", "paused"]).default("scheduled"),
    metadata: z29.any(),
    startDate: z29.string().optional(),
    endDate: z29.string().optional()
  })).mutation(async ({ input }) => {
    await db.insert(locationTargeting).values({
      ...input,
      startDate: input.startDate,
      endDate: input.endDate
    });
    return { success: true };
  }),
  getAllRules: protectedProcedure.query(async () => {
    const rules = await db.select().from(locationTargeting).orderBy(desc23(locationTargeting.createdAt));
    return rules;
  }),
  getHeroAd: publicProcedure.input(z29.object({
    locationType: z29.enum(["province", "city", "suburb"]),
    locationId: z29.number()
  })).query(async ({ input }) => {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const ads = await db.select().from(locationTargeting).where(and30(
      eq36(locationTargeting.targetType, "hero_ad"),
      eq36(locationTargeting.locationType, input.locationType),
      eq36(locationTargeting.locationId, input.locationId),
      eq36(locationTargeting.status, "active"),
      // Handle date ranges (start <= now <= end)
      or15(isNull3(locationTargeting.startDate), lte8(locationTargeting.startDate, now)),
      or15(isNull3(locationTargeting.endDate), gte9(locationTargeting.endDate, now))
    )).orderBy(desc23(locationTargeting.ranking)).limit(1);
    return ads[0] || null;
    return ads[0] || null;
  }),
  getFeaturedDevelopers: publicProcedure.input(z29.object({
    locationType: z29.enum(["province", "city", "suburb"]),
    locationId: z29.number()
  })).query(async ({ input }) => {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const results = await db.select({
      targeting: locationTargeting,
      developer: {
        id: developers.id,
        name: developers.name,
        slug: developers.slug,
        logo: developers.logo
      }
    }).from(locationTargeting).innerJoin(developers, eq36(locationTargeting.targetId, developers.id)).where(and30(
      eq36(locationTargeting.targetType, "featured_developer"),
      eq36(locationTargeting.locationType, input.locationType),
      eq36(locationTargeting.locationId, input.locationId),
      eq36(locationTargeting.status, "active"),
      or15(isNull3(locationTargeting.startDate), lte8(locationTargeting.startDate, now)),
      or15(isNull3(locationTargeting.endDate), gte9(locationTargeting.endDate, now))
    )).orderBy(desc23(locationTargeting.ranking)).limit(6);
    return results.map((r) => ({
      ...r.developer,
      ranking: r.targeting.ranking
    }));
  }),
  getRecommendedAgents: publicProcedure.input(z29.object({
    locationType: z29.enum(["province", "city", "suburb"]),
    locationId: z29.number()
  })).query(async ({ input }) => {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const results = await db.select({
      targeting: locationTargeting,
      agent: {
        id: agents.id,
        firstName: agents.firstName,
        lastName: agents.lastName,
        profileImage: agents.profileImage,
        role: agents.role,
        totalSales: agents.totalSales,
        rating: agents.rating
      },
      agency: {
        id: agencies.id,
        name: agencies.name,
        logo: agencies.logo
      }
    }).from(locationTargeting).innerJoin(agents, eq36(locationTargeting.targetId, agents.id)).leftJoin(agencies, eq36(agents.agencyId, agencies.id)).where(and30(
      eq36(locationTargeting.targetType, "recommended_agent"),
      eq36(locationTargeting.locationType, input.locationType),
      eq36(locationTargeting.locationId, input.locationId),
      eq36(locationTargeting.status, "active"),
      or15(isNull3(locationTargeting.startDate), lte8(locationTargeting.startDate, now)),
      or15(isNull3(locationTargeting.endDate), gte9(locationTargeting.endDate, now))
    )).orderBy(desc23(locationTargeting.ranking)).limit(8);
    return results.map((r) => ({
      ...r.agent,
      agency: r.agency,
      ranking: r.targeting.ranking
    }));
  })
});

// server/brandProfileRouter.ts
import { z as z30 } from "zod";
import { TRPCError as TRPCError11 } from "@trpc/server";

// server/services/developerBrandProfileService.ts
init_db();
init_schema();
import { eq as eq37, and as and31, desc as desc24, sql as sql27, like as like11, or as or16, inArray as inArray10 } from "drizzle-orm";
function generateSlug3(brandName) {
  return brandName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").substring(0, 200);
}
async function createBrandProfile(input) {
  const slug = input.slug || generateSlug3(input.brandName);
  const [result] = await db.insert(developerBrandProfiles).values({
    brandName: input.brandName,
    slug,
    logoUrl: input.logoUrl || null,
    about: input.about || null,
    foundedYear: input.foundedYear || null,
    headOfficeLocation: input.headOfficeLocation || null,
    operatingProvinces: input.operatingProvinces || [],
    propertyFocus: input.propertyFocus || [],
    websiteUrl: input.websiteUrl || null,
    publicContactEmail: input.publicContactEmail || null,
    brandTier: input.brandTier || "regional",
    identityType: input.identityType || "developer",
    sourceAttribution: input.sourceAttribution || null,
    profileType: "industry_reference",
    isSubscriber: 0,
    isClaimable: 1,
    isVisible: input.isVisible !== false ? 1 : 0,
    isContactVerified: input.isContactVerified ? 1 : 0,
    ownerType: "platform",
    totalLeadsReceived: 0,
    unclaimedLeadCount: 0,
    createdBy: input.createdBy || null
  });
  return { id: result.insertId, slug };
}
async function getBrandProfileById(id) {
  const [profile] = await db.select().from(developerBrandProfiles).where(eq37(developerBrandProfiles.id, id)).limit(1);
  return profile || null;
}
async function getBrandProfileBySlug(slug) {
  const [profile] = await db.select().from(developerBrandProfiles).where(
    and31(
      eq37(developerBrandProfiles.slug, slug),
      eq37(developerBrandProfiles.isVisible, 1)
    )
  ).limit(1);
  return profile || null;
}
async function listBrandProfiles(filters = {}) {
  const conditions = [];
  if (filters.isVisible !== false) {
    conditions.push(eq37(developerBrandProfiles.isVisible, 1));
  }
  if (filters.brandTier) {
    conditions.push(eq37(developerBrandProfiles.brandTier, filters.brandTier));
  }
  if (filters.isSubscriber !== void 0) {
    conditions.push(eq37(developerBrandProfiles.isSubscriber, filters.isSubscriber ? 1 : 0));
  }
  if (filters.ownerType) {
    conditions.push(eq37(developerBrandProfiles.ownerType, filters.ownerType));
  }
  if (filters.search) {
    conditions.push(
      or16(
        like11(developerBrandProfiles.brandName, `%${filters.search}%`),
        like11(developerBrandProfiles.headOfficeLocation, `%${filters.search}%`)
      )
    );
  }
  const whereClause = conditions.length > 0 ? and31(...conditions) : void 0;
  const profiles = await db.select().from(developerBrandProfiles).where(whereClause).orderBy(desc24(developerBrandProfiles.totalLeadsReceived)).limit(filters.limit || 50).offset(filters.offset || 0);
  if (profiles.length === 0) {
    return [];
  }
  const profileIds = profiles.map((p) => p.id);
  const brandDevelopments = await db.select({
    id: developments.id,
    developerBrandProfileId: developments.developerBrandProfileId,
    status: developments.status
  }).from(developments).where(inArray10(developments.developerBrandProfileId, profileIds));
  const enrichedProfiles = profiles.map((profile) => {
    const profileDevs = brandDevelopments.filter((d) => d.developerBrandProfileId === profile.id);
    const totalProjects = profileDevs.length;
    const readyToMove = profileDevs.filter(
      (d) => ["ready-to-move", "completed", "phase-completed"].includes(d.status)
    ).length;
    const underConstruction = profileDevs.filter(
      (d) => ["under-construction"].includes(d.status)
    ).length;
    const newLaunch = profileDevs.filter(
      (d) => ["launching-soon", "now-selling", "new-phase-launching", "coming_soon", "planning"].includes(d.status)
    ).length;
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const experience = profile.foundedYear ? currentYear - profile.foundedYear : 0;
    return {
      ...profile,
      stats: {
        totalProjects,
        readyToMove,
        underConstruction,
        newLaunch,
        experience
      }
    };
  });
  return enrichedProfiles;
}
async function updateBrandProfile(id, input) {
  const updateData = {};
  if (input.brandName !== void 0) updateData.brandName = input.brandName;
  if (input.slug !== void 0) updateData.slug = input.slug;
  if (input.logoUrl !== void 0) updateData.logoUrl = input.logoUrl;
  if (input.about !== void 0) updateData.about = input.about;
  if (input.foundedYear !== void 0) updateData.foundedYear = input.foundedYear;
  if (input.headOfficeLocation !== void 0) updateData.headOfficeLocation = input.headOfficeLocation;
  if (input.operatingProvinces !== void 0) updateData.operatingProvinces = input.operatingProvinces;
  if (input.propertyFocus !== void 0) updateData.propertyFocus = input.propertyFocus;
  if (input.websiteUrl !== void 0) updateData.websiteUrl = input.websiteUrl;
  if (input.publicContactEmail !== void 0) updateData.publicContactEmail = input.publicContactEmail;
  if (input.brandTier !== void 0) updateData.brandTier = input.brandTier;
  if (input.identityType !== void 0) updateData.identityType = input.identityType;
  if (input.sourceAttribution !== void 0) updateData.sourceAttribution = input.sourceAttribution;
  if (input.profileType !== void 0) updateData.profileType = input.profileType;
  if (input.isSubscriber !== void 0) updateData.isSubscriber = input.isSubscriber ? 1 : 0;
  if (input.isClaimable !== void 0) updateData.isClaimable = input.isClaimable ? 1 : 0;
  if (input.isVisible !== void 0) updateData.isVisible = input.isVisible ? 1 : 0;
  if (input.isContactVerified !== void 0) updateData.isContactVerified = input.isContactVerified ? 1 : 0;
  if (input.linkedDeveloperAccountId !== void 0) updateData.linkedDeveloperAccountId = input.linkedDeveloperAccountId;
  if (input.ownerType !== void 0) updateData.ownerType = input.ownerType;
  if (input.claimRequestedAt !== void 0) updateData.claimRequestedAt = input.claimRequestedAt;
  if (Object.keys(updateData).length === 0) {
    return { success: false, message: "No fields to update" };
  }
  await db.update(developerBrandProfiles).set(updateData).where(eq37(developerBrandProfiles.id, id));
  return { success: true };
}
async function toggleVisibility(id, visible) {
  await db.update(developerBrandProfiles).set({ isVisible: visible ? 1 : 0 }).where(eq37(developerBrandProfiles.id, id));
  return { success: true };
}
async function attachDevelopmentToBrand(developmentId, brandProfileId) {
  await db.update(developments).set({
    developerBrandProfileId: brandProfileId,
    devOwnerType: "platform"
  }).where(eq37(developments.id, developmentId));
  return { success: true };
}
async function detachDevelopmentFromBrand(developmentId) {
  await db.update(developments).set({
    developerBrandProfileId: null,
    devOwnerType: "developer"
  }).where(eq37(developments.id, developmentId));
  return { success: true };
}
async function getBrandDevelopments(brandProfileId) {
  const devs = await db.select().from(developments).where(eq37(developments.developerBrandProfileId, brandProfileId));
  return devs;
}
async function getBrandProfileWithStats(id) {
  const [profile] = await db.select().from(developerBrandProfiles).where(eq37(developerBrandProfiles.id, id)).limit(1);
  if (!profile) return null;
  const devs = await db.select({ count: sql27`COUNT(*)` }).from(developments).where(eq37(developments.developerBrandProfileId, id));
  return {
    ...profile,
    developmentCount: devs[0]?.count || 0
  };
}
async function requestClaim(brandProfileId) {
  await db.update(developerBrandProfiles).set({
    claimRequestedAt: sql27`CURRENT_TIMESTAMP`
  }).where(eq37(developerBrandProfiles.id, brandProfileId));
  return { success: true };
}
async function convertToSubscriber(brandProfileId, developerAccountId) {
  await db.update(developerBrandProfiles).set({
    isSubscriber: 1,
    isClaimable: 0,
    linkedDeveloperAccountId: developerAccountId,
    ownerType: "developer"
  }).where(eq37(developerBrandProfiles.id, brandProfileId));
  await db.update(developments).set({
    devOwnerType: "developer"
  }).where(eq37(developments.developerBrandProfileId, brandProfileId));
  return { success: true };
}
async function incrementLeadCountAsync(brandProfileId) {
  await db.update(developerBrandProfiles).set({
    totalLeadsReceived: sql27`${developerBrandProfiles.totalLeadsReceived} + 1`,
    unclaimedLeadCount: sql27`${developerBrandProfiles.unclaimedLeadCount} + 1`,
    lastLeadDate: sql27`CURRENT_TIMESTAMP`
  }).where(eq37(developerBrandProfiles.id, brandProfileId));
  return { success: true };
}
async function getBrandLeadStats(brandProfileId) {
  const [profile] = await db.select({
    totalLeadsReceived: developerBrandProfiles.totalLeadsReceived,
    unclaimedLeadCount: developerBrandProfiles.unclaimedLeadCount,
    lastLeadDate: developerBrandProfiles.lastLeadDate,
    isSubscriber: developerBrandProfiles.isSubscriber,
    isContactVerified: developerBrandProfiles.isContactVerified
  }).from(developerBrandProfiles).where(eq37(developerBrandProfiles.id, brandProfileId)).limit(1);
  if (!profile) return null;
  const leadCounts = await db.select({
    status: leads.brandLeadStatus,
    count: sql27`COUNT(*)`
  }).from(leads).where(eq37(leads.developerBrandProfileId, brandProfileId)).groupBy(leads.brandLeadStatus);
  return {
    ...profile,
    leadBreakdown: leadCounts
  };
}
async function deleteBrandProfile(id) {
  const devCount = await db.select({ count: sql27`COUNT(*)` }).from(developments).where(eq37(developments.developerBrandProfileId, id));
  const leadCount = await db.select({ count: sql27`COUNT(*)` }).from(leads).where(eq37(leads.developerBrandProfileId, id));
  const hasDeps = (devCount[0]?.count || 0) > 0 || (leadCount[0]?.count || 0) > 0;
  if (hasDeps) {
    const [current] = await db.select({ brandName: developerBrandProfiles.brandName }).from(developerBrandProfiles).where(eq37(developerBrandProfiles.id, id));
    await db.update(developerBrandProfiles).set({
      isVisible: 0,
      brandName: `${current?.brandName} (Deleted ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]})`,
      slug: `deleted-${id}-${Date.now()}`
      // Free up the slug
    }).where(eq37(developerBrandProfiles.id, id));
    return { success: true, mode: "soft" };
  } else {
    await db.delete(developerBrandProfiles).where(eq37(developerBrandProfiles.id, id));
    return { success: true, mode: "hard" };
  }
}
var developerBrandProfileService = {
  // CRUD
  createBrandProfile,
  getBrandProfileById,
  getBrandProfileBySlug,
  listBrandProfiles,
  updateBrandProfile,
  deleteBrandProfile,
  // Added
  toggleVisibility,
  // Development linking
  attachDevelopmentToBrand,
  detachDevelopmentFromBrand,
  getBrandDevelopments,
  getBrandProfileWithStats,
  // Claim flow
  requestClaim,
  convertToSubscriber,
  // Lead metrics
  incrementLeadCountAsync,
  getBrandLeadStats
};

// server/services/brandLeadService.ts
init_db();
init_schema();
import { eq as eq38, and as and32, desc as desc25 } from "drizzle-orm";

// server/_core/emailService.ts
init_env();
import { Resend as Resend2 } from "resend";
var resend2 = ENV.resendApiKey ? new Resend2(ENV.resendApiKey) : null;
var EmailService2 = class {
  static async sendEmail(emailData) {
    try {
      if (resend2) {
        try {
          const { data, error } = await resend2.emails.send({
            from: ENV.resendFromEmail,
            to: emailData.to,
            subject: emailData.subject,
            html: emailData.html,
            text: emailData.text
          });
          if (error) {
            console.error("[Email] Resend API Error:", error);
            return false;
          }
          console.log("[Email] Sent via Resend:", data?.id);
          return true;
        } catch (resendError) {
          console.error("[Email] Resend Exception:", resendError);
          return false;
        }
      }
      console.log("[Email] Sending email (Mock/Log):", {
        to: emailData.to,
        subject: emailData.subject
        // Don't log HTML content for security
      });
      if (process.env.NODE_ENV === "development") {
        console.log("[Email] Development mode - email content:");
        console.log("Subject:", emailData.subject);
        console.log("To:", emailData.to);
        console.log("HTML length:", emailData.html.length);
      }
      return true;
    } catch (error) {
      console.error("[Email] Failed to send email:", error);
      return false;
    }
  }
  // Pre-built email templates
  static async sendSubscriptionCreatedEmail(email, agencyName, planName) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Welcome to SA Property Portal Premium!</h1>
        <p>Dear ${agencyName} team,</p>
        <p>Thank you for upgrading to our <strong>${planName}</strong> plan!</p>
        <p>Your subscription is now active and you have access to all premium features including:</p>
        <ul>
          <li>Unlimited property listings</li>
          <li>Advanced analytics and reporting</li>
          <li>Priority support</li>
          <li>Custom branding options</li>
        </ul>
        <p>You can manage your subscription and billing details in your agency dashboard.</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: `Welcome to SA Property Portal ${planName} Plan!`,
      html
    });
  }
  static async sendPaymentFailedEmail(email, agencyName, amount) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Payment Failed</h1>
        <p>Dear ${agencyName} team,</p>
        <p>We were unable to process your payment of ${amount}.</p>
        <p>This could be due to:</p>
        <ul>
          <li>Insufficient funds</li>
          <li>Expired card</li>
          <li>Incorrect card details</li>
        </ul>
        <p>Please update your payment method in your billing dashboard to avoid service interruption.</p>
        <p>If you need assistance, please contact our support team.</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: "Payment Failed - Action Required",
      html
    });
  }
  static async sendSubscriptionCancelledEmail(email, agencyName, endDate) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Subscription Cancelled</h1>
        <p>Dear ${agencyName} team,</p>
        <p>Your subscription has been cancelled and will remain active until ${endDate}.</p>
        <p>You will continue to have access to all premium features until this date.</p>
        <p>If you'd like to reactivate your subscription, you can do so anytime in your billing dashboard.</p>
        <p>Thank you for being part of SA Property Portal.</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: "Subscription Cancelled",
      html
    });
  }
  static async sendInvoiceEmail(email, agencyName, invoiceUrl, amount) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Invoice Available</h1>
        <p>Dear ${agencyName} team,</p>
        <p>Your invoice for ${amount} is now available.</p>
        <p>You can view and download your invoice here: <a href="${invoiceUrl}">View Invoice</a></p>
        <p>If you have any questions about this invoice, please contact our support team.</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: `Invoice Available - ${amount}`,
      html
    });
  }
  static async sendTrialEndingEmail(email, agencyName, daysLeft) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Trial Ending Soon</h1>
        <p>Dear ${agencyName} team,</p>
        <p>Your free trial will end in ${daysLeft} days.</p>
        <p>To continue enjoying our premium features, please add a payment method to your account.</p>
        <p>You can manage your billing in the agency dashboard under the Billing section.</p>
        <p>Thank you for trying SA Property Portal!</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: `Trial Ending in ${daysLeft} Days`,
      html
    });
  }
  static async sendAgencyInvitationEmail(email, inviterName, agencyName, acceptUrl) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>You're Invited to Join ${agencyName}</h1>
        <p>Hello,</p>
        <p>${inviterName} has invited you to join ${agencyName} on SA Property Portal.</p>
        <p>As a team member, you'll be able to:</p>
        <ul>
          <li>Collaborate on property listings</li>
          <li>Access agency analytics</li>
          <li>Manage leads together</li>
          <li>Use premium features</li>
        </ul>
        <p><a href="${acceptUrl}" style="background-color: #3b82f6; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">Accept Invitation</a></p>
        <p>This invitation will expire in 7 days.</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: `Invitation to join ${agencyName}`,
      html
    });
  }
  static async sendViewingNotificationEmail(agentEmail, agentName, prospectName, prospectEmail, prospectPhone, propertyTitle, propertyPrice, scheduledAt, notes, buyabilityScore, affordabilityRange) {
    const scoreColor = buyabilityScore === "high" ? "#10b981" : buyabilityScore === "medium" ? "#f59e0b" : "#ef4444";
    const scoreText = buyabilityScore === "high" ? "High" : buyabilityScore === "medium" ? "Medium" : "Low";
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #f8fafc; padding: 20px;">
        <div style="background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
          <h1 style="color: #1f2937; margin-bottom: 20px;">\u{1F3E1} New Property Viewing Scheduled!</h1>

          <div style="background-color: #eff6ff; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h2 style="color: #1e40af; margin: 0 0 10px 0;">Viewing Details</h2>
            <p style="margin: 5px 0; color: #374151;"><strong>Property:</strong> ${propertyTitle}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Price:</strong> R${propertyPrice}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Scheduled:</strong> ${new Date(
      scheduledAt
    ).toLocaleString("en-ZA", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    })}</p>
            ${notes ? `<p style="margin: 5px 0; color: #374151;"><strong>Notes:</strong> ${notes}</p>` : ""}
          </div>

          <div style="background-color: #f0fdf4; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h2 style="color: #166534; margin: 0 0 10px 0;">Prospect Information</h2>
            <p style="margin: 5px 0; color: #374151;"><strong>Name:</strong> ${prospectName}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Email:</strong> <a href="mailto:${prospectEmail}" style="color: #3b82f6;">${prospectEmail}</a></p>
            ${prospectPhone ? `<p style="margin: 5px 0; color: #374151;"><strong>Phone:</strong> <a href="tel:${prospectPhone}" style="color: #3b82f6;">${prospectPhone}</a></p>` : ""}

            ${buyabilityScore ? `
            <div style="margin-top: 15px; padding: 10px; background-color: white; border-radius: 6px; border-left: 4px solid ${scoreColor};">
              <p style="margin: 0; color: #374151;"><strong>Buyability Score:</strong>
                <span style="color: ${scoreColor}; font-weight: bold;"> ${scoreText}</span>
              </p>
              ${affordabilityRange ? `<p style="margin: 5px 0 0 0; color: #6b7280; font-size: 14px;">Affordability: ${affordabilityRange}</p>` : ""}
            </div>
            ` : ""}
          </div>

          <div style="background-color: #fef3c7; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h3 style="color: #92400e; margin: 0 0 10px 0;">\u{1F4A1} Pro Tip</h3>
            <p style="margin: 0; color: #78350f; font-size: 14px;">
              This prospect has been pre-qualified using our advanced buyability calculator.
              ${buyabilityScore === "high" ? "They appear to be a highly qualified buyer - prioritize this viewing!" : buyabilityScore === "medium" ? "They show moderate buying potential - a good opportunity to convert." : "They may need some financial guidance or additional time to prepare."}
            </p>
          </div>

          <div style="text-align: center; margin-top: 30px;">
            <a href="mailto:${prospectEmail}"
               style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block;">
              Contact Prospect
            </a>
          </div>

          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
            <p>This viewing was scheduled through the SA Property Portal prospect pre-qualification system.</p>
            <p>Learn more about our gamified prospect dashboard at <a href="#" style="color: #3b82f6;">portal.sa</a></p>
          </div>
        </div>
      </div>
    `;
    return this.sendEmail({
      to: agentEmail,
      subject: `\u{1F3E1} New Viewing: ${prospectName} wants to view ${propertyTitle}`,
      html
    });
  }
  static async sendProspectGamificationEmail(prospectEmail, prospectName, badges, currentProgress, recommendedProperties) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #f8fafc; padding: 20px;">
        <div style="background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
          <h1 style="color: #1f2937; text-align: center; margin-bottom: 20px;">\u{1F3AF} You're Making Great Progress!</h1>

          <div style="text-align: center; margin-bottom: 30px;">
            <div style="font-size: 48px; margin-bottom: 10px;">\u{1F3C6}</div>
            <p style="color: #6b7280; font-size: 16px;">Profile Completion: ${currentProgress}%</p>
            <div style="width: 100%; height: 8px; background-color: #e5e7eb; border-radius: 4px; margin: 10px 0;">
              <div style="width: ${currentProgress}%; height: 8px; background-color: #3b82f6; border-radius: 4px;"></div>
            </div>
          </div>

          ${badges.length > 0 ? `
          <div style="background-color: #fef3c7; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h3 style="color: #92400e; margin: 0 0 15px 0;">\u{1F396}\uFE0F New Badges Earned!</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
              ${badges.map((badge) => `<span style="background-color: #fbbf24; color: #92400e; padding: 5px 10px; border-radius: 15px; font-size: 12px; font-weight: bold;">${badge}</span>`).join("")}
            </div>
          </div>
          ` : ""}

          ${recommendedProperties.length > 0 ? `
          <div style="background-color: #eff6ff; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h3 style="color: #1e40af; margin: 0 0 15px 0;">\u{1F3E0} Properties You Can Afford</h3>
            ${recommendedProperties.map(
      (property) => `
              <div style="background-color: white; padding: 15px; border-radius: 6px; margin-bottom: 10px; border-left: 4px solid #3b82f6;">
                <h4 style="margin: 0 0 5px 0; color: #1f2937;">${property.title}</h4>
                <p style="margin: 0; color: #6b7280; font-size: 14px;">From R${property.price}</p>
                <a href="${property.url}" style="color: #3b82f6; text-decoration: none; font-size: 14px;">View Property \u2192</a>
              </div>
            `
    ).join("")}
          </div>
          ` : ""}

          <div style="text-align: center; margin-top: 30px;">
            <a href="#"
               style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block;">
              Continue Your Search
            </a>
          </div>

          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
            <p>You're receiving this because you started using our buyability calculator.</p>
            <p>Want to stop these emails? <a href="#" style="color: #3b82f6;">Unsubscribe</a></p>
          </div>
        </div>
      </div>
    `;
    return this.sendEmail({
      to: prospectEmail,
      subject: `\u{1F3AF} ${prospectName}, you've unlocked ${badges.length} new badge${badges.length !== 1 ? "s" : ""}!`,
      html
    });
  }
  // New email templates for Phase 3 & 4 features
  static async sendNewLeadNotificationEmail(agentEmail, agentName, leadName, leadEmail, propertyTitle, propertyPrice, message) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #f8fafc; padding: 20px;">
        <div style="background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
          <h1 style="color: #1f2937; margin-bottom: 20px;">\u{1F195} New Lead Assigned!</h1>

          <div style="background-color: #eff6ff; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h2 style="color: #1e40af; margin: 0 0 10px 0;">Lead Details</h2>
            <p style="margin: 5px 0; color: #374151;"><strong>Name:</strong> ${leadName}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Email:</strong> <a href="mailto:${leadEmail}" style="color: #3b82f6;">${leadEmail}</a></p>
            <p style="margin: 5px 0; color: #374151;"><strong>Property:</strong> ${propertyTitle}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Price:</strong> R${propertyPrice}</p>
            ${message ? `<p style="margin: 5px 0; color: #374151;"><strong>Message:</strong> "${message}"</p>` : ""}
          </div>

          <div style="text-align: center; margin-top: 30px;">
            <a href="mailto:${leadEmail}"
               style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block;">
              Contact Lead Now
            </a>
          </div>

          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
            <p>This lead has been automatically assigned to you through the SA Property Portal.</p>
          </div>
        </div>
      </div>
    `;
    return this.sendEmail({
      to: agentEmail,
      subject: `\u{1F195} New Lead: ${leadName} interested in ${propertyTitle}`,
      html
    });
  }
  static async sendOfferReceivedNotificationEmail(agentEmail, agentName, buyerName, propertyTitle, offerAmount, expiresAt) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #f8fafc; padding: 20px;">
        <div style="background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
          <h1 style="color: #1f2937; margin-bottom: 20px;">\u{1F4B0} New Offer Received!</h1>

          <div style="background-color: #fef3c7; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h2 style="color: #92400e; margin: 0 0 10px 0;">Offer Details</h2>
            <p style="margin: 5px 0; color: #374151;"><strong>Property:</strong> ${propertyTitle}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Buyer:</strong> ${buyerName}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Offer Amount:</strong> R${offerAmount}</p>
            ${expiresAt ? `<p style="margin: 5px 0; color: #374151;"><strong>Expires:</strong> ${new Date(expiresAt).toLocaleDateString()}</p>` : ""}
          </div>

          <div style="text-align: center; margin-top: 30px;">
            <a href="#"
               style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block; margin-right: 10px;">
              Review Offer
            </a>
            <a href="#"
               style="background-color: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block;">
              Accept Offer
            </a>
          </div>

          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
            <p>A new offer has been submitted for one of your listings.</p>
          </div>
        </div>
      </div>
    `;
    return this.sendEmail({
      to: agentEmail,
      subject: `\u{1F4B0} Offer Received: R${offerAmount} for ${propertyTitle}`,
      html
    });
  }
  // Developer Workflow Emails
  static async sendDeveloperRegistrationEmail(email, name) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Application Received</h1>
        <p>Dear ${name},</p>
        <p>We have received your application to join SA Property Portal as a verified developer.</p>
        <p>Our team will review your details and get back to you shortly.</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: "Developer Application Received",
      html
    });
  }
  static async sendDeveloperApprovalEmail(email, name) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Application Approved!</h1>
        <p>Dear ${name},</p>
        <p>Congratulations! Your application to join SA Property Portal as a verified developer has been approved.</p>
        <p>You can now log in to your dashboard and start managing your developments and listings.</p>
        <p><a href="${process.env.NEXT_PUBLIC_APP_URL}/dashboard" style="background-color: #10b981; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">Go to Dashboard</a></p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: "Developer Application Approved",
      html
    });
  }
  static async sendDeveloperRejectionEmail(email, name, reason) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1>Application Update</h1>
        <p>Dear ${name},</p>
        <p>Thank you for your interest in joining SA Property Portal.</p>
        <p>After careful review, we are unable to approve your application at this time.</p>
        <p><strong>Reason:</strong> ${reason}</p>
        <p>If you have any questions or would like to appeal this decision, please contact our support team.</p>
        <p>Best regards,<br>The SA Property Portal Team</p>
      </div>
    `;
    return this.sendEmail({
      to: email,
      subject: "Update on your Developer Application",
      html
    });
  }
  // Brand Lead Notification Email
  // Note: Email must clearly state lead originated from Property Listify
  static async sendBrandLeadNotification(developerEmail, brandName, leadData) {
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #f8fafc; padding: 20px;">
        <div style="background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
          <h1 style="color: #1f2937; margin-bottom: 20px;">\u{1F4E9} New Buyer Enquiry from Property Listify</h1>
          
          <div style="background-color: #eff6ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <p style="margin: 0; color: #1e40af; font-size: 14px;">
              This enquiry originated from <strong>Property Listify</strong> (propertylistify.co.za)
            </p>
          </div>

          <div style="background-color: #f0fdf4; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h2 style="color: #166534; margin: 0 0 10px 0;">Lead Details</h2>
            <p style="margin: 5px 0; color: #374151;"><strong>Name:</strong> ${leadData.name}</p>
            <p style="margin: 5px 0; color: #374151;"><strong>Email:</strong> <a href="mailto:${leadData.email}" style="color: #3b82f6;">${leadData.email}</a></p>
            <p style="margin: 5px 0; color: #374151;"><strong>Phone:</strong> ${leadData.phone}</p>
            ${leadData.message !== "No message" ? `<p style="margin: 5px 0; color: #374151;"><strong>Message:</strong> "${leadData.message}"</p>` : ""}
          </div>

          <div style="text-align: center; margin-top: 30px;">
            <a href="mailto:${leadData.email}?subject=Re: Your enquiry to ${brandName}"
               style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block;">
              Contact Buyer Now
            </a>
          </div>

          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
            <p>This lead was captured via Property Listify on your behalf.</p>
            <p>To view leads in your dashboard and access analytics, <a href="${process.env.NEXT_PUBLIC_APP_URL}/developer/subscribe" style="color: #3b82f6;">subscribe today</a>.</p>
            <p style="margin-top: 15px; font-style: italic;">Reference: Lead #${leadData.leadId}</p>
          </div>
        </div>
      </div>
    `;
    return this.sendEmail({
      to: developerEmail,
      subject: `\u{1F4E9} New Buyer Enquiry for ${brandName} via Property Listify`,
      html
    });
  }
};

// server/services/brandLeadService.ts
async function captureBrandLead(input) {
  const brandProfile = await developerBrandProfileService.getBrandProfileById(
    input.developerBrandProfileId
  );
  if (!brandProfile) {
    throw new Error("Brand profile not found");
  }
  let brandLeadStatus;
  let deliveryMethod = "none";
  if (brandProfile.isSubscriber) {
    brandLeadStatus = "delivered_subscriber";
    deliveryMethod = "crm_export";
  } else if (brandProfile.publicContactEmail && brandProfile.isContactVerified) {
    brandLeadStatus = "delivered_unsubscribed";
    deliveryMethod = "email";
  } else if (brandProfile.publicContactEmail) {
    brandLeadStatus = "delivered_unsubscribed";
    deliveryMethod = "email";
  } else {
    brandLeadStatus = "captured";
    deliveryMethod = "none";
  }
  const [result] = await db.insert(leads).values({
    developerBrandProfileId: input.developerBrandProfileId,
    developmentId: input.developmentId || null,
    propertyId: input.propertyId || null,
    name: input.name,
    email: input.email,
    phone: input.phone || null,
    message: input.message || null,
    leadType: "inquiry",
    status: "new",
    source: input.leadSource || "property_listify",
    leadSource: input.leadSource || "property_listify",
    referrerUrl: input.referrerUrl || null,
    utmSource: input.utmSource || null,
    utmMedium: input.utmMedium || null,
    utmCampaign: input.utmCampaign || null,
    brandLeadStatus,
    leadDeliveryMethod: deliveryMethod,
    funnelStage: "interest",
    qualificationStatus: "pending"
  });
  const leadId = result.insertId;
  setImmediate(async () => {
    try {
      if (deliveryMethod === "email" && brandProfile.publicContactEmail) {
        await routeLeadToEmail(leadId, brandProfile, input);
      }
      await developerBrandProfileService.incrementLeadCountAsync(
        input.developerBrandProfileId
      );
    } catch (error) {
      console.error("Error in async lead processing:", error);
    }
  });
  return {
    leadId,
    delivered: deliveryMethod !== "none",
    deliveryMethod,
    brandLeadStatus,
    message: getLeadCaptureMessage(brandLeadStatus)
  };
}
function getLeadCaptureMessage(status) {
  switch (status) {
    case "delivered_subscriber":
      return "Your enquiry has been sent to the developer. They will contact you shortly.";
    case "delivered_unsubscribed":
      return "Your enquiry has been forwarded to the developer.";
    case "captured":
    default:
      return "Your enquiry has been received. We will connect you with the developer.";
  }
}
async function routeLeadToEmail(leadId, brandProfile, leadData) {
  if (!brandProfile.publicContactEmail) {
    console.warn(`No email for brand profile, cannot route lead ${leadId}`);
    return false;
  }
  try {
    await EmailService2.sendBrandLeadNotification(
      brandProfile.publicContactEmail,
      brandProfile.brandName,
      {
        leadId,
        name: leadData.name,
        email: leadData.email,
        phone: leadData.phone || "Not provided",
        message: leadData.message || "No message",
        developmentId: leadData.developmentId,
        propertyId: leadData.propertyId
      }
    );
    await db.update(leads).set({ brandLeadStatus: "delivered_unsubscribed" }).where(eq38(leads.id, leadId));
    return true;
  } catch (error) {
    console.error("Failed to route lead via email:", error);
    return false;
  }
}
async function canViewDashboardLeads(brandProfileId) {
  const profile = await developerBrandProfileService.getBrandProfileById(brandProfileId);
  if (!profile) {
    return false;
  }
  return profile.isSubscriber === 1;
}
async function getBrandLeads(brandProfileId, filters = {}) {
  const canView = await canViewDashboardLeads(brandProfileId);
  if (!canView) {
    return {
      leads: [],
      total: 0,
      message: "Subscribe to view leads in your dashboard."
    };
  }
  const conditions = [eq38(leads.developerBrandProfileId, brandProfileId)];
  if (filters.status) {
    conditions.push(eq38(leads.status, filters.status));
  }
  const leadResults = await db.select().from(leads).where(and32(...conditions)).orderBy(desc25(leads.createdAt)).limit(filters.limit || 50).offset(filters.offset || 0);
  return {
    leads: leadResults,
    total: leadResults.length,
    message: null
  };
}
async function getSalesPitchStats(brandProfileId) {
  const profile = await developerBrandProfileService.getBrandProfileById(brandProfileId);
  if (!profile) {
    return null;
  }
  return {
    brandName: profile.brandName,
    totalLeadsReceived: profile.totalLeadsReceived,
    lastLeadDate: profile.lastLeadDate,
    unclaimedLeadCount: profile.unclaimedLeadCount,
    isSubscriber: profile.isSubscriber === 1,
    message: profile.isSubscriber ? null : `Your developments on Property Listify have received ${profile.totalLeadsReceived} buyer enquiries. Subscribe to view leads in real time, contact buyers directly, and access analytics.`
  };
}
var brandLeadService = {
  // Lead capture
  captureBrandLead,
  // Lead routing
  routeLeadToEmail,
  // Lead visibility (Refinement #4)
  canViewDashboardLeads,
  getBrandLeads,
  // Sales stats
  getSalesPitchStats
};

// server/brandProfileRouter.ts
var createBrandProfileSchema = z30.object({
  brandName: z30.string().min(2, "Brand name must be at least 2 characters"),
  slug: z30.string().optional(),
  logoUrl: z30.string().nullable().optional(),
  about: z30.string().nullable().optional(),
  foundedYear: z30.number().int().min(1800).max(2030).nullable().optional(),
  headOfficeLocation: z30.string().nullable().optional(),
  operatingProvinces: z30.array(z30.string()).optional(),
  propertyFocus: z30.array(z30.string()).optional(),
  websiteUrl: z30.string().url().nullable().optional(),
  publicContactEmail: z30.string().email().nullable().optional(),
  brandTier: z30.enum(["national", "regional", "boutique"]).optional(),
  sourceAttribution: z30.string().nullable().optional(),
  isVisible: z30.boolean().optional(),
  isContactVerified: z30.boolean().optional()
});
var updateBrandProfileSchema = z30.object({
  id: z30.number().int(),
  data: z30.object({
    brandName: z30.string().min(2).optional(),
    slug: z30.string().optional(),
    logoUrl: z30.string().nullable().optional(),
    about: z30.string().nullable().optional(),
    foundedYear: z30.number().int().nullable().optional(),
    headOfficeLocation: z30.string().nullable().optional(),
    operatingProvinces: z30.array(z30.string()).optional(),
    propertyFocus: z30.array(z30.string()).optional(),
    websiteUrl: z30.string().nullable().optional(),
    publicContactEmail: z30.string().nullable().optional(),
    brandTier: z30.enum(["national", "regional", "boutique"]).optional(),
    sourceAttribution: z30.string().nullable().optional(),
    profileType: z30.enum(["industry_reference", "verified_partner"]).optional(),
    isVisible: z30.boolean().optional(),
    isContactVerified: z30.boolean().optional()
  })
});
var listBrandProfilesSchema = z30.object({
  brandTier: z30.enum(["national", "regional", "boutique"]).optional(),
  isSubscriber: z30.boolean().optional(),
  isVisible: z30.boolean().optional(),
  search: z30.string().optional(),
  limit: z30.number().int().positive().max(100).optional(),
  offset: z30.number().int().min(0).optional()
}).optional();
var captureBrandLeadSchema = z30.object({
  developerBrandProfileId: z30.number().int(),
  developmentId: z30.number().int().optional(),
  propertyId: z30.number().int().optional(),
  name: z30.string().min(1, "Name is required"),
  email: z30.string().email("Valid email is required"),
  phone: z30.string().optional(),
  message: z30.string().optional(),
  leadSource: z30.string().optional(),
  referrerUrl: z30.string().optional(),
  utmSource: z30.string().optional(),
  utmMedium: z30.string().optional(),
  utmCampaign: z30.string().optional()
});
var brandProfileRouter = router({
  // ============================================================================
  // PUBLIC ENDPOINTS
  // ============================================================================
  /**
   * Get brand profile by slug (public)
   */
  getBrandProfile: publicProcedure.input(z30.object({ slug: z30.string() })).query(async ({ input }) => {
    const profile = await developerBrandProfileService.getBrandProfileBySlug(input.slug);
    if (!profile) {
      throw new TRPCError11({
        code: "NOT_FOUND",
        message: "Developer brand not found"
      });
    }
    return profile;
  }),
  /**
   * List brand profiles with filters (public)
   */
  listBrandProfiles: publicProcedure.input(listBrandProfilesSchema).query(async ({ input }) => {
    return await developerBrandProfileService.listBrandProfiles(input || {});
  }),
  /**
   * Get developments for a brand (public)
   */
  getBrandDevelopments: publicProcedure.input(z30.object({ brandProfileId: z30.number().int() })).query(async ({ input }) => {
    return await developerBrandProfileService.getBrandDevelopments(input.brandProfileId);
  }),
  /**
   * Capture lead for brand profile (public)
   * This is the main lead capture endpoint
   */
  captureLead: publicProcedure.input(captureBrandLeadSchema).mutation(async ({ input }) => {
    try {
      const result = await brandLeadService.captureBrandLead(input);
      return result;
    } catch (error) {
      console.error("Lead capture failed:", error);
      throw new TRPCError11({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to submit enquiry. Please try again."
      });
    }
  }),
  // ============================================================================
  // ADMIN ENDPOINTS (Super Admin Only)
  // ============================================================================
  /**
   * Create new brand profile (admin)
   */
  adminCreateBrandProfile: protectedProcedure.input(createBrandProfileSchema).mutation(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can create brand profiles"
      });
    }
    const result = await developerBrandProfileService.createBrandProfile({
      ...input,
      createdBy: ctx.user.id
    });
    return result;
  }),
  /**
   * Update brand profile (admin)
   */
  adminUpdateBrandProfile: protectedProcedure.input(updateBrandProfileSchema).mutation(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can update brand profiles"
      });
    }
    return await developerBrandProfileService.updateBrandProfile(input.id, input.data);
  }),
  /**
   * Toggle profile visibility (admin)
   */
  adminToggleVisibility: protectedProcedure.input(z30.object({
    id: z30.number().int(),
    visible: z30.boolean()
  })).mutation(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can toggle visibility"
      });
    }
    return await developerBrandProfileService.toggleVisibility(input.id, input.visible);
  }),
  /**
   * Attach development to brand (admin)
   */
  adminAttachDevelopment: protectedProcedure.input(z30.object({
    developmentId: z30.number().int(),
    brandProfileId: z30.number().int()
  })).mutation(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can attach developments"
      });
    }
    return await developerBrandProfileService.attachDevelopmentToBrand(
      input.developmentId,
      input.brandProfileId
    );
  }),
  /**
   * Detach development from brand (admin)
   */
  adminDetachDevelopment: protectedProcedure.input(z30.object({
    developmentId: z30.number().int()
  })).mutation(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can detach developments"
      });
    }
    return await developerBrandProfileService.detachDevelopmentFromBrand(input.developmentId);
  }),
  /**
   * Get brand lead stats (admin)
   */
  adminGetBrandLeadStats: protectedProcedure.input(z30.object({ brandProfileId: z30.number().int() })).query(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can view lead stats"
      });
    }
    return await developerBrandProfileService.getBrandLeadStats(input.brandProfileId);
  }),
  /**
   * Get all brand profiles with stats (admin only, includes hidden)
   */
  adminListAllBrandProfiles: protectedProcedure.input(listBrandProfilesSchema).query(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can list all brand profiles"
      });
    }
    return await developerBrandProfileService.listBrandProfiles({
      ...input,
      isVisible: void 0
      // Show all, including hidden
    });
  }),
  /**
   * Convert brand to subscriber (admin)
   * Links brand profile to developer account after claim approval
   */
  adminConvertToSubscriber: protectedProcedure.input(z30.object({
    brandProfileId: z30.number().int(),
    developerAccountId: z30.number().int()
  })).mutation(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can convert brands to subscribers"
      });
    }
    return await developerBrandProfileService.convertToSubscriber(
      input.brandProfileId,
      input.developerAccountId
    );
  }),
  /**
   * Get sales pitch stats for outreach (admin)
   */
  adminGetSalesPitchStats: protectedProcedure.input(z30.object({ brandProfileId: z30.number().int() })).query(async ({ input, ctx }) => {
    if (ctx.user.role !== "super_admin") {
      throw new TRPCError11({
        code: "FORBIDDEN",
        message: "Only super admins can view sales stats"
      });
    }
    return await brandLeadService.getSalesPitchStats(input.brandProfileId);
  })
});

// server/superAdminPublisherRouter.ts
import { z as z31 } from "zod";
init_db();
import { TRPCError as TRPCError12 } from "@trpc/server";
init_schema();
import { eq as eq39, desc as desc26, and as and33 } from "drizzle-orm";
var superAdminPublisherRouter = router({
  // ==========================================================================
  // Brand Context Selection
  // ==========================================================================
  /**
   * List all brand profiles for the context selector
   */
  listBrandProfiles: superAdminProcedure.input(z31.object({
    search: z31.string().optional(),
    limit: z31.number().default(50)
  })).query(async ({ input }) => {
    return await developerBrandProfileService.listBrandProfiles({
      search: input.search,
      limit: input.limit
      // We want all profiles including platform-owned ones
    });
  }),
  /**
   * Get full details of a specific brand profile for context hydration
   */
  getBrandContext: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int()
  })).query(async ({ input }) => {
    return await developerBrandProfileService.getBrandProfileWithStats(input.brandProfileId);
  }),
  /**
   * Create a new brand profile (Context Creation)
   */
  createBrandProfile: superAdminProcedure.input(z31.object({
    // Identity
    brandName: z31.string().min(2),
    brandTier: z31.enum(["national", "regional", "boutique"]).default("regional"),
    identityType: z31.enum(["developer", "marketing_agency", "hybrid"]).default("developer"),
    logoUrl: z31.string().optional(),
    // Company Info
    description: z31.string().optional(),
    category: z31.string().optional(),
    establishedYear: z31.number().nullable().optional(),
    website: z31.string().optional(),
    // Contact Info
    email: z31.string().email().optional().or(z31.literal("")),
    phone: z31.string().optional(),
    address: z31.string().optional(),
    city: z31.string().optional(),
    province: z31.string().optional(),
    // Portfolio
    completedProjects: z31.number().default(0),
    currentProjects: z31.number().default(0),
    upcomingProjects: z31.number().default(0),
    specializations: z31.array(z31.string()).default([]),
    operatingProvinces: z31.array(z31.string()).optional()
  })).mutation(async ({ input }) => {
    const result = await developerBrandProfileService.createBrandProfile({
      brandName: input.brandName,
      brandTier: input.brandTier,
      identityType: input.identityType,
      logoUrl: input.logoUrl,
      // Map extended fields
      about: input.description,
      // Category is not directly on developerBrandProfiles schema based on service check,
      // but we can map it to 'propertyFocus' or store in 'about' if needed.
      // Re-checking service definition: propertyFocus is string[]. 
      // We'll treat category as primary property focus.
      propertyFocus: input.category ? [input.category, ...input.specializations] : input.specializations,
      foundedYear: input.establishedYear,
      websiteUrl: input.website,
      publicContactEmail: input.email,
      // Combine address components for headOfficeLocation
      headOfficeLocation: input.city && input.province ? `${input.address ? input.address + ", " : ""}${input.city}, ${input.province}` : input.address,
      operatingProvinces: input.operatingProvinces || (input.province ? [input.province] : []),
      // Note: Project counts are currently not in createBrandProfileInput in service
      // We might need to handle them separately or update service if they are critical
      // Looking at service, it has 'totalLeadsReceived' etc but not project counts?
      // Wait, 'developerBrandProfiles' table schema check needed. 
      // Based on service 'createBrandProfile', it takes 'CreateBrandProfileInput'.
      isVisible: true
    });
    return result;
  }),
  /**
   * Update an existing brand profile
   */
  updateBrandProfile: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int(),
    // Identity
    brandName: z31.string().min(2).optional(),
    brandTier: z31.enum(["national", "regional", "boutique"]).optional(),
    identityType: z31.enum(["developer", "marketing_agency", "hybrid"]).optional(),
    logoUrl: z31.string().optional(),
    // Company Info
    description: z31.string().optional(),
    category: z31.string().optional(),
    establishedYear: z31.number().nullable().optional(),
    website: z31.string().optional(),
    // Contact Info
    email: z31.string().email().optional().or(z31.literal("")),
    phone: z31.string().optional(),
    address: z31.string().optional(),
    city: z31.string().optional(),
    province: z31.string().optional(),
    // Portfolio (We will just map specializations for now as project counts aren't in schema update yet)
    specializations: z31.array(z31.string()).optional(),
    operatingProvinces: z31.array(z31.string()).optional()
  })).mutation(async ({ input }) => {
    let headOfficeLocation = void 0;
    if (input.city || input.address || input.province) {
      headOfficeLocation = `${input.address || ""}, ${input.city || ""}, ${input.province || ""}`.replace(/^, /, "").replace(/, ,/, ",");
    }
    await developerBrandProfileService.updateBrandProfile(input.brandProfileId, {
      brandName: input.brandName,
      brandTier: input.brandTier,
      identityType: input.identityType,
      logoUrl: input.logoUrl,
      about: input.description,
      foundedYear: input.establishedYear,
      websiteUrl: input.website,
      publicContactEmail: input.email,
      propertyFocus: input.specializations,
      // simplified mapping
      headOfficeLocation,
      // strict update
      operatingProvinces: input.operatingProvinces
    });
    return { success: true };
  }),
  /**
   * Delete a brand profile
   */
  deleteBrandProfile: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int()
  })).mutation(async ({ input }) => {
    return await developerBrandProfileService.deleteBrandProfile(input.brandProfileId);
  }),
  // ==========================================================================
  // Development Management (Context-Aware)
  // ==========================================================================
  /**
   * List developments for the selected brand context
   */
  getDevelopments: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int(),
    status: z31.enum(["all", "draft", "pending", "approved", "rejected", "published"]).optional(),
    search: z31.string().optional()
  })).query(async ({ input }) => {
    return await developerBrandProfileService.getBrandDevelopments(input.brandProfileId);
  }),
  /**
   * Create a development under the selected brand context
   */
  createDevelopment: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int(),
    name: z31.string().min(2),
    description: z31.string().optional(),
    city: z31.string(),
    province: z31.string(),
    developmentType: z31.enum(["residential", "commercial", "mixed_use", "estate", "complex"])
  })).mutation(async ({ input, ctx }) => {
    const dbConn = await getDb();
    if (!dbConn) throw new Error("Database not available");
    const [result] = await dbConn.insert(developments).values({
      name: input.name,
      description: input.description,
      city: input.city,
      province: input.province,
      developmentType: input.developmentType,
      developerBrandProfileId: input.brandProfileId,
      devOwnerType: "platform",
      // Crucial: distinct from subscriber-owned
      // Default platform-safe values
      isPublished: 0,
      approvalStatus: "draft",
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      views: 0,
      isFeatured: 0,
      slug: input.name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") + "-" + Date.now().toString().slice(-4)
    });
    return {
      id: result.insertId,
      message: "Development created under brand context"
    };
  }),
  /**
   * Update a development (must check brand context ownership)
   */
  updateDevelopment: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int(),
    developmentId: z31.number().int(),
    data: z31.any()
    // Flexible partial update, validating ownership first
  })).mutation(async ({ input, ctx }) => {
    const dbConn = await getDb();
    if (!dbConn) throw new Error("Database not available");
    const [dev] = await dbConn.select().from(developments).where(and33(
      eq39(developments.id, input.developmentId),
      eq39(developments.developerBrandProfileId, input.brandProfileId)
    ));
    if (!dev) {
      throw new TRPCError12({
        code: "NOT_FOUND",
        message: "Development not found or does not belong to this brand context"
      });
    }
    await dbConn.update(developments).set({
      ...input.data,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    }).where(eq39(developments.id, input.developmentId));
    return { success: true };
  }),
  // ==========================================================================
  // Leads & Metrics (Context-Aware)
  // ==========================================================================
  /**
   * Get leads captured for this brand
   */
  getBrandLeads: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int(),
    limit: z31.number().default(50),
    offset: z31.number().default(0)
  })).query(async ({ input }) => {
    const dbConn = await getDb();
    if (!dbConn) throw new Error("Database not available");
    const brandLeads = await dbConn.select().from(leads).where(eq39(leads.developerBrandProfileId, input.brandProfileId)).orderBy(desc26(leads.createdAt)).limit(input.limit).offset(input.offset);
    return brandLeads;
  }),
  /**
   * Get aggregated metrics for this brand
   */
  getBrandMetrics: superAdminProcedure.input(z31.object({
    brandProfileId: z31.number().int()
  })).query(async ({ input }) => {
    return await developerBrandProfileService.getBrandLeadStats(input.brandProfileId);
  })
});

// server/routers.ts
var appRouter = router({
  system: systemRouter,
  // ... other routers
  analytics: analyticsRouter,
  monetization: monetizationRouter,
  // partners: partnerRouter,
  admin: adminRouter,
  agency: agencyRouter,
  user: userRouter,
  invitation: invitationRouter,
  agent: agentRouter,
  aiAgent: aiAgentRouter,
  video: videoRouter,
  billing: billingRouter,
  location: locationRouter,
  enhancedLocation: enhancedLocationRouter,
  googleMaps: googleMapsRouter,
  priceInsights: priceInsightsRouter,
  listing: listingRouter,
  upload: uploadRouter,
  settings: settingsRouter,
  savedSearch: savedSearchRouter,
  guestMigration: guestMigrationRouter,
  dev: devRouter,
  // â ï¸ DEV ONLY - Remove before production
  marketing: marketingRouter,
  subscription: subscriptionRouter,
  developer: developerRouter,
  explore: exploreRouter,
  exploreVideoUpload: exploreVideoUploadRouter,
  // recommendationEngine: recommendationEngineRouter, // TODO: Fix syntax errors in this file
  // exploreApi: exploreApiRouter, // TODO: Fix syntax errors in this file  
  // boostCampaign: boostCampaignRouter, // TODO: Fix syntax errors in this file
  exploreAnalytics: exploreAnalyticsRouter,
  similarProperties: similarPropertiesRouter,
  cache: cacheRouter,
  locationPages: locationPagesRouter,
  brandProfile: brandProfileRouter,
  superAdminPublisher: superAdminPublisherRouter,
  propertyResults: propertyResultsRouter,
  auth: router({
    me: publicProcedure.query((opts) => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return {
        success: true
      };
    })
  }),
  properties: router({
    search: publicProcedure.input(
      z32.object({
        city: z32.string().optional(),
        province: z32.string().optional(),
        suburb: z32.array(z32.string()).optional(),
        // Added support for suburb array
        locations: z32.array(z32.string()).optional(),
        // Multi-location support
        propertyType: z32.enum([
          "apartment",
          "house",
          "villa",
          "plot",
          "commercial",
          "townhouse",
          "cluster_home",
          "farm",
          "shared_living"
        ]).optional(),
        listingType: z32.enum(["sale", "rent", "rent_to_buy", "auction", "shared_living"]).optional(),
        minPrice: z32.number().optional(),
        maxPrice: z32.number().optional(),
        minBedrooms: z32.number().optional(),
        maxBedrooms: z32.number().optional(),
        minBathrooms: z32.number().optional(),
        // Added
        minArea: z32.number().optional(),
        maxArea: z32.number().optional(),
        status: z32.enum(["available", "sold", "rented", "pending"]).optional(),
        ownershipType: z32.array(z32.enum(OWNERSHIP_TYPES)).optional(),
        structuralType: z32.array(z32.enum(STRUCTURAL_TYPES)).optional(),
        floors: z32.array(z32.enum(FLOOR_TYPES)).optional(),
        amenities: z32.array(z32.string()).optional(),
        postedBy: z32.array(z32.string()).optional(),
        minLat: z32.number().optional(),
        maxLat: z32.number().optional(),
        minLng: z32.number().optional(),
        maxLng: z32.number().optional(),
        limit: z32.number().default(20),
        offset: z32.number().default(0),
        sortOption: z32.enum([
          "price_asc",
          "price_desc",
          "date_desc",
          "date_asc",
          "suburb_asc",
          "suburb_desc"
        ]).optional()
        // Added sort option support
      })
    ).query(async ({ input }) => {
      const { propertySearchService: propertySearchService2 } = await Promise.resolve().then(() => (init_propertySearchService(), propertySearchService_exports));
      const filters = {
        city: input.city,
        province: input.province,
        suburb: input.suburb,
        // Now supported
        locations: input.locations,
        // Multi-location support
        propertyType: input.propertyType ? [input.propertyType] : void 0,
        // Service expects array
        listingType: input.listingType,
        minPrice: input.minPrice,
        maxPrice: input.maxPrice,
        minBedrooms: input.minBedrooms,
        maxBedrooms: input.maxBedrooms,
        minBathrooms: input.minBathrooms,
        minErfSize: input.minArea,
        // Map area to erfSize/floorSize as generic size filter
        maxErfSize: input.maxArea,
        status: input.status ? [input.status] : void 0,
        // Service expects array
        amenities: input.amenities,
        // Note: Service might need update if it processes amenities differently, but looks okay
        // postedBy handling might differ or need explicit mapping if service supports it
        bounds: input.minLat && input.maxLat && input.minLng && input.maxLng ? {
          south: input.minLat,
          north: input.maxLat,
          west: input.minLng,
          east: input.maxLng
        } : void 0
      };
      const page = Math.floor(input.offset / input.limit) + 1;
      return await propertySearchService2.searchProperties(
        filters,
        input.sortOption || "date_desc",
        page,
        input.limit
      );
    }),
    featured: publicProcedure.input(
      z32.object({
        limit: z32.number().default(6)
      })
    ).query(async ({ input }) => {
      return await getFeaturedListings(input.limit);
    }),
    // Get filter counts for search refinement
    getFilterCounts: publicProcedure.input(
      z32.object({
        filters: z32.object({
          city: z32.string().optional(),
          province: z32.string().optional(),
          suburb: z32.array(z32.string()).optional(),
          propertyType: z32.string().optional(),
          listingType: z32.string().optional(),
          minPrice: z32.number().optional(),
          maxPrice: z32.number().optional(),
          minBedrooms: z32.number().optional(),
          maxBedrooms: z32.number().optional()
        }).optional()
      })
    ).query(async ({ input }) => {
      try {
        const { propertySearchService: propertySearchService2 } = await Promise.resolve().then(() => (init_propertySearchService(), propertySearchService_exports));
        return await propertySearchService2.getFilterCounts(input.filters || {});
      } catch (error) {
        console.error("Error getting filter counts:", error);
        return { total: 0, byType: {}, byBedrooms: {}, byPriceRange: {} };
      }
    }),
    // getAll - Same as search but with city/propertyType filtering
    getAll: publicProcedure.input(
      z32.object({
        limit: z32.number().default(20),
        offset: z32.number().default(0),
        city: z32.string().optional(),
        propertyType: z32.string().optional()
      })
    ).query(async ({ input }) => {
      return await searchListings({
        city: input.city,
        propertyType: input.propertyType,
        limit: input.limit,
        offset: input.offset
      });
    }),
    getById: publicProcedure.input(
      z32.object({
        id: z32.number()
      })
    ).query(async ({ input }) => {
      await incrementPropertyViews(input.id);
      const listing = await getListingById(input.id);
      if (listing) {
        const rawImages = await getListingMedia(input.id);
        const bucketName = process.env.S3_BUCKET_NAME || "listify-properties-sa";
        const awsRegion = process.env.AWS_REGION || "af-south-1";
        const cdnUrl = process.env.CLOUDFRONT_URL || `https://${bucketName}.s3.${awsRegion}.amazonaws.com`;
        const images2 = rawImages.map((img) => {
          const imageUrl = img.originalUrl.startsWith("http") ? img.originalUrl : `${cdnUrl}/${img.originalUrl}`;
          return {
            id: img.id,
            imageUrl,
            isPrimary: img.isPrimary,
            displayOrder: img.displayOrder
          };
        });
        const propertyDetails = listing.propertyDetails || {};
        const transformedProperty = {
          ...listing,
          // Map pricing fields
          price: listing.askingPrice || listing.monthlyRent || listing.startingBid || 0,
          listingType: listing.action,
          // 'sell', 'rent', 'auction'
          transactionType: listing.action,
          // Extract property details from JSON
          bedrooms: propertyDetails.bedrooms || 0,
          bathrooms: propertyDetails.bathrooms || 0,
          area: propertyDetails.erfSizeM2 || propertyDetails.unitSizeM2 || propertyDetails.landSizeM2OrHa || propertyDetails.houseAreaM2 || 0,
          amenities: propertyDetails.amenitiesFeatures || propertyDetails.propertyHighlights || [],
          features: propertyDetails.propertyHighlights || propertyDetails.amenitiesFeatures || [],
          // Map property settings for specs display
          propertySettings: {
            ownershipType: propertyDetails.ownershipType,
            powerBackup: propertyDetails.powerBackup,
            securityFeatures: propertyDetails.securityFeatures,
            waterSupply: propertyDetails.waterSupply,
            internetAccess: propertyDetails.internetAccess,
            flooring: propertyDetails.flooring,
            parkingType: propertyDetails.parkingType,
            petFriendly: propertyDetails.petFriendly,
            electricitySupply: propertyDetails.electricitySupply,
            additionalRooms: propertyDetails.additionalRooms
          },
          // Map location fields
          zipCode: listing.postalCode,
          // Keep original fields
          ownerId: listing.ownerId
        };
        return { property: transformedProperty, images: images2 };
      }
      const property = await getPropertyById(input.id);
      const images = await getPropertyImages(input.id);
      return { property, images };
    }),
    getImages: publicProcedure.input(
      z32.object({
        propertyId: z32.number()
      })
    ).query(async ({ input }) => {
      return await getPropertyImages(input.propertyId);
    }),
    // Property Management (CRUD) - Protected
    create: protectedProcedure.input(
      z32.object({
        title: z32.string().min(5, "Title must be at least 5 characters").max(255),
        description: z32.string().min(10, "Description must be at least 10 characters"),
        propertyType: z32.enum([
          "apartment",
          "house",
          "villa",
          "plot",
          "commercial",
          "townhouse",
          "cluster_home",
          "farm",
          "shared_living"
        ]),
        listingType: z32.enum(["sale", "rent", "rent_to_buy", "auction", "shared_living"]),
        price: z32.number().positive("Price must be positive"),
        bedrooms: z32.number().int().positive().optional(),
        bathrooms: z32.number().int().positive().optional(),
        area: z32.number().positive("Area must be positive"),
        address: z32.string().min(5, "Address must be at least 5 characters"),
        city: z32.string().min(2, "City must be at least 2 characters"),
        province: z32.string().min(2, "Province must be at least 2 characters"),
        zipCode: z32.string().optional(),
        latitude: z32.string().optional(),
        longitude: z32.string().optional(),
        amenities: z32.array(z32.string()).optional(),
        yearBuilt: z32.number().int().positive().optional(),
        levies: z32.number().int().optional(),
        ratesAndTaxes: z32.number().int().optional(),
        videoUrl: z32.string().url().optional(),
        virtualTourUrl: z32.string().url().optional(),
        agentId: z32.number().int().optional(),
        developmentId: z32.number().int().optional(),
        images: z32.array(z32.string()).min(1, "At least one image is required")
        // Array of image URLs
      })
    ).mutation(async ({ ctx, input }) => {
      const { images, ...propertyData } = input;
      const propertyId = await createProperty({
        ...propertyData,
        amenities: input.amenities ? JSON.stringify(input.amenities) : null,
        ownerId: ctx.user.id,
        status: "available",
        featured: 0,
        views: 0,
        transactionType: input.listingType === "rent" ? "rent" : "sale"
      });
      for (let i = 0; i < images.length; i++) {
        await createPropertyImage({
          propertyId: Number(propertyId),
          imageUrl: images[i],
          isPrimary: i === 0 ? 1 : 0,
          displayOrder: i
        });
      }
      return { success: true, propertyId: Number(propertyId) };
    }),
    update: protectedProcedure.input(
      z32.object({
        id: z32.number().int().positive(),
        title: z32.string().min(5).max(255).optional(),
        description: z32.string().min(10).optional(),
        propertyType: z32.enum([
          "apartment",
          "house",
          "villa",
          "plot",
          "commercial",
          "townhouse",
          "cluster_home",
          "farm",
          "shared_living"
        ]).optional(),
        listingType: z32.enum(["sale", "rent", "rent_to_buy", "auction", "shared_living"]).optional(),
        price: z32.number().positive().optional(),
        bedrooms: z32.number().int().positive().optional(),
        bathrooms: z32.number().int().positive().optional(),
        area: z32.number().positive().optional(),
        address: z32.string().min(5).optional(),
        city: z32.string().min(2).optional(),
        province: z32.string().min(2).optional(),
        zipCode: z32.string().optional(),
        latitude: z32.string().optional(),
        longitude: z32.string().optional(),
        amenities: z32.array(z32.string()).optional(),
        yearBuilt: z32.number().int().positive().optional(),
        levies: z32.number().int().optional(),
        ratesAndTaxes: z32.number().int().optional(),
        videoUrl: z32.string().url().optional(),
        virtualTourUrl: z32.string().url().optional(),
        agentId: z32.number().int().optional(),
        developmentId: z32.number().int().optional(),
        status: z32.enum(["available", "sold", "rented", "pending"]).optional()
      })
    ).mutation(async ({ ctx, input }) => {
      const property = await getPropertyById(input.id);
      if (!property || property.ownerId !== ctx.user.id) {
        throw new Error("Unauthorized");
      }
      await updateProperty(input.id, {
        ...input,
        amenities: input.amenities ? JSON.stringify(input.amenities) : void 0,
        updatedAt: /* @__PURE__ */ new Date()
      });
      return { success: true };
    }),
    delete: protectedProcedure.input(
      z32.object({
        id: z32.number().int().positive()
      })
    ).mutation(async ({ ctx, input }) => {
      const property = await getPropertyById(input.id);
      if (!property || property.ownerId !== ctx.user.id) {
        throw new Error("Unauthorized");
      }
      await deleteProperty(input.id);
      return { success: true };
    }),
    // Favorites
    toggleFavorite: protectedProcedure.input(
      z32.object({
        propertyId: z32.number().int().positive()
      })
    ).mutation(async ({ ctx, input }) => {
      const existing = await isFavorite(ctx.user.id, input.propertyId);
      if (existing) {
        await removeFavorite(ctx.user.id, input.propertyId);
        return { favorited: false };
      } else {
        await addFavorite(ctx.user.id, input.propertyId);
        return { favorited: true };
      }
    }),
    getFavorites: protectedProcedure.query(async ({ ctx }) => {
      return await getUserFavorites(ctx.user.id);
    })
  })
});

// server/_core/context.ts
init_auth();
async function createContext(opts) {
  console.log("=== TRPC CONTEXT ===");
  console.log("Path:", opts.req.path);
  console.log("Raw Cookie Header:", opts.req.headers.cookie);
  console.log("Parsed Cookies:", opts.req.cookies);
  console.log("All Cookie Keys:", Object.keys(opts.req.cookies || {}));
  console.log("SessionId Cookie:", opts.req.cookies?.app_session_id);
  console.log("===================");
  let user = null;
  try {
    user = await authService.authenticateRequest(opts.req);
  } catch (error) {
    user = null;
  }
  return {
    req: opts.req,
    res: opts.res,
    user
  };
}

// server/_core/vite.ts
import express from "express";
import fs from "fs";
import { nanoid as nanoid3 } from "nanoid";
import path2 from "path";
import { createServer as createViteServer } from "vite";

// vite.config.ts
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import path from "path";
import { defineConfig } from "vite";
var plugins = [react(), tailwindcss()];
var vite_config_default = defineConfig({
  plugins,
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  envDir: path.resolve(import.meta.dirname),
  root: path.resolve(import.meta.dirname, "client"),
  publicDir: path.resolve(import.meta.dirname, "client", "public"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
    minify: "terser",
    terserOptions: {
      keep_fnames: true,
      mangle: {
        keep_fnames: true
      }
    },
    // Prevent name mangling issues with wouter
    rollupOptions: {
      output: {
        manualChunks: void 0
      }
    }
  },
  server: {
    host: true,
    port: 3009,
    allowedHosts: ["localhost", "127.0.0.1"],
    fs: {
      strict: true,
      deny: ["**/.*"]
    },
    proxy: {
      "/api": {
        target: process.env.VITE_API_URL || "http://localhost:5000",
        changeOrigin: true,
        secure: false
      },
      "/trpc": {
        target: process.env.VITE_API_URL || "http://localhost:5000",
        changeOrigin: true,
        secure: false
      }
    }
  }
});

// server/_core/vite.ts
async function setupVite(app, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    server: serverOptions,
    appType: "custom"
  });
  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(import.meta.dirname, "../..", "client", "index.html");
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(`src="/src/main.tsx"`, `src="/src/main.tsx?v=${nanoid3()}"`);
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    console.error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app.use(express.static(distPath));
  app.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/_core/stripeWebhooks.ts
init_db();
init_schema();
import { eq as eq40, and as and34 } from "drizzle-orm";
import { TRPCError as TRPCError13 } from "@trpc/server";
var emailService = process.env.NODE_ENV === "development" || process.env.VITE_USE_MOCK_EMAILS === "true" ? MockEmailService : EmailService2;
var handleStripeWebhook = async (req, res) => {
  if (!stripe) {
    console.warn("Stripe not configured, skipping webhook processing");
    return res.status(200).json({ received: true, status: "stripe_not_configured" });
  }
  const db3 = await getDb();
  if (!db3) {
    throw new TRPCError13({
      code: "INTERNAL_SERVER_ERROR",
      message: "Database not available"
    });
  }
  try {
    const event = verifyStripeWebhook(req.body, req.headers["stripe-signature"]);
    console.log(`\u{1F514} Webhook received: ${event.type}`);
    switch (event.type) {
      case "customer.subscription.created":
        await handleSubscriptionCreated(event.data.object, db3);
        break;
      case "customer.subscription.updated":
        await handleSubscriptionUpdated(event.data.object, db3);
        break;
      case "customer.subscription.deleted":
        await handleSubscriptionDeleted(event.data.object, db3);
        break;
      case "invoice.payment_succeeded":
        await handleInvoicePaymentSucceeded(event.data.object, db3);
        break;
      case "invoice.payment_failed":
        await handleInvoicePaymentFailed(event.data.object, db3);
        break;
      case "checkout.session.completed":
        await handleCheckoutSessionCompleted(event.data.object, db3);
        break;
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
    res.json({ received: true });
  } catch (error) {
    console.error("Webhook error:", error);
    res.status(400).send(`Webhook Error: ${error}`);
  }
};
async function handleSubscriptionCreated(subscription, db3) {
  try {
    const [existingSubscription] = await db3.select().from(agencySubscriptions).where(eq40(agencySubscriptions.stripeSubscriptionId, subscription.id)).limit(1);
    if (existingSubscription) {
      if (subscription.status === "active" && existingSubscription.status !== "active") {
        const [agency] = await db3.select().from(agencies).where(eq40(agencies.id, existingSubscription.agencyId)).limit(1);
        const [plan] = await db3.select().from(plans).where(eq40(plans.id, existingSubscription.planId)).limit(1);
        if (agency && plan) {
          await EmailService2.sendSubscriptionCreatedEmail(
            agency.email,
            agency.name,
            plan.displayName
          );
        }
      }
      await db3.update(agencySubscriptions).set({
        status: subscription.status,
        currentPeriodStart: subscription.current_period_start ? new Date(subscription.current_period_start * 1e3) : null,
        currentPeriodEnd: subscription.current_period_end ? new Date(subscription.current_period_end * 1e3) : null,
        trialEnd: subscription.trial_end ? new Date(subscription.trial_end * 1e3) : null,
        cancelAtPeriodEnd: subscription.cancel_at_period_end ? 1 : 0,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq40(agencySubscriptions.id, existingSubscription.id));
    }
    console.log(`\u2705 Subscription created: ${subscription.id}`);
  } catch (error) {
    console.error("Error handling subscription created:", error);
  }
}
async function handleSubscriptionUpdated(subscription, db3) {
  try {
    const updateData = {
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1e3),
      currentPeriodEnd: new Date(subscription.current_period_end * 1e3),
      trialEnd: subscription.trial_end ? new Date(subscription.trial_end * 1e3) : null,
      cancelAtPeriodEnd: subscription.cancel_at_period_end ? 1 : 0,
      canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1e3) : null,
      endedAt: subscription.ended_at ? new Date(subscription.ended_at * 1e3) : null,
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (subscription.items.data[0]?.price?.id) {
      updateData.stripePriceId = subscription.items.data[0].price.id;
    }
    await db3.update(agencySubscriptions).set(updateData).where(eq40(agencySubscriptions.stripeSubscriptionId, subscription.id));
    console.log(`\u2705 Subscription updated: ${subscription.id}`);
  } catch (error) {
    console.error("Error handling subscription updated:", error);
  }
}
async function handleSubscriptionDeleted(subscription, db3) {
  try {
    const [existingSubscription] = await db3.select().from(agencySubscriptions).where(eq40(agencySubscriptions.stripeSubscriptionId, subscription.id)).limit(1);
    if (existingSubscription) {
      await db3.update(agencySubscriptions).set({
        status: "canceled",
        endedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq40(agencySubscriptions.id, existingSubscription.id));
      const [agency] = await db3.select().from(agencies).where(eq40(agencies.id, existingSubscription.agencyId)).limit(1);
      if (agency) {
        const endDate = existingSubscription.currentPeriodEnd?.toLocaleDateString() || "period end";
        await EmailService2.sendSubscriptionCancelledEmail(agency.email, agency.name, endDate);
      }
      await db3.update(agencies).set({
        subscriptionPlan: "free",
        subscriptionStatus: "canceled",
        subscriptionExpiry: null,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq40(agencies.id, existingSubscription.agencyId));
    }
    console.log(`\u2705 Subscription canceled: ${subscription.id}`);
  } catch (error) {
    console.error("Error handling subscription deleted:", error);
  }
}
async function handleInvoicePaymentSucceeded(invoice, db3) {
  try {
    const invoiceData = {
      agencyId: 0,
      // Will be set below
      stripeInvoiceId: invoice.id,
      stripeCustomerId: invoice.customer,
      amount: invoice.amount_due,
      currency: invoice.currency,
      status: "paid",
      invoicePdf: invoice.invoice_pdf,
      hostedInvoiceUrl: invoice.hosted_invoice_url,
      invoiceNumber: invoice.number,
      periodStart: invoice.period_start ? new Date(invoice.period_start * 1e3) : null,
      periodEnd: invoice.period_end ? new Date(invoice.period_end * 1e3) : null,
      paidAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    const [subscription] = await db3.select().from(agencySubscriptions).where(eq40(agencySubscriptions.stripeCustomerId, invoice.customer)).limit(1);
    if (subscription) {
      invoiceData.agencyId = subscription.agencyId;
      await db3.insert(invoices).values(invoiceData).onDuplicateKeyUpdate({
        set: invoiceData
      });
    }
    console.log(`\u2705 Invoice paid: ${invoice.id}`);
  } catch (error) {
    console.error("Error handling invoice payment succeeded:", error);
  }
}
async function handleInvoicePaymentFailed(invoice, db3) {
  try {
    await db3.update(invoices).set({
      status: "uncollectible",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq40(invoices.stripeInvoiceId, invoice.id));
    console.log(`\u274C Invoice payment failed: ${invoice.id}`);
  } catch (error) {
    console.error("Error handling invoice payment failed:", error);
  }
}
async function handleCheckoutSessionCompleted(session, db3) {
  try {
    const { agencyId, planId } = session.metadata || {};
    if (!agencyId || !planId) {
      console.warn("\u26A0\uFE0F  Missing metadata in checkout session:", session.id);
      return;
    }
    const numericAgencyId = parseInt(agencyId, 10);
    const numericPlanId = parseInt(planId, 10);
    await db3.update(agencies).set({
      subscriptionStatus: "active",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq40(agencies.id, numericAgencyId));
    const [agency] = await db3.select({
      id: agencies.id,
      name: agencies.name,
      email: agencies.email,
      ownerEmail: users.email,
      ownerName: users.name,
      ownerFirstName: users.firstName
    }).from(agencies).leftJoin(users, eq40(agencies.id, users.agencyId)).where(eq40(agencies.id, numericAgencyId)).limit(1);
    if (!agency) {
      console.error(`\u274C Agency ${agencyId} not found after checkout`);
      return;
    }
    const [plan] = await db3.select().from(plans).where(eq40(plans.id, numericPlanId)).limit(1);
    const teamInvitations = await db3.select().from(invitations).where(and34(eq40(invitations.agencyId, numericAgencyId), eq40(invitations.status, "pending"))).limit(50);
    let successCount = 0;
    const appUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    for (const invitation of teamInvitations) {
      try {
        const inviteUrl = `${appUrl}/invite/accept?token=${invitation.token}`;
        const inviterName = agency.ownerName || agency.ownerFirstName || agency.ownerEmail?.split("@")[0] || "Your colleague";
        await emailService.sendEmail({
          to: invitation.email,
          subject: `You've been invited to join ${agency.name}`,
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h1>You're Invited! \u{1F389}</h1>
              <p>
                <strong>${inviterName}</strong> has invited you to join 
                <strong>${agency.name}</strong> on SA Property Portal.
              </p>
              
              <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <p style="margin: 0 0 10px 0;"><strong>What's next?</strong></p>
                <ol style="margin: 0; padding-left: 20px;">
                  <li>Click the button below to accept your invitation</li>
                  <li>Create your account or sign in</li>
                  <li>Start collaborating with your team!</li>
                </ol>
              </div>

              <a href="${inviteUrl}" 
                 style="display: inline-block; background: #2563eb; color: white; 
                        padding: 12px 24px; text-decoration: none; border-radius: 6px; 
                        font-weight: bold; margin: 20px 0;">
                Accept Invitation
              </a>

              <p style="color: #666; font-size: 14px;">
                This invitation expires on ${new Date(invitation.expiresAt).toLocaleDateString()}.
              </p>

              <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
              
              <p style="color: #999; font-size: 12px;">
                If you didn't expect this invitation, you can safely ignore this email.
              </p>
            </div>
          `
        });
        successCount++;
        console.log(`\u2705 Invitation sent to ${invitation.email} for agency ${agencyId}`);
      } catch (error) {
        console.error(`\u274C Failed to send invitation to ${invitation.email}:`, error);
      }
    }
    console.log(
      `\u{1F4E7} Sent ${successCount}/${teamInvitations.length} team invitations for agency ${agencyId}`
    );
    if (agency.email) {
      try {
        await emailService.sendEmail({
          to: agency.email,
          subject: `Welcome to SA Property Portal, ${agency.name}!`,
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h1>Welcome aboard, ${agency.name}! \u{1F3E0}</h1>
              
              <p>
                Congratulations! Your agency is now active on our platform with the 
                <strong>${plan?.displayName || "selected"}</strong> plan.
              </p>

              <div style="background: #f0fdf4; border-left: 4px solid #22c55e; 
                          padding: 15px; margin: 20px 0;">
                <p style="margin: 0;"><strong>\u2705 Your account is fully activated</strong></p>
                <p style="margin: 10px 0 0 0;">
                  ${successCount > 0 ? `We've sent invitations to ${successCount} team member${successCount > 1 ? "s" : ""}.` : "You can invite team members from your dashboard."}
                </p>
              </div>

              <h3>Next Steps:</h3>
              <ol>
                <li>Complete your agency profile</li>
                <li>Add your first property listing</li>
                <li>Invite additional team members</li>
                <li>Configure your branding preferences</li>
              </ol>

              <a href="${appUrl}/agency/dashboard" 
                 style="display: inline-block; background: #2563eb; color: white; 
                        padding: 12px 24px; text-decoration: none; border-radius: 6px; 
                        font-weight: bold; margin: 20px 0;">
                Go to Dashboard
              </a>

              <p style="color: #666; margin-top: 30px;">
                Need help getting started? Contact our support team for assistance.
              </p>
            </div>
          `
        });
        console.log(`\u2705 Welcome email sent to ${agency.email}`);
      } catch (error) {
        console.error(`\u274C Failed to send welcome email:`, error);
      }
    }
    console.log(`\u2705 Checkout completed and processed: ${session.id}`);
  } catch (error) {
    console.error("\u274C Error handling checkout session completed:", error);
    throw error;
  }
}

// server/_core/domainRouter.ts
init_db();
init_schema();
import express2 from "express";
import { eq as eq41 } from "drizzle-orm";
var router2 = express2.Router();
var domainRoutingMiddleware = async (req, res, next) => {
  const db3 = await getDb();
  if (!db3) {
    return next();
  }
  const host = req.headers.host;
  const subdomain = getSubdomain(host);
  if (subdomain && subdomain !== "www" && subdomain !== "app") {
    try {
      const [branding] = await db3.select().from(agencyBranding).where(eq41(agencyBranding.subdomain, subdomain)).limit(1);
      if (branding && branding.isEnabled) {
        req.agencyBranding = branding;
        req.isWhiteLabel = true;
      }
    } catch (error) {
      console.error("Domain routing error:", error);
    }
  }
  next();
};
function getSubdomain(hostname) {
  if (!hostname) return null;
  const host = hostname.split(":")[0];
  if (host === "localhost" || host.startsWith("localhost:")) {
    return null;
  }
  const parts = host.split(".");
  if (parts.length >= 3) {
    return parts[0];
  }
  return null;
}
var customDomainMiddleware = async (req, res, next) => {
  const db3 = await getDb();
  if (!db3) {
    return next();
  }
  const host = req.headers.host?.split(":")[0];
  if (host) {
    try {
      const [branding] = await db3.select().from(agencyBranding).where(eq41(agencyBranding.customDomain, host)).limit(1);
      if (branding && branding.isEnabled) {
        req.agencyBranding = branding;
        req.isWhiteLabel = true;
        req.isCustomDomain = true;
      }
    } catch (error) {
      console.error("Custom domain routing error:", error);
    }
  }
  next();
};

// server/_core/index.ts
async function startServer() {
  if (!process.env.JWT_SECRET) {
    console.error("\n\u274C CRITICAL ERROR: JWT_SECRET is not defined in environment variables.");
    console.error("   Login functionality will fail with HTTP 500 errors.");
    console.error("   Please set JWT_SECRET in your .env file or deployment configuration.\n");
  }
  await initializeCache();
  const app = express4();
  const server = createServer(app);
  const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 5,
    // 5 login attempts
    message: "Too many login attempts, please try again later",
    standardHeaders: true,
    legacyHeaders: false
  });
  app.use("/api/auth/login", authLimiter);
  app.use("/api/auth/register", authLimiter);
  const allowedOrigins = [
    "http://localhost:5173",
    // Vite dev
    "http://localhost:3000",
    // Local dev
    "http://localhost:5000",
    // Local dev (port 5000)
    "https://real-estate-portal-xi.vercel.app",
    // Vercel production
    "https://realestateportal-production-8e32.up.railway.app",
    // Railway backend (old)
    "https://realestateportal-production-9bb8.up.railway.app",
    // Railway backend (current)
    "https://www.propertylistifysa.co.za",
    // Production Domain
    "https://propertylistifysa.co.za"
    // Production Domain (non-www)
  ];
  app.use(
    cors({
      origin: (origin, callback) => {
        if (!origin) return callback(null, true);
        if (allowedOrigins.includes(origin) || origin.endsWith(".vercel.app")) {
          console.log(`\u2705 CORS: Allowed origin: ${origin}`);
          callback(null, true);
        } else {
          console.warn(`\u274C CORS: Blocked origin: ${origin}`);
          callback(new Error("Not allowed by CORS"));
        }
      },
      credentials: true,
      methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "trpc-batch-mode"],
      exposedHeaders: ["Set-Cookie"],
      maxAge: 86400
      // 24 hours
    })
  );
  app.use(express4.json({ limit: "50mb" }));
  app.use(express4.urlencoded({ limit: "50mb", extended: true }));
  app.use(domainRoutingMiddleware);
  app.use(customDomainMiddleware);
  registerAuthRoutes(app);
  app.get("/api/test", async (req, res) => {
    try {
      const { db: db3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      await db3.execute(sql35`SELECT 1`);
      res.json({
        message: "Backend is running!",
        database: "Connected",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("DB Check Failed:", error);
      res.status(500).json({
        message: "Backend is running but Database is unavailable",
        database: "Error",
        error: error.message,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  app.post("/api/webhooks/stripe", express4.raw({ type: "application/json" }), handleStripeWebhook);
  app.use(
    "/api/trpc",
    createExpressMiddleware({
      router: appRouter,
      createContext,
      transformer: superjson2,
      onError({ error, path: path3, type }) {
        console.error("\u274C tRPC Error:", {
          path: path3,
          type,
          code: error.code,
          message: error.message,
          stack: error.stack,
          cause: error.cause
        });
      }
    })
  );
  const analyticsRouter2 = await Promise.resolve().then(() => (init_analytics(), analytics_exports));
  app.use("/api/analytics", analyticsRouter2.default);
  const partnerRouter = await Promise.resolve().then(() => (init_partnerRouter(), partnerRouter_exports));
  app.use("/api/partners", partnerRouter.default);
  const partnerAnalyticsRouter = await Promise.resolve().then(() => (init_partnerAnalyticsRouter(), partnerAnalyticsRouter_exports));
  app.use("/api/partner-analytics", partnerAnalyticsRouter.default);
  const contentRouter = await Promise.resolve().then(() => (init_contentRouter(), contentRouter_exports));
  app.use("/api/content", contentRouter.default);
  const topicsRouter = await Promise.resolve().then(() => (init_topicsRouter(), topicsRouter_exports));
  app.use("/api/topics", topicsRouter.default);
  const partnerSubscriptionRouter = await Promise.resolve().then(() => (init_partnerSubscriptionRouter(), partnerSubscriptionRouter_exports));
  app.use("/api/subscriptions", partnerSubscriptionRouter.default);
  const partnerBoostCampaignRouter = await Promise.resolve().then(() => (init_partnerBoostCampaignRouter(), partnerBoostCampaignRouter_exports));
  app.use("/api/boosts", partnerBoostCampaignRouter.default);
  const partnerLeadRouter = await Promise.resolve().then(() => (init_partnerLeadRouter(), partnerLeadRouter_exports));
  app.use("/api/leads", partnerLeadRouter.default);
  console.log("[Server] NODE_ENV:", process.env.NODE_ENV);
  console.log("[Server] SKIP_FRONTEND:", process.env.SKIP_FRONTEND);
  if (process.env.NODE_ENV === "development" && process.env.SKIP_FRONTEND !== "true") {
    console.log("[Server] Using Vite development server");
    await setupVite(app, server);
  } else if (process.env.NODE_ENV !== "development" && process.env.SKIP_FRONTEND !== "true") {
    console.log("[Server] Serving static files");
    serveStatic(app);
  } else {
    console.log("[Server] Skipping frontend static file serving (backend-only mode)");
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  console.log("----------------------------------------");
  console.log(`[Server] Starting on port ${port}`);
  console.log("----------------------------------------");
  server.listen(port, "0.0.0.0", () => {
    console.log(`Backend running on http://localhost:${port}`);
    console.log(`tRPC endpoint: http://localhost:${port}/trpc`);
    console.log(`Environment: ${process.env.NODE_ENV || "development"}`);
  });
}
startServer().catch(console.error);
process.on("SIGTERM", async () => {
  console.log("SIGTERM received, shutting down...");
  await shutdownCache();
  process.exit(0);
});
process.on("SIGINT", async () => {
  console.log("SIGINT received, shutting down...");
  await shutdownCache();
  process.exit(0);
});
